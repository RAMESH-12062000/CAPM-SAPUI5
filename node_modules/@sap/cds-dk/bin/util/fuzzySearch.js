/**
 * Levenshtein distance algorithm using recursive calls and cache
 *
 * @param input search the list for a best match for this string
 * @param list a list of strings to match input against
 * @param log logging method to use, might be null if no logging is wanted
 * @returns array with best matches, is never null but might be empty in case no search was possible
 */


const cache = {};


module.exports = (input, list, log) => {
  let minDistWords = [];

  if (input.length > 50 || list.length > 50) {
    return minDistWords;
  }

  let minDist = Number.MAX_SAFE_INTEGER;

  log && log('\nword\t\tlevDist\t\ttime(ms)');

  let runtime = 0;

  for (const word of list) {
    const start = log && Date.now();
    const levDist = levDistance(input, word);

    if (log) {
      const duration = Date.now() - start;
      runtime = runtime + duration;
      log(`${word}\t\t${levDist}\t\t${duration}`);
    }

    if (levDist === minDist) {
      minDistWords.push(word);
    }

    if (levDist < minDist) {
      minDist = levDist;
      minDistWords = [word];
    }
  }

  log && log(`runtime: ${runtime}ms`);

  return minDistWords.sort();
}


const levDistance = (a, b) => {

  if (cache[a] && cache[a][b]) {
    return cache[a][b];
  }

  if (a.length === 0) {
    return addToCache(a, b, b.length);
  }

  if (b.length === 0) {
    return addToCache(a, b, a.length);
  }

  const tail_a = a.substring(1);
  const tail_b = b.substring(1);

  if (a[0] === b[0]) {
    return levDistance(tail_a, tail_b);
  }

  const lev1 = levDistance(tail_a, b);
  const lev2 = levDistance(a, tail_b);
  const lev3 = levDistance(tail_a, tail_b);

  const levDist = Math.min(lev1, lev2, lev3) + 1;
  return addToCache(a, b, levDist);
}


const addToCache = (a, b, value) => {
  cache[a] = cache[a] || {};
  cache[a][b] = value;
  return value;
}
