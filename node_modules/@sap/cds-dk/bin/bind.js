const { warn } = require('../lib/util/term')

module.exports = Object.assign(cds_bind, {
    options: ['--to', '--for', '--on', '--kind', '--out', '--to-app-services', '--no-create-service-key', '--output-file'],
    flags: ['--exec'],
    shortcuts: ['-2', '-4', '-n', '-k', '-o', '-a'],
    help: `
# SYNOPSIS

    *cds bind* <service> [<options>]
    *cds bind --exec* [--profile <profile>] [--] <command> <args ...>

    Binds the given service to a service instance by storing connection
    information in *.cdsrc-private.json*
    in your project directory. Credentials are not stored in the file but rather
    retrieved dynamically during *cds watch*.
    Use option *--out* to specify a different path or file.

    With *--exec* you can execute arbitrary commands with your service bindings.
    The service bindings are provided
    in the *VCAP_SERVICES* env variable to the command.

# OPTIONS

    *-2 | --to* <instance>[:<key>] | <service-binding> | <secret>

        Bind to a given Cloud Foundry instance, Kubernetes service binding or Kubernetes secret.

    *-4 | --for* <profile>

        Profile to store binding information. Defaults to *hybrid*.

    *-n | --on* cf | k8s

        Target platform (Cloud Foundry or Kubernetes) to bind to. Defaults to *cf*.

    *-k | --kind* <kind>

        Kind of the service.

    *-o | --out* <path>

        Output file for added binding information. Use this option if binding configuration should
        be added to *package.json* or *.cdsrc.json*. If *path* is a directory, the *.cdsrc.json*
        file in that directory is used. Defaults to *.cdsrc-private.json*.

    *-a | --to-app-services <app>* (Beta)

        Bind to a given application (Cloud Foundry only).

    *--no-create-service-key*

        Skip automatic creation of service keys.

# EXAMPLE

    cds bind --to bookshop-db
    cds bind --to bookshop-db,bookshop-auth
    cds bind auth --to bookshop-auth:bookshop-auth-key --kind xsuaa --for my-profile

    cds bind --to bookshop-db --out .cdsrc.json

    cds bind --to bookshop-db --on k8s
    cds bind --to bookshop-db --for my-profile

    cds bind --to-app-services bookshop-srv
`
});

const os = require('os');
const IS_WIN = os.platform() === 'win32';

const { bind, parseProfile } = require('../lib/bind');


async function cds_bind(args, options) {

    const { on, 'to-app-services': app, to, out, 'output-file': outputFile, exec } = options

    if (exec) {
        process.env.CDS_ENV = parseProfile(process.env.CDS_ENV);
        if (options.for) {
            console.warn('Parameter --for is not supported in combination with --exec. Its value will be ignored.');
        }
        return cds_bind_exec(args)
    }

    // Check if cds command was bind. Don't abort in case of deploy
    if (process.env.CDS_ENV && process.argv[2] === 'bind') {
        throw 'Option --profile is no longer supported. Use --for instead to specify the profile to use when storing connection settings.';
    }

    if (outputFile) {
        console.warn(warn('Option --output-file is deprecated. Please use --out instead.'))
        options.out ??= outputFile
    }

    if (on === 'k8s' && app) {
        throw 'Option --to-app-services is only supported for Cloud Foundry.';
    }

    if (!to && !app) {
        throw `Use option --to or -2 to specify the target instance, e.g. cds bind --to myInstance:myService`;
    }

    if (app === true) {
        throw `Option '--to-app-services' requires an app name, for example 'cds bind --to-app-services bookshop-srv'.`
    }

    if (app) {
        const services = await require('../lib/util/cf').getServices(app)
        // Later: optimize logging for parallelization, services.forEach(service => bind({ ...options, to: service.name, outputFile }))
        for (const service of services.filter(s => Object.keys(s.credentials).length > 0)) {
            await bind({ ...options, to: service.name, out })
        }
    } else {
        if (args.length > 1) {
            throw `Too many arguments: Please specify only one or no service.`;
        }

        options.serviceArg = args[0]
        options.targets = options.to.split(/,/g);

        if (options.targets.length >= 2 && options.serviceArg) {
            throw `Service argument cannot be specified together with multiple targets ('--to') services. Use one service per call or omit the service argument.`;
        }

        if (options.targets.length >= 2 && options.kind) {
            throw `The option '--kind' cannot be specified together with multiple targets ('--to') services. Use one service per call or omit the '--kind' option.`;
        }

        await bind({ ...options, out });
    }
}

async function cds_bind_exec(command) { // eslint-disable-lint
    const cds = require('../lib/cds');
    const env = cds.env.for('cds', process.cwd());

    const BindingManager = require('../lib/bind/bindingManager')
    const bindingManager = new BindingManager({ env })
    const bindingEnv = await bindingManager.bindingEnv()
    const processEnv = Object.assign(process.env, bindingEnv)

    execAndExit({ env: processEnv }, ...command);
}

function execAndExit(options, command, ...args) {
    const { spawnSync } = require('child_process');
    // use shell with Windows only; without output is not visible and some commands cannot be run
    const result = spawnSync(command, args, {
        stdio: 'inherit',
        shell: IS_WIN,
        ...options
    });
    process.exit(result.status);
}
