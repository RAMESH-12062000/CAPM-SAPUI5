/* eslint-disable no-prototype-builtins */
/**
 * OData V4 to CSN parser
 */

"use strict";
let messages = require("../message").getMessages();
let common = require("../common");
let versionInfo = require("../../../package.json").version;
let Multimap = require("./util/MultiMap");
const ignoreObjects = ["$Reference"]; // add all the objects that needs to be ignored for parsing.
const { warn, info } = require("../../util/term");
const MetadataConverterFactory = require("./metadataconverter/MetadataConverterFactory");

const edmPrimitiveTypes = [
    'Edm.Binary', 'Edm.Boolean', 'Edm.Byte', 'Edm.Date', 'Edm.DateTimeOffset',
    'Edm.Decimal', 'Edm.Double', 'Edm.Duration', 'Edm.Guid', 'Edm.Int16', 'Edm.Int32',
    'Edm.Int64', 'Edm.SByte', 'Edm.Single', 'Edm.Stream', 'Edm.String', 'Edm.TimeOfDay',
    'Edm.Geography', 'Edm.GeographyPoint', 'Edm.GeographyLineString', 'Edm.GeographyPolygon',
    'Edm.GeographyMultiPoint', 'Edm.GeographyMultiLineString', 'Edm.GeographyMultiPolygon',
    'Edm.GeographyCollection', 'Edm.Geometry', 'Edm.GeometryPoint', 'Edm.GeometryLineString',
    'Edm.GeometryPolygon', 'Edm.GeometryMultiPoint', 'Edm.GeometryMultiLineString',
    'Edm.GeometryMultiPolygon', 'Edm.GeometryCollection'
];

const edmToCdsTypeMapping = {
    'Edm.Binary': 'cds.LargeBinary',
    'Edm.Boolean': 'cds.Boolean',
    'Edm.Date': 'cds.Date',
    'Edm.Decimal': 'cds.Decimal',
    'Edm.Double': 'cds.Double',
    'Edm.Guid': 'cds.UUID',
    'Edm.Int16': 'cds.Integer',
    'Edm.Int32': 'cds.Integer',
    'Edm.Int64': 'cds.Integer64',
    'Edm.String': 'cds.LargeString',
    'Edm.TimeOfDay': 'cds.Time',
};

const edmToCdsTypeMappingWithMaxLength = {
    'Edm.Binary': 'cds.Binary',
    'Edm.Byte': 'cds.Binary', // couldn't find any example
    'Edm.String': 'cds.String'
};

const edmToCdsTypeMappingWithPrecision = {
    'Edm.Decimal': 'cds.Decimal'
};

const edmToCdsTypeSpecialHandling = {
    'Edm.Byte': 'cds.Integer',
    'Edm.DateTimeOffset': ['cds.DateTime', 'cds.Timestamp'],
    'Edm.Double': 'cds.Double', // couldn't find an example
    'Edm.SByte': 'cds.Integer',
    'Edm.Single': 'cds.Double',
    'Edm.Stream': 'cds.LargeBinary'
};

const known_vocabularies = {
    'Org.OData.Authorization.V1': 'Authorization',
    'Org.OData.Aggregation.V1': 'Aggregation',
    'Org.OData.Core.V1': 'Core',
    'Org.OData.Capabilities.V1': 'Capabilities',
    'Org.OData.Validation.V1': 'Validation',
    'Org.OData.Measures.V1': 'Measures',
    'Org.OData.JSON.V1': 'JSON',
    'Org.OData.Repeatability.V1': 'Repeatability',

    'com.sap.vocabularies.Analytics.v1': 'Analytics',
    'com.sap.vocabularies.CodeList.v1': 'CodeList',
    'com.sap.vocabularies.Common.v1': 'Common',
    'com.sap.vocabularies.Communication.v1': 'Communication',
    'com.sap.vocabularies.DataIntegration.v1': 'DataIntegration',
    'com.sap.vocabularies.Graph.v1': 'Graph',
    'com.sap.vocabularies.Hierarchy.v1': 'Hierarchy',
    'com.sap.vocabularies.HTML5.v1': 'HTML5',
    'com.sap.vocabularies.ODM.v1': 'ODM',
    'com.sap.vocabularies.Offline.v1': 'Offline',
    'com.sap.vocabularies.PDF.v1': 'PDF',
    'com.sap.vocabularies.PersonalData.v1': 'PersonalData',
    'com.sap.vocabularies.Session.v1': 'Session',
    'com.sap.vocabularies.UI.v1': 'UI',
};

function _initialize(parserContext) {
    parserContext.unboundedActions = {};
    parserContext.unboundedFunctions = {};
    parserContext.entityTypes = [];
    parserContext.entityTypeOpenEntries = [];
    parserContext.complexTypeOpenEntries = [];
    parserContext.complexTypes = [];
    parserContext.enumTypes = [];
    parserContext.typeDefinitions = [];
    parserContext.entityContainerName = "";
    parserContext.entityToEntitySetMap = new Multimap();
    parserContext.entityToSingletonMap = new Multimap();
    parserContext.actionToActionImportMap = new Multimap();
    parserContext.functionToFunctionImportMap = new Multimap();
    parserContext.primarySchema = "";
    parserContext.schemaAliasToNamespace = {};
    parserContext.schemaToSchemaDataIndex = {};
    parserContext.vocabAliasToNamespace = {};
    parserContext.entityToBoundedActions = {};
    parserContext.entityToBoundedFunctions = {};
    parserContext.entityContainerAnnotations = {};
    parserContext.mockServerUc = true;
    parserContext.beta = false;
}
function _isJson(edmx) {
    let isJson = false;
    try {
        JSON.parse(edmx);
        isJson = true;
    } catch (err) {
        isJson = false;
    }
    return isJson;
}

function _extractSchemaNameAndElementName(name) {
    let lastIndex = name.lastIndexOf('.');
    let schemaName = name.substring(0, lastIndex);
    let elementName = name.substring(lastIndex + 1);
    return [schemaName, elementName];
}

/**
 * @param {String} fqName
 * @param {String} schemaName
 * @param {Object} parserContext
 * @returns index of schemaName in the schemaDataList
 */
function _getIndexAndNamespaceOfSchema(fqName, schemaName, parserContext) {
    let aliasNameMapping = parserContext.schemaAliasToNamespace;
    let schemaIndexMap = parserContext.schemaToSchemaDataIndex;

    // if prefix is schema `alias` value
    if (Object.keys(aliasNameMapping).includes(schemaName)) {
        schemaName = aliasNameMapping[schemaName];
        return [schemaIndexMap[schemaName], schemaName];
    }
    // if the prefix is schema `namespace` value
    else if (Object.keys(schemaIndexMap).includes(schemaName)) {
        return [schemaIndexMap[schemaName], schemaName];
    }
    // the schema namespace is not resolvable, throw error
    else {
        throw new Error(messages.UNRESOLVED_SCHEMA_NAMESPACE + fqName );
    }
}

function _resolveAliasedElementName(fqName, parserContext) {
    let [schemaName, elementName] = _extractSchemaNameAndElementName(fqName);
    [, schemaName] = _getIndexAndNamespaceOfSchema(fqName, schemaName, parserContext);

    return schemaName + '.' + elementName;
}

function _collectPrimarySchemaContext(jsonObj, parserContext, importerContext) {
    let jsonObjEntityContainer = jsonObj.$EntityContainer;
    if (jsonObjEntityContainer) {
        // scenario: Schema Namespace="A.B.C.D" & jsonObjEntityContainer is "A.B.C.D.EntityContainerName"
        [parserContext.primarySchema, parserContext.entityContainerName] = _extractSchemaNameAndElementName(jsonObjEntityContainer);
        // required for `--keep-namespace` scenario
        importerContext.schemaNamespace = parserContext.primarySchema;
    }
    else {
        parserContext.mockServerUc = false;
    }
}

function _updateElementObjectForCollection(dataTypeObj, isPrimaryKey, propertyDataType) {
    if (isPrimaryKey) {
        throw new Error(messages.COLLECTION_IN_KEY);
    }
    if (propertyDataType === 'Edm.Stream') {
        throw new Error(messages.STREAM_NO_COLLECTION);
    }

    dataTypeObj.items = {};

    Object.keys(dataTypeObj).forEach(objKey => {
        if (!objKey.startsWith('@') && !(dataTypeObj[objKey] instanceof Object)) {
            dataTypeObj.items[objKey] = dataTypeObj[objKey];
            delete dataTypeObj[objKey];
        }
    });
}

function _updateElementObjectForDefaultValue(dataTypeObj, defaultvalue) {
    // for collection, default value isin't expected
    if (dataTypeObj.items === undefined) {
        dataTypeObj.default = {};
        // defaultvalue could be of type string (eg., '0') or number (eg., 0 or -1.5)
        dataTypeObj.default.val = (defaultvalue !== undefined) ? defaultvalue : null;
    }
    else {
        console.log(warn(messages.NO_DEFAULT_FOR_COLLECTIONS));
    }
}

function _updateDataTypeObjectForMaxLength(dataTypeObj, propertyDataType, maxLength) {
    const mappedValue = edmToCdsTypeMappingWithMaxLength[propertyDataType];

    if (mappedValue) {
        dataTypeObj.type = mappedValue
        dataTypeObj.length = maxLength;
    }
    if (propertyDataType === 'Edm.Binary' && maxLength > 5000) {
        console.log(warn(messages.BINARY_MAXLENGTH));
    }
}

function _updateDataTypeObjectForPrecision(dataTypeObj, propertyDataType, precision, scale) {
    const mappedValue = edmToCdsTypeMappingWithPrecision[propertyDataType];
    const numberedScale = Number(scale);

    if (mappedValue) {
        dataTypeObj.type = mappedValue;
        if (precision >= 0) {
            dataTypeObj.precision = precision;
        }
        if (numberedScale >= 0) {
            dataTypeObj.scale = scale;
        }
        if (numberedScale > precision) {
            console.log(warn(messages.SCALE_GT_PRECISION));
        }
        if (precision >= 0 && (scale === 'floating' || scale === 'variable')) {
            console.log(warn(messages.FIXED_PRECISION_VARIABLE_SCALE));
        }
    }
}

function _updateDataTypeObjectForSpecialHandling(dataTypeObj, propertyDataType, maxLength, precision) {
    if (propertyDataType === 'Edm.Byte' && maxLength) {
        return; // already taken care with direct mapping with maxlength so returning
    }
    else if (['Edm.DateTimeOffset', 'Edm.Double'].includes(propertyDataType)) {
        if (propertyDataType === 'Edm.Double' && precision) {
            dataTypeObj['@odata.Precision'] = precision;
        }
        if (propertyDataType === 'Edm.DateTimeOffset') {
            dataTypeObj['@odata.Precision'] = precision;
            dataTypeObj['@odata.Type'] = propertyDataType;
            dataTypeObj.type = (precision) ?
                edmToCdsTypeSpecialHandling[propertyDataType][1] :
                edmToCdsTypeSpecialHandling[propertyDataType][0];
        }
        return;
    }
    else if (propertyDataType === 'Edm.Stream') {
        dataTypeObj['@Core.MediaType'] = 'application/octet-stream';
    }

    dataTypeObj['@odata.Type'] = propertyDataType;
    dataTypeObj.type = edmToCdsTypeSpecialHandling[propertyDataType];
}

function _captureAnnotationInCSN(targetString, annotationObject, csnDefsTargetObject) {
    /**
     * For scenarios like:
     * <Annotation Term="Core.Computed" />
     * Here, 'annotationObject' would be null but in CSN we need to treat it as:
     * @Core.Computed : true
     */
    if (annotationObject === null) {
        annotationObject = true;
    }
    /**
     * if anntationObject is empty list or empty object, we won't capture it.
     * eg., <Annotation Term="Core.OptimisticConcurrency"> <Collection /> </Annotation>
     * TODO: we might have to revisit it later for nested scenario.
     */
    if ((annotationObject instanceof Array && annotationObject.length === 0) ||
        (annotationObject instanceof Object && Object.keys(annotationObject).length === 0)
    ) {
        return;
    }
    /**
     * <Annotation Term="Common.Text" Path="name"/> --> annotationTermObject = { "=": annotationTermObject.$Path };
     */
    if (annotationObject.$Path) {
        annotationObject = { "=": annotationObject.$Path };
    }

    csnDefsTargetObject[targetString] = annotationObject;
}

function _replaceSpecialCharacters(text) {
    return text.replace(/(?:\\[rn]|[\r\n]+)+/gm, "\n").replace(/\s+/g, ' ').replace(/"/g, "&quot;").trim();
}

function _resolveCoreTerm(annotationTerm, annotationTermObject, csnDefsTargetObject, parserContext) {
    if (annotationTerm === "@Core.Description" || annotationTerm === "@Core.LongDescription") {
        // we don't capture `null` value for doc
        if (annotationTermObject === null)  return;

        annotationTermObject = _replaceSpecialCharacters(annotationTermObject);

        if (csnDefsTargetObject.doc) {
            if (annotationTerm === "@Core.Description") {
                annotationTermObject = annotationTermObject + '\n\n' + csnDefsTargetObject.doc;
            } else {
                annotationTermObject = csnDefsTargetObject.doc + '\n\n' + annotationTermObject;
            }
        }
        return _captureAnnotationInCSN('doc', annotationTermObject, csnDefsTargetObject);
    }
    /**
     * <Annotation Term="Core.XYZ"/>
     * For such scenario, mark the `anntationTermObject` as `true`
     */
    if (annotationTermObject === null) annotationTermObject = true;

    if (annotationTerm === "@Core.OptionalParameter") {
        if (parserContext.beta) {
            _updateElementObjectForDefaultValue(csnDefsTargetObject, annotationTermObject.DefaultValue);
        }
    } else {
        _captureAnnotationInCSN(annotationTerm, annotationTermObject, csnDefsTargetObject);
    }
}

function _flattenAnnotationObject(annotationPrefix, annotationObject) {
    let flattenedResult = [];

    Object.entries(annotationObject).forEach(annotation => {
        let currentResult = [];
        /**
         * if annotation looks like:
         * { "#" : <value> } or { "=" : <value> }
         * don't flatten because it is for the `EnumMember` & `Path` use cases respectively
         */
        if (annotation[0] === '#' || annotation[0] === '=') {
            currentResult[0] = annotationPrefix;
            currentResult[1] = annotationObject;
        } else {
            currentResult[0] = annotationPrefix + '.' + annotation[0];
            currentResult[1] = annotation[1];
        }
        flattenedResult.push(currentResult);
    });

    return flattenedResult;
}

function _removeTypeInAnnotation(annotationObject) {
    Object.keys(annotationObject).forEach(key => {
        if (key === "$Type") delete annotationObject[key];
        else if (annotationObject[key] instanceof Object) {
            _removeTypeInAnnotation(annotationObject[key]);
        }
    });
}

function _parseCapabilitiesTerm(annotationTerm, annotationTermObject, csnDefsTargetObject) {
    let targetString;
    /**
     * <Annotation Term="Capabilities.KeyAsSegmentSupported" />
     * For such scenario, mark the `anntationTermObject` as `true`
     */
    if (annotationTermObject === null) annotationTermObject = true;

    _removeTypeInAnnotation(annotationTermObject);
    /**
     * For entries like:
     * <Annotation Term="Capabilities.FilterFunctions"> <Collection> <String>eq</String> <String>ne</String> </Collection> </Annotation>
     * <Annotation Term="Capabilities.DeleteRestrictions.Deletable" Bool="true"/>
     *
     * simply preserve the value as it is
     */
    if (annotationTermObject instanceof Array || !(annotationTermObject instanceof Object)) {
        _captureAnnotationInCSN(annotationTerm, annotationTermObject, csnDefsTargetObject);
    }
    else {
        Object.keys(annotationTermObject).forEach(annoKey => {
            let currentAnnoValue = annotationTermObject[annoKey];
            // if the currentAnnoValue is an Object, we need to flatten it
            if (currentAnnoValue instanceof Object && !(currentAnnoValue instanceof Array)) {
                targetString = annotationTerm + '.' + annoKey;
                let flattenedResultList = _flattenAnnotationObject(targetString, currentAnnoValue);

                for (let idx = 0; idx < flattenedResultList.length; idx++) {
                    _captureAnnotationInCSN(flattenedResultList[idx][0], flattenedResultList[idx][1], csnDefsTargetObject);
                }
            }
            // if the currentAnnoValue is a list or direct value, we preserve as it is
            else {
                targetString = annotationTerm + '.' + annoKey;
                _captureAnnotationInCSN(targetString, currentAnnoValue, csnDefsTargetObject);
            }
        });
    }
}

function _parseValidationTerm(annotationTerm, annotationTermObject, csnDefsTargetObject) {
    const resolveCastFor = ["Minimum", "Maximum", "MaxItems"];
    const term = annotationTerm.split('.')[1];

    if (resolveCastFor.includes(term) && annotationTermObject.$Cast) {
        annotationTermObject = Number(annotationTermObject.$Cast);
    }

    _captureAnnotationInCSN(annotationTerm, annotationTermObject, csnDefsTargetObject);
}

function _parseAnnotationTerms(annotationTerm, annotationTermObject, csnDefsTargetObject, parserContext) {
    const term = annotationTerm.split('.');
    const vocabAlias = term[0];

    switch (vocabAlias) {
        case "@Core":
            _resolveCoreTerm(annotationTerm, annotationTermObject, csnDefsTargetObject, parserContext);
            break;
        case "@Capabilities":
            _parseCapabilitiesTerm(annotationTerm, annotationTermObject, csnDefsTargetObject);
            break;
        case "@Validation":
            _parseValidationTerm(annotationTerm, annotationTermObject, csnDefsTargetObject);
            break;
        default:
            _captureAnnotationInCSN(annotationTerm, annotationTermObject, csnDefsTargetObject);
            break;
    }
}

function _resolveAnotationTerm(schemaDataAnnotation, parserContext) {
    // Case 1: We have the Namespace and Alias for the vocabulary
    for (const [alias, namespace] of Object.entries(parserContext.vocabAliasToNamespace)) {
        if (schemaDataAnnotation.includes('@' + alias + '.')) {
            schemaDataAnnotation = schemaDataAnnotation.split('@' + alias + '.').join('@' + known_vocabularies[namespace] + '.');
        }
    }
    /**
     * Case 2: We only have the Namespace for the vocabulary
     * Case 3: We don't have the edmx:Reference at all
     */
    for (const [vocabulary, alias] of Object.entries(known_vocabularies)) {
        if (schemaDataAnnotation.includes(vocabulary)) {
            schemaDataAnnotation = schemaDataAnnotation.split(vocabulary).join(alias);
        }
    }

    return JSON.parse(schemaDataAnnotation);
}

/**
 * Capture all the annotation cases withtin an Element
 *
 * UnKnown term: <Annotation Term="Org.OData.ASDF.V1.qwe"/>
 * Known term: <Annotation Term="Org.OData.Measures.V1.Unit" String="Centimeters"/>
 *
 * if "--include-namespaces *" then we also capture for ABS and QWE
 * <TypeDefinition Name="TD_2" UnderlyingType="Edm.Int32" ABS:asdf="testing" QWE:qwe="testing"/>
 */
function _captureAnnotationWithinElement(sourceObject, targetObject, parserContext) {
    let element;

    Object.keys(sourceObject).forEach(key => {
        if (key.startsWith('@')) {
            element = _resolveAnotationTerm(JSON.stringify(key), parserContext);
            _parseAnnotationTerms(element, sourceObject[key], targetObject, parserContext);
        }
    });
}

function _generatePrimitiveDataTypeCsn(propertyObject, isPrimaryKey, parserContext) {
    const dataTypeObj = {};
    const propertyDataType = propertyObject.$Type;
    const maxLength = Number(propertyObject.$MaxLength);
    const precision = Number(propertyObject.$Precision);
    const scale = propertyObject.$Scale;
    const underlyingType = propertyObject.$UnderlyingType;
    const isCollection = propertyObject.$Collection;
    const nullable = propertyObject.$Nullable;
    const defaultvalue = propertyObject.$DefaultValue;

    if (isPrimaryKey) {
        dataTypeObj.key = true;
        if (nullable) {
            console.log(warn(messages.NULLABLE_KEY));
        }
    }
    _captureAnnotationWithinElement(propertyObject, dataTypeObj, parserContext);

    dataTypeObj.type = edmToCdsTypeMapping[propertyDataType];

    if (maxLength) {
        _updateDataTypeObjectForMaxLength(dataTypeObj, propertyDataType, maxLength);
    }
    /**
     * Precision: non-negative integers
     * Scale: non-negative integers, variable, floating
     */
    if (precision >= 0 || scale !== undefined) {
        _updateDataTypeObjectForPrecision(dataTypeObj, propertyDataType, precision, scale);
    }
    if (edmToCdsTypeSpecialHandling[propertyDataType]) {
        _updateDataTypeObjectForSpecialHandling(dataTypeObj, propertyDataType, maxLength, precision);
    }
    if (!edmToCdsTypeMapping[propertyDataType] && !edmToCdsTypeSpecialHandling[propertyDataType]) {
        dataTypeObj['@odata.Type'] = propertyDataType;
        dataTypeObj.type = 'cds.String';
    }
    /**
     * When called from TypeDefinition or EnumType we,
     * don't want to process Nullable, Collection, DefaultValue.
     */
    if (underlyingType) {
        return dataTypeObj;
    }

    if (!nullable) {
        dataTypeObj['notNull'] = true;
    }
    if (isCollection) {
        _updateElementObjectForCollection(dataTypeObj, isPrimaryKey, propertyDataType);
    }
    // defaultvalue could be of type string (eg., '0') or number (eg., 0 or -1.5)
    if (defaultvalue !== undefined) {
        _updateElementObjectForDefaultValue(dataTypeObj, defaultvalue);
    }

    return dataTypeObj;
}

function _getEntityTypeMappedName(entityType, parserContext) {
    const mappedResult = parserContext.entityToEntitySetMap.get(entityType);
    // if one entity type has mapping to multiple entity sets, use the first entity set
    if (mappedResult.length > 1) {
        return parserContext.primarySchema + '.' + mappedResult[0];
    }
    else {
        return parserContext.primarySchema + '.' + mappedResult;
    }
}

function _generateStructuredDataTypeCsn(dataType, propertyObject, isPrimaryKey, dataTypeKind, elementKind, parserContext) {
    const dataTypeObj = {};
    const isCollection = propertyObject.$Collection;
    const nullable = propertyObject.$Nullable;
    const defaultvalue = propertyObject.$DefaultValue;
    let propertyDataType = propertyObject.$Type;
    // const underlyingType = propertyObject.$UnderlyingType; // might have to use later

    /**
     * for a typeDefintion to be a Primary key, it has to be
     * based out of one of the entries in the edmPrimitiveTypes list
     * We might have to decide if we want to throw an error if we get
     * an entry not following this rule.
     */
    if (isPrimaryKey) {
        dataTypeObj.key = true;
        if (nullable) {
            console.log(warn(messages.NULLABLE_KEY));
        }
    }

    // if dataTypeKind is EntityType, also check for mapped entity name
    if (parserContext.mockServerUc && dataTypeKind === 'EntityType') {
        // propertyDataType is resolved fully qualified name
        if (parserContext.entityToEntitySetMap?.get(propertyDataType)) {
            propertyDataType = _getEntityTypeMappedName(propertyDataType, parserContext);
        }
        // dataType can be aliased name, so check that too.
        else if (parserContext.entityToEntitySetMap?.get(dataType)) {
            propertyDataType = _getEntityTypeMappedName(dataType, parserContext);
        }
    }
    dataTypeObj.type = propertyDataType;

    if (!nullable) {
        dataTypeObj['notNull'] = true;
    }
    if (isCollection) {
        _updateElementObjectForCollection(dataTypeObj, isPrimaryKey, propertyDataType);
    }
    /**
     * only Primitive type and EnumType can have DefaultValue facet as per documentation
     * but compiler accepts it for TypeDefintion and ComplexType as well,
     * do we also need to handle it for TypeDefintion and ComplexType?
     *
     * For parameters, defaultvalue is added via OptionalParamter Annotation
     * defaultvalue could be of type string (eg., '0') or number (eg., 0 or -1.5)
     */
    if (defaultvalue !== undefined && dataTypeKind === 'EnumType' && elementKind === 'property') {
        _updateElementObjectForDefaultValue(dataTypeObj, defaultvalue);
    }
    else {
        // throw error, because only primitive or enumeration type can have DefaultValue.
    }
    _captureAnnotationWithinElement(propertyObject, dataTypeObj, parserContext);

    return dataTypeObj;
}

function _parseAssociationProperty(foreignReference, associationNode, parserContext) {
    const associationProperty = {};
    let foreignKeys;
    // var foreignReference = associationNode.$Type;
    let refConstraint = associationNode.$ReferentialConstraint;
    let data;
    let ref;

    associationProperty.type = (associationNode.$OnDelete === 'Cascade') ? 'cds.Composition' : 'cds.Association';
    // annotation for ON condition
    associationProperty["@cds.ambiguous"] = 'missing on condition?';
    // associationProperty.target = associationNode.$Type;

    // Code for NavigationProperty for notNull
    // if (!associationProperty.$Nullable) {
    //     associationProperty["notNull"] = true;
    // }

    let resolvedEntityName;
    let entityTypeMapping = (
        parserContext.entityToEntitySetMap?.get(associationNode.$Type) ||
        parserContext.entityToSingletonMap?.get(associationNode.$Type)
    );
    // if entityTypeMapping is `undefined`, means the associationNode.$Type could be aliased
    if (!entityTypeMapping) {
        resolvedEntityName = _resolveAliasedElementName(associationNode.$Type, parserContext);
        entityTypeMapping = (
            parserContext.entityToEntitySetMap?.get(resolvedEntityName) ||
            parserContext.entityToSingletonMap?.get(resolvedEntityName)
        );
    }

    if (parserContext.mockServerUc && entityTypeMapping) {
        if (entityTypeMapping.length > 1) {
            for (let j = 0; j < entityTypeMapping.length; j++) {
                if (entityTypeMapping[j] === foreignReference) {
                    associationProperty.target = parserContext.primarySchema + '.' + entityTypeMapping[j];
                }
            }
        } else {
            associationProperty.target = parserContext.primarySchema + '.' + entityTypeMapping;
        }
    } else {
        associationProperty.target = resolvedEntityName;
    }
    // cardinality
    associationProperty.cardinality = {};
    if (associationNode.$Collection) {
        associationProperty.cardinality.max = '*';
    } else {
        associationProperty.cardinality.max = 1;
    }
    // on -> "SalesOrders.CustomerID=CustomerID and SalesOrders.Type=Type"
    if (refConstraint) {
        associationProperty.on = [];
        foreignKeys = Object.keys(refConstraint);

        for (let i = 0; i < foreignKeys.length; i++) {
            data = {};
            ref = [];
            ref.push(foreignReference);
            ref.push(refConstraint[foreignKeys[i]]);
            data.ref = ref;
            associationProperty.on.push(data);
            associationProperty.on.push('=');
            data = {};
            ref = [];
            ref.push(foreignKeys[i]);
            data.ref = ref;
            associationProperty.on.push(data);
            if (i < foreignKeys.length - 1) {
                associationProperty.on.push(' and ');
            }
        }
    }
    // Convert managed associations and compositions in unmanaged with empty key to avoid
    // "generation" of keys, that do not exist in the external service.
    if (common.checkForEmptyKeys(associationProperty, "V4")) {
        associationProperty.keys = [];
    }
    _captureAnnotationWithinElement(associationNode, associationProperty, parserContext);

    return associationProperty;
}

function _checkIsStructureTypeAndReturnDataKind(dataType, contentObject, elementKind, parserContext) {
    let fqName = dataType;
    let [schemaName, elementName] = _extractSchemaNameAndElementName(dataType);

    if (parserContext.schemaAliasToNamespace[schemaName]) {
        fqName = parserContext.schemaAliasToNamespace[schemaName] + "." + elementName;
        contentObject.$Type = fqName;
    }
    if (parserContext.complexTypes.includes(fqName)) {
        return 'ComplexType';
    }
    else if (parserContext.typeDefinitions.includes(fqName)) {
        return 'TypeDefinition';
    }
    else if (parserContext.enumTypes.includes(fqName)) {
        return 'EnumType';
    }
    else if (elementKind === 'property' && parserContext.entityTypes.includes(fqName)) {
        throw new Error(messages.UNSUPPORTED_PROPERTY_TYPE + dataType);
    }
    else if (elementKind === 'parameter' && parserContext.entityTypes.includes(fqName)) {
        return 'EntityType';
    }
    else {
        throw new Error(messages.UNRESOLVED_TYPE + dataType);
    }
}

/**
 * @param {Object} csnObj
 * @param {Object} elementObj
 * @param {Object} parserContext
 */
function _parsePropertyContent(csnObj, elementObj, parserContext) {
    let contentObj = {};
    const isPrimaryKey = true;
    let dataType, isPrimitiveType, keySet = [];

    Object.keys(elementObj).forEach(objKey => {
        const contentKind = elementObj[objKey].$Kind;
        contentObj = elementObj[objKey];

        if ((objKey.indexOf('@') === -1) && (objKey.indexOf('.') === -1)) {
            if (contentObj instanceof Object) {
                if (contentObj.$Type) {
                    dataType = contentObj.$Type;
                    isPrimitiveType = dataType.startsWith('Edm') ? true : false;
                }
                if (objKey === '$Key') {
                    keySet.push(...elementObj.$Key);
                }
                // primitive datatypes
                else if (isPrimitiveType) {
                    if (edmPrimitiveTypes.includes(dataType)) {
                        csnObj.elements[objKey] = _generatePrimitiveDataTypeCsn(contentObj,
                            (keySet.includes(objKey) ? isPrimaryKey : !isPrimaryKey),
                            parserContext
                        );
                    } else {
                        throw new Error(messages.INVALID_DATATYPE + `'${dataType}' in element: '${objKey}'`)
                    }
                }
                // structured datatypes
                else if (!isPrimitiveType && !(contentKind === 'NavigationProperty')) {
                    const dataKind = _checkIsStructureTypeAndReturnDataKind(dataType, contentObj, 'property', parserContext);

                    if (['EnumType', 'TypeDefinition'].includes(dataKind)) {
                        csnObj.elements[objKey] = _generateStructuredDataTypeCsn(dataType, contentObj,
                            (keySet.includes(dataType) ? isPrimaryKey : !isPrimaryKey),
                            dataKind, 'property', parserContext
                        );
                    }
                    else {
                        csnObj.elements[objKey] = _generateStructuredDataTypeCsn(dataType, contentObj,
                            !isPrimaryKey, dataKind, 'property', parserContext
                        );
                    }
                }
                else if (contentKind === 'NavigationProperty') {
                    csnObj.elements[objKey] = _parseAssociationProperty(objKey, elementObj[objKey], parserContext);
                }
            }
        }
    });
}

function _addBlobElement() {
    return {
        "blob": {
            "@Core.MediaType": 'application/octet-stream',
            "type": "cds.LargeBinary"
        }
    }
}

/**
 * to handle the Abstract, Open & Base Type scenarios
 * @param {String} fqName, element name
 * @param {Object} csnObj,
 * @param {Object} elementObj,
 * @param {Object} parserContext
 */
function _captureOpenTypes(fqName, csnObj, elementObj, isEntity, mockServerUc, parserContext) {
    let baseTypeName = elementObj.$BaseType;
    let isAbstract = elementObj.$Abstract;
    let isOpenType = elementObj.$OpenType;

    if (baseTypeName) {
        let resolvedBaseTypeName = _resolveAliasedElementName(baseTypeName, parserContext);

        if (isEntity) {
            if (parserContext.entityTypes.includes(resolvedBaseTypeName)) {
                if (!parserContext.entityTypeOpenEntries.includes(resolvedBaseTypeName)) {
                    parserContext.entityTypeOpenEntries.push(resolvedBaseTypeName);
                }
                if (mockServerUc) {
                    let entityMapping = (
                        parserContext.entityToEntitySetMap?.get(baseTypeName) ||
                        parserContext.entityToSingletonMap?.get(baseTypeName)
                    );
                    if (entityMapping) {
                        resolvedBaseTypeName = _getEntityTypeMappedName(baseTypeName, parserContext);
                    }
                    else {
                        entityMapping = (
                            parserContext.entityToEntitySetMap?.get(resolvedBaseTypeName) ||
                            parserContext.entityToSingletonMap?.get(resolvedBaseTypeName)
                        );
                        if (entityMapping) {
                            resolvedBaseTypeName = parserContext.primarySchema + '.' + entityMapping[0];
                        }
                    }
                }
            } else {
                throw new Error(messages.UNRESOLVED_TYPE + `'${baseTypeName}'`);
            }
        } else {
            if (parserContext.complexTypes.includes(resolvedBaseTypeName) &&
                !parserContext.complexTypeOpenEntries.includes(resolvedBaseTypeName)
            ) {
                parserContext.complexTypeOpenEntries.push(resolvedBaseTypeName);
            }
            else if (!parserContext.complexTypes.includes(resolvedBaseTypeName)) {
                throw new Error(messages.UNRESOLVED_TYPE + `'${baseTypeName}'`);
            }
        }
        csnObj.includes = [resolvedBaseTypeName];
    }
    if (isAbstract || isOpenType) {
        if (isEntity && !parserContext.entityTypeOpenEntries.includes(fqName)) {
            parserContext.entityTypeOpenEntries.push(fqName);
        }
        else if (!parserContext.complexTypeOpenEntries.includes(fqName)) {
            parserContext.complexTypeOpenEntries.push(fqName);
        }
    }
}

function _generateCSNForEntityType(ignorePersistenceSkip, entityList, parserContext) {
    const csnEntity = {};
    let isEntity = true;
    entityList.forEach(entityElement => {
        let entityName = Object.keys(entityElement)[0];

        csnEntity[entityName] = {};
        csnEntity[entityName].kind = 'entity';
        csnEntity[entityName]['@cds.external'] = true;

        if (!ignorePersistenceSkip) {
            csnEntity[entityName]['@cds.persistence.skip'] = true;
        }

        _captureOpenTypes(entityName, csnEntity[entityName], entityElement[entityName], isEntity, parserContext.mockServerUc, parserContext);
        _captureAnnotationWithinElement(entityElement[entityName], csnEntity[entityName], parserContext);

        csnEntity[entityName].elements = {};

        _parsePropertyContent(csnEntity[entityName], entityElement[entityName], parserContext);

        // needs to be checked if this is necessary
        if (entityElement[entityName].$HasStream) {
            csnEntity[entityName].elements = { ...csnEntity[entityName].elements, ..._addBlobElement() };
        }
    });
    // add @open annotations
    parserContext.entityTypeOpenEntries.forEach(entityName => {
        if (csnEntity[entityName]) csnEntity[entityName]['@open'] = true;
    });

    return csnEntity;
}

function _parseCSNForEntityType(schemaData, ignorePersistenceSkip, parserContext) {
    let entitiesList = [];
    for (let fqName of parserContext.entityTypes) {
        let entity = {};
        let [schemaName, elementName] = _extractSchemaNameAndElementName(fqName);
        let entityObj = schemaData[elementName];

        if (entityObj?.$Kind === 'EntityType' && schemaName === schemaData.$SchemaNamespace) {
            entity[fqName] = entityObj;
            entitiesList.push(entity);
        }
    }

    return _generateCSNForEntityType(ignorePersistenceSkip, entitiesList, parserContext);
}

function _parseParameterAndReturnTypeContent(elementObject, parserContext) {
    let dataType = elementObject.$Type;
    const isPrimitiveType = dataType.startsWith('Edm') ? true : false;
    const isPrimaryKey = true;

    // primitive type
    if (isPrimitiveType) {
        if (edmPrimitiveTypes.includes(dataType)) {
            return _generatePrimitiveDataTypeCsn(elementObject, !isPrimaryKey, parserContext);
        }
        else {
            throw new Error(messages.INVALID_DATATYPE + `'${dataType}' in element: '${elementObject.$Name}'`)
        }
    }
    // structured type
    else {
        const dataKind = _checkIsStructureTypeAndReturnDataKind(dataType, elementObject, 'parameter', parserContext);
        return _generateStructuredDataTypeCsn(dataType, elementObject, !isPrimaryKey, dataKind, 'parameter', parserContext);
    }
}

function _generateCSNForBoundedActionFunction(actionFunctionObject, kind, parserContext) {
    const csnObj = {};
    const isBounded = actionFunctionObject.$IsBound;
    const parameters = actionFunctionObject.$Parameter;
    const returnType = actionFunctionObject.$ReturnType;

    csnObj.kind = kind;
    _captureAnnotationWithinElement(actionFunctionObject, csnObj, parserContext);

    if (parameters) {
        csnObj.params = {};

        for (let index = 0; index < parameters.length; index++) {
            let isCollection = parameters[index].$Collection;
            csnObj.params[parameters[index].$Name] = _parseParameterAndReturnTypeContent(parameters[index], parserContext);
            /**
             * binding parameter handling - only first parameter will contain the binding
             * parameter information, so only make change to the first parameter information.
             * NOTE: Edm.Stream can act as the binding parameter for action/function
             * We don't have any example for it, so not handled as of now
             */
            if (isBounded && index === 0) {
                if (isCollection) {
                    csnObj.params[parameters[index].$Name].items.type = '$self';
                }
                else {
                    csnObj.params[parameters[index].$Name].type = '$self';
                }
            }
        }
    }
    if (returnType) {
        csnObj.returns = _parseParameterAndReturnTypeContent(returnType, parserContext);
    }

    return csnObj;
}

function _parseBoundedActionFunction(schemaData, csnObj, kind, parserContext) {
    const boundedObject = (kind === 'action') ? parserContext.entityToBoundedActions : parserContext.entityToBoundedFunctions;

    Object.keys(boundedObject).forEach(fqEntityName => {
        const [schemaName, ] = _extractSchemaNameAndElementName(fqEntityName);

        if (schemaName === schemaData.$SchemaNamespace) {
            const actionFunctionObjectList = boundedObject[fqEntityName];

            if (!csnObj[fqEntityName].actions) {
                csnObj[fqEntityName].actions = {};
            }
            Object.keys(actionFunctionObjectList).forEach(actionFunctionName => {
                csnObj[fqEntityName].actions[actionFunctionName] = _generateCSNForBoundedActionFunction(
                    actionFunctionObjectList[actionFunctionName], kind, parserContext
                );
            });
        }
    });
}

function _parseUnBoundedActionFunction(schemaData, kind, parserContext) {
    const unBoundedObject = (kind === 'action') ? parserContext.unboundedActions : parserContext.unboundedFunctions;
    const csnObj = {};

    Object.keys(unBoundedObject).forEach(fqName => {
        const [schemaName, ] = _extractSchemaNameAndElementName(fqName);

        if (schemaName === schemaData.$SchemaNamespace) {
            const actionFunctionObject = unBoundedObject[fqName];
            const parameters = actionFunctionObject.$Parameter;
            const returnType = actionFunctionObject.$ReturnType;

            csnObj[fqName] = {};
            csnObj[fqName].kind = kind;
            csnObj[fqName]['@cds.external'] = true;
            _captureAnnotationWithinElement(actionFunctionObject, csnObj[fqName], parserContext);

            if (parameters) {
                csnObj[fqName].params = {};

                for (let paramObj of parameters) {
                    csnObj[fqName].params[paramObj.$Name] = _parseParameterAndReturnTypeContent(paramObj, parserContext);
                }
            }
            if (returnType) {
                csnObj[fqName].returns = _parseParameterAndReturnTypeContent(returnType, parserContext);
            }
        }
    });

    return csnObj;
}

function _parserCSNForComplexType(schemaData, parserContext) {
    const complexCsn = {};
    const isEntity = true;

    for (let fqName of parserContext.complexTypes) {
        let [schemaName, elementName] = _extractSchemaNameAndElementName(fqName);
        let complexObj = schemaData[elementName];

        if (complexObj?.$Kind === 'ComplexType' && schemaName === schemaData.$SchemaNamespace) {
            complexCsn[fqName] = {};
            complexCsn[fqName].kind = 'type';
            complexCsn[fqName]['@cds.external'] = true;
            complexCsn[fqName].elements = {};
            // inheritance handling
            _captureOpenTypes(fqName, complexCsn[fqName], complexObj, !isEntity, !parserContext.mockServerUc, parserContext);
            _captureAnnotationWithinElement(complexObj, complexCsn[fqName], parserContext);
            _parsePropertyContent(complexCsn[fqName], complexObj, parserContext);
        }
    }
    // add @open annotations
    parserContext.complexTypeOpenEntries.forEach(key => {
        if (complexCsn[key]) complexCsn[key]['@open'] = true;
    });

    return complexCsn;
}

function _parseCSNForEnumType(schemaData, parserContext) {
    const nonMemberList = ["$Kind", "$Type", "$UnderlyingType", "$IsFlags"];
    const possibleCdsTypes = ['cds.Integer',  'cds.Integer64'];
    const enumCsn = {};
    const isKey = true;

    for (let fqName of parserContext.enumTypes) {
        let [schemaName, elementName] = _extractSchemaNameAndElementName(fqName);
        let enumObj = schemaData[elementName];

        if (enumObj?.$Kind === 'EnumType' && schemaName === schemaData.$SchemaNamespace) {
            enumCsn[fqName] = {};
            enumCsn[fqName].kind = 'type';
            enumCsn[fqName]['@cds.external'] = true;
            enumCsn[fqName].enum = {};
            /**
             * If UnderlyingType not specified, default is Edm.Int32 --> cds.Integer
             */
            let underlyingType = enumObj.$UnderlyingType;
            enumObj.$Type = underlyingType;

            let cdsType = underlyingType ? (_generatePrimitiveDataTypeCsn(enumObj, !isKey, parserContext)) : { type : 'cds.Integer' };
            enumCsn[fqName].type = cdsType.type;

            if (cdsType['@odata.Type']) {
                enumCsn[fqName]['@odata.Type'] = cdsType['@odata.Type'];
            }
            if (!possibleCdsTypes.includes(enumCsn[fqName].type)) {
                throw new Error(messages.INVALID_ENUM_TYPE + `'${underlyingType}'`);
            }

            Object.keys(enumObj).forEach(member => {
                if (!nonMemberList.includes(member)) {
                    enumCsn[fqName].enum[member] = {};
                    enumCsn[fqName].enum[member].val = enumObj[member];
                }
            });
        }
    }

    return enumCsn;
}

function _parseCSNForTypeDefinition(schemaData, parserContext) {
    const typeDef = {};
    const isKey = true;

    for (let fqName of parserContext.typeDefinitions) {
        let [schemaName, elementName] = _extractSchemaNameAndElementName(fqName);
        let typeDefObj = schemaData[elementName];

        if (typeDefObj?.$Kind === 'TypeDefinition' && schemaName === schemaData.$SchemaNamespace) {
            typeDef[fqName] = {};
            typeDef[fqName].kind = 'type';
            typeDef[fqName]['@cds.external'] = true;

            let underlyingType = typeDefObj.$UnderlyingType;
            typeDefObj.$Type = underlyingType;

            if (edmPrimitiveTypes.includes(underlyingType)) {
                typeDef[fqName] = Object.assign(typeDef[fqName], _generatePrimitiveDataTypeCsn(typeDefObj, !isKey, parserContext));
            }
            else {
                throw new Error(messages.UNRESOLVED_TYPE + `'${underlyingType}'`);
            }
        }
    }

    return typeDef;
}

function _resolveEntityContainerAnnotationTarget(targetPath, csnDefs, hasProperty, parserContext) {
    /**
     * format: <schemaName_or_Alias><EntityContainerName>/<ContainerElement>
     * <schemaName_or_Alias><EntityContainerName>/<ContainerElement>/...
     *
     * needs to be handled without 'EntityContainerName'
     */
    if (hasProperty) {
        const eleNameList = targetPath.split('/');
        // based on the length of eleName list, do the processing
        if (eleNameList.length === 2) {
            return csnDefs[parserContext.primarySchema + '.' + eleNameList[1]];
        }
        else {
            // TODO: We might have to take care of such senarios in the future.
        }
    }
    // direct path to service object
    else {
       return csnDefs[parserContext.primarySchema];
    }
}

function _resolveActionFunctionAnnotationTarget(targetPath, csnDefs, hasParameter, parserContext) {
    let elemNameList = targetPath.split('(');
    const fqActFunName = _resolveAliasedElementName(elemNameList[0], parserContext);
    const paramName = hasParameter ? targetPath.split('/')[1] : null;

    // unbounded action or function
    if (csnDefs[fqActFunName]) {
        // with parameter
        if (hasParameter && csnDefs[fqActFunName].params[paramName]) {
            return csnDefs[fqActFunName]?.params[paramName];
        }
        // without parameter
        else if (!hasParameter) {
            return csnDefs[fqActFunName];
        }
    }
    // bounded action or function
    else {
        const [, elementName] = _extractSchemaNameAndElementName(fqActFunName);
        const isCollection = elemNameList[1] === 'Collection' ? true : false;
        let parameterList = isCollection ? elemNameList[2].split(')') : elemNameList[1].split(')');
        let bindingParameter = parameterList[0];

        if (bindingParameter.includes(',')) {
            bindingParameter = bindingParameter.split(',')[0];
        }
        const entityType = _resolveAliasedElementName(bindingParameter, parserContext);

        if (csnDefs[entityType]?.actions[elementName]) {
            // with parameter
            if (hasParameter && csnDefs[entityType].actions[elementName].params[paramName]) {
                return csnDefs[entityType].actions[elementName].params[paramName];
            }
            // without parameter
            else if (!hasParameter) {
                return csnDefs[entityType].actions[elementName];
            }
        }
    }
}

function _resolveAnnotationTarget(targetPath, csnDefs, parserContext) {
    const indexOfSlash = targetPath.indexOf('/');
    const indexOfOpenBrace = targetPath.indexOf('(');
    const hasPropOrParam = (indexOfSlash > 0);
    let elemNameList, fqName;

    // Case 1: Direct path
    if (indexOfOpenBrace === -1 && indexOfSlash === -1) {
        fqName = _resolveAliasedElementName(targetPath, parserContext);

        if (csnDefs[fqName]) {
            return csnDefs[fqName];
        }
        else if (parserContext.entityContainerAnnotations[targetPath]) {
            return _resolveEntityContainerAnnotationTarget(fqName, csnDefs, hasPropOrParam, parserContext);
        }
    }
    // Case 2: Direct path with /
    else if (indexOfOpenBrace === -1 && indexOfSlash !== -1) {
        elemNameList = targetPath.split('/');
        fqName = _resolveAliasedElementName(elemNameList[0], parserContext);

        if (csnDefs[fqName]) {
            if (csnDefs[fqName]?.elements?.[elemNameList[1]]) {
                return csnDefs[fqName].elements[elemNameList[1]];
            }
            else if (csnDefs[fqName]?.enum?.[elemNameList[1]]) {
                return csnDefs[fqName].enum[elemNameList[1]];
            }
        }
        // Entity Container path with /
        else if (parserContext.entityContainerAnnotations[targetPath]) {
            return _resolveEntityContainerAnnotationTarget(targetPath, csnDefs, hasPropOrParam, parserContext);
        }
    }
    // Case 3: actions and functions path with or without parameter
    else {
        return _resolveActionFunctionAnnotationTarget(targetPath, csnDefs, hasPropOrParam, parserContext);
    }
}

function _parseAnnotations(schemaAnnotations, csnDefs, parserContext) {
    Object.keys(schemaAnnotations).forEach(annotationTargetPath => {
        let csnDefsTargetObject = _resolveAnnotationTarget(annotationTargetPath, csnDefs, parserContext);
        // if the target object exists, process the annotation terms
        if (csnDefsTargetObject) {
            let annotationTerms = schemaAnnotations[annotationTargetPath];
            Object.keys(annotationTerms).forEach(annotationTerm => {
                let annotationTermObject = schemaAnnotations[annotationTargetPath][annotationTerm];
                _parseAnnotationTerms(annotationTerm, annotationTermObject, csnDefsTargetObject, parserContext);
            });
        }
    });
}

function _addSuffixForCollisionTypes(fqName, suffix) {
    console.log(info(`INFO: Due to collision in ${fqName} suffix "${suffix}" is added.`));
    const suffixedFqElementName = (fqName + suffix);
    return suffixedFqElementName;
}

function _parseEntityContainer(csnDefs, entityContainerElements, parserContext) {
    const entityContainerElementNames = Object.keys(entityContainerElements);
    const redundantElementNames = [];
    let possibleAnnotations = {};

    // filter entries starting with '@', they can be possible annotation
    entityContainerElementNames.filter(
        elementName => elementName.startsWith('@')
    ).forEach(elementName => {
        possibleAnnotations[elementName] = entityContainerElements[elementName];
        delete entityContainerElements[elementName];
    });

    entityContainerElementNames.forEach(ecElement => {
        if (entityContainerElements[ecElement] instanceof Object) {
            let definitionRefName, kind;

            if (entityContainerElements[ecElement].$Action) {
                definitionRefName = entityContainerElements[ecElement].$Action;
                kind = 'action';
            }
            else if (entityContainerElements[ecElement].$Function) {
                definitionRefName = entityContainerElements[ecElement].$Function;
                kind = 'function';
            }
            else {
                definitionRefName = entityContainerElements[ecElement].$Type;
                kind = 'entity';
            }

            let [, elementName] = _extractSchemaNameAndElementName(definitionRefName);
            let fqDefRefName = _resolveAliasedElementName(definitionRefName, parserContext);
            let fqElementName = parserContext.primarySchema + "." + ecElement;

            if (csnDefs[fqElementName] && csnDefs[fqElementName].kind !== kind) {
                console.log(info(messages.COLLISION_DETECTED));
                let suffixedFqElementName;
                // Check the type category that experienced the collision
                if (parserContext.complexTypes.includes(fqElementName)) {
                    suffixedFqElementName = _addSuffixForCollisionTypes(fqElementName, "_ComplexType");
                } else if (parserContext.enumTypes.includes(fqElementName)) {
                    suffixedFqElementName = _addSuffixForCollisionTypes(fqElementName, "_EnumType");
                } else if (parserContext.typeDefinitions.includes(fqElementName)) {
                    suffixedFqElementName = _addSuffixForCollisionTypes(fqElementName, "_TypeDefinition");
                }
                // copy the definition with new suffixed name and delete the old definition from csnDefs
                csnDefs[suffixedFqElementName] = csnDefs[fqElementName];
                delete csnDefs[fqElementName];
            }

            if (fqElementName !== fqDefRefName) {
                if (csnDefs[fqElementName] && !parserContext.entityToEntitySetMap.get(fqElementName)) {
                    fqElementName = _addSuffixForCollisionTypes(fqElementName, "_EntityType");
                }
                csnDefs[fqElementName] = Object.assign({}, csnDefs[fqDefRefName]);
                /**
                 * Capture all the defintion reference element name which are no
                 * longer required after the entity container elements are populated.
                 * We will delete their entries from the csnDefs later.
                 */
                if (!entityContainerElementNames.includes(elementName)) {
                    redundantElementNames.push(fqDefRefName);
                }
            }
            if (entityContainerElements[ecElement].$Singleton) {
                csnDefs[fqElementName]['@odata.singleton'] = true;
            }
            if (entityContainerElements[ecElement].$SingletonNullable) {
                csnDefs[fqElementName]['@odata.singleton.nullable'] = true;
            }
        }
    });

    /**
     * remove all the entries from the csnDefs which had a mapping in entity
     * container and we have successfully copied their content to mapped elements
     */
    redundantElementNames.forEach(name => {
        delete csnDefs[name];
    });

    // check for possible annotations present within the entity container
    if (Object.keys(possibleAnnotations).length > 0) {
        let entityContainerAnnotations = {};
        let annotationTarget = parserContext.primarySchema + '.' + parserContext.entityContainerName;
        possibleAnnotations = _resolveAnotationTerm(
            JSON.stringify(possibleAnnotations), parserContext
        );
        /**
         * If the same annotation target already exists because of the annotation present outside
         * of the EntityContainer, then append the possible annotations to it and parse all of them.
         * Few exact same annotation term if exists, will result in information being overwritten
         * by the annotation term present within the EntityContainer.
         */
        if (Object.keys(parserContext.entityContainerAnnotations).length > 0) {
            entityContainerAnnotations = parserContext.entityContainerAnnotations;
            /**
             * When the parserContext.entityContainerAnnotations contains the annotation target,
             * and we have unique information present within EntityContainer as well as indipendent
             * annotation, we have to merge them.
             */
            if (parserContext.entityContainerAnnotations[annotationTarget] &&
                Object.keys(parserContext.entityContainerAnnotations[annotationTarget]).length > 0
            ) {
                entityContainerAnnotations[annotationTarget] = Object.assign(
                    entityContainerAnnotations[annotationTarget], 
                    possibleAnnotations
                );
            }
            /**
             * If the annotation target name is different, we can expand all of the information
             * into a single object itself
             */
            else {
                entityContainerAnnotations[annotationTarget] = possibleAnnotations;
            }
        }
        // Simply add the possible annotations to the object with the target
        else {
            entityContainerAnnotations[annotationTarget] = possibleAnnotations;
        }
        parserContext.entityContainerAnnotations = entityContainerAnnotations;
    }

    // parse all the entity container annotations
    if (parserContext.entityContainerAnnotations) {
        _parseAnnotations(parserContext.entityContainerAnnotations, csnDefs, parserContext);
    }

    return csnDefs;
}

/**
 * @param {List<Object>} dataObjList, action/function object list
 * @returns unique parameter list
 */
function _collectAllParameters(dataObjList) {
    let uniqueParams = [], paramNames = [], params;

    for (let dataObj of dataObjList) {
        params = dataObj.$Parameter;

        if (params) {
            for (let i = 0; i < params.length; i++) {
                if (!paramNames.includes(params[i].$Name)) {
                    paramNames.push(params[i].$Name);
                    uniqueParams.push(params[i]);
                }
            }
        }
    }

    return uniqueParams;
}

/**
 * @param {Boolean} isAction, to identify action/function
 * @param {String} fqName, fully qualified name
 * @param {List<Object>} schemaDataList
 * @param {Object} parserContext
 *
 * Scenarios:
 * 1. UnBounded Actions can't have collision. Action name must be unique.
 * 2. UnBounded Functions can have collision; capture the max number of parameters.
 */
function _populateUnboundedActionFunction(isAction, fqName, schemaDataList, parserContext) {
    let [schemaName, actFunName] = _extractSchemaNameAndElementName(fqName);
    let indexOfSchema;
    [indexOfSchema, schemaName] = _getIndexAndNamespaceOfSchema(fqName, schemaName, parserContext);
    const dataList = schemaDataList[indexOfSchema][actFunName];
    let actionFunctionObject = dataList[0];
    fqName = schemaName + '.' + actFunName; // modified fqName as per new schemaName

    if (isAction) {
        if (dataList.length === 1) {
            parserContext.unboundedActions[fqName] = actionFunctionObject;
        }
        else {
            throw new Error(messages.UNBOUNDED_ACTION_COLLISION + `'${actFunName}' of Schema: ${schemaName} `);
        }
    }
    else {
        if (dataList.length > 1) {
            actionFunctionObject['$Parameter'] = _collectAllParameters(dataList);
            parserContext.unboundedFunctions[fqName] = actionFunctionObject;
        }
        else {
            parserContext.unboundedFunctions[fqName] = actionFunctionObject;
        }
        // throw error if the return type is missing
        if (!parserContext.unboundedFunctions[fqName].$ReturnType) {
            throw new Error(messages.NO_RETURN_TYPE + actFunName);
        }
    }
}

function _collectUnboundedActionFunction(schemaDataList, parserContext) {
    for (let actionName of parserContext.actionToActionImportMap.keys()) {
        _populateUnboundedActionFunction(true, actionName, schemaDataList, parserContext);
    }
    for (let functionName of parserContext.functionToFunctionImportMap.keys()) {
        _populateUnboundedActionFunction(false, functionName, schemaDataList, parserContext);
    }
}

/**
 * @param {Boolean} isAction
 * @param {String} currNamespace
 * @param {String} elementName
 * @param {List<Object>} elementDataList, bounded action/function details
 * @param {Object} parserContext
 *
 * Scenarios for bounded actions, functions:
 * 1. Actions with same name and binding parameter type can't have collision.
 * 2. Functions can have collision and we will capture the max number of parameters.
 * Special scenario is when same function name is bounded to different entity as well.
 */
function _collectBoundedActionFunction(isAction, currNamespace, elementName, elementDataList, parserContext) {
    let functionObjList; // list to collect all the collision obj for function

    for (let i = 0; i < elementDataList.length; i++) {
        let dataObj = elementDataList[i];
        let boundedEntityName = dataObj.$Parameter[0].$Type;
        let [schemaName, entityName] = _extractSchemaNameAndElementName(boundedEntityName);

        // binding parameter type should be within the current schema only
        if (currNamespace !== schemaName && currNamespace !== parserContext.schemaAliasToNamespace[schemaName]) {
            throw new Error(messages.INVALID_BOUNDED_PARAM_TYPE + ` Check the Element: ${elementName} of Schema: ${currNamespace} `);
        }
        if (!parserContext.entityTypes.includes(currNamespace + '.' + entityName)) {
            throw new Error(messages.UNRESOLVED_TYPE + boundedEntityName);
        }
        boundedEntityName = currNamespace + '.' + entityName;

        if (isAction) {
            if (!parserContext.entityToBoundedActions[boundedEntityName]?.[elementName]) {
                if (!parserContext.entityToBoundedActions[boundedEntityName]) {
                    parserContext.entityToBoundedActions[boundedEntityName] = {};
                }
                parserContext.entityToBoundedActions[boundedEntityName][elementName] = dataObj;
            }
            else {
                throw new Error(messages.BOUNDED_ACTION_COLLISION + ` Check the Element: ${elementName} of Schema: ${currNamespace} `);
            }
        }
        else {
            if (!parserContext.entityToBoundedFunctions[boundedEntityName]?.[elementName]) {
                if (!parserContext.entityToBoundedFunctions[boundedEntityName]) {
                    parserContext.entityToBoundedFunctions[boundedEntityName] = {};
                }
                if (!functionObjList || !parserContext.entityToBoundedFunctions[boundedEntityName][elementName]) {
                    functionObjList = [];
                }
                parserContext.entityToBoundedFunctions[boundedEntityName][elementName] = dataObj;
                functionObjList.push(dataObj);
            }
            else {
                functionObjList.push(dataObj);
                let functionObject = functionObjList[0];
                functionObject['$Parameter'] = _collectAllParameters(functionObjList);
                functionObjList = [functionObject]; // reset the function object list with recently formed object
                parserContext.entityToBoundedFunctions[boundedEntityName][elementName] = functionObject;
            }
            // throw error if the return type is missing
            if (!parserContext.entityToBoundedFunctions[boundedEntityName][elementName].$ReturnType) {
                throw new Error(messages.NO_RETURN_TYPE + elementName);
            }
        }
    }
}

/**
 * @param {Object} edmxAsJson, intermediate JSON
 * @param {List<Object>} schemaDataList, list of all the schema contents
 * @param {Object} parserContext, contains parser level context informations
 */
function _collectSchemaElements(edmxAsJson, schemaDataList, parserContext) {

    _collectUnboundedActionFunction(schemaDataList, parserContext);

    // capture all the references
    if (edmxAsJson.$Reference) {
        Object.entries(edmxAsJson.$Reference).forEach(ref => {
            if (ref[1].$Include[0].$Alias &&
                known_vocabularies.hasOwnProperty(ref[1].$Include[0].$Namespace)
            ) {
                parserContext.vocabAliasToNamespace[ref[1].$Include[0].$Alias] = ref[1].$Include[0].$Namespace;
            }
        });
    }

    // collect entityType, enumType, complexType, typeDefinition, bounded action/function, annotations
    for (let schemaData of schemaDataList) {
        let currNamespace = schemaData.$SchemaNamespace;

        Object.keys(schemaData).forEach(elementName => {
            let fqName = currNamespace + '.' + elementName;
            let elementData = schemaData[elementName];

            if (elementData instanceof Object) {
                if (elementData.$Kind === 'EntityType') parserContext.entityTypes.push(fqName);
                else if (elementData.$Kind === 'EnumType') parserContext.enumTypes.push(fqName);
                else if (elementData.$Kind === 'ComplexType') parserContext.complexTypes.push(fqName);
                else if (elementData.$Kind === 'TypeDefinition') parserContext.typeDefinitions.push(fqName);
                // bounded actions/functions
                else if (elementData instanceof Array) {
                    let isAction = elementData[0].$Kind === 'Action' ? true : false;
                    if (elementData[0].$IsBound) {
                        _collectBoundedActionFunction(isAction, currNamespace, elementName, elementData, parserContext);
                    }
                }
                // annotations
                else if (elementName === '$Annotations') {
                    schemaData.$Annotations = _resolveAnotationTerm(JSON.stringify(schemaData.$Annotations), parserContext);
                    /**
                     * collect entity container annotations with the assumption that
                     * we only have a single entity container
                     */
                    if (currNamespace === parserContext.primarySchema) {
                        Object.keys(schemaData.$Annotations).forEach(annotationTarget => {
                            if (annotationTarget.includes(parserContext.entityContainerName)) {
                                parserContext.entityContainerAnnotations[annotationTarget] = schemaData.$Annotations[annotationTarget];
                                /**
                                 * since already captured in the parserContext, we will directly make
                                 * use of that itself. Hence delete from the schema annotaions here.
                                 */
                                delete schemaData.$Annotations[annotationTarget];
                            }
                        });
                    }
                }
            }
        });
    }
}

function _preProcess(edmxAsJson, parserContext, importerContext) {
    _collectPrimarySchemaContext(edmxAsJson, parserContext, importerContext);
    let schemaDataList = [], indexOfSchema = 0;

    Object.keys(edmxAsJson).forEach(schemaName => {
        let schemaData = edmxAsJson[schemaName];
        // collect the schema data
        if (ignoreObjects.indexOf(schemaName) === -1 && schemaData instanceof Object) {
            schemaData.$SchemaNamespace = schemaName;
            schemaDataList.push(schemaData);
            if (schemaData.$Alias) {
                parserContext.schemaAliasToNamespace[schemaData.$Alias] = schemaName;
            }
            parserContext.schemaToSchemaDataIndex[schemaName] = indexOfSchema;
            indexOfSchema++;
        }
        // if mock server use case & traversing primary schema, collect relevant mappings
        if (parserContext.mockServerUc && schemaName === parserContext.primarySchema) {
            let entityContainerData = schemaData[parserContext.entityContainerName];
            Object.keys(entityContainerData).forEach(elementName => {
                let elementObj = entityContainerData[elementName];
                let allowedObject = (ignoreObjects.indexOf(elementName) === -1) && (elementObj instanceof Object);
                // EntityType - EntitySet, Singleton mapping
                if (allowedObject && elementObj.$Type) {
                    if (elementObj.$Collection) {
                        parserContext.entityToEntitySetMap.set(entityContainerData[elementName].$Type, elementName);
                    }
                    if (elementObj.$Singleton) {
                        parserContext.entityToSingletonMap.set(entityContainerData[elementName].$Type, elementName);
                    }
                }
                // Action - ActionImport mapping
                else if (allowedObject && elementObj.$Action) {
                    parserContext.actionToActionImportMap.set(elementObj.$Action, elementName);
                }
                // Function - FunctionImport mapping
                else if (allowedObject && elementObj.$Function) {
                    parserContext.functionToFunctionImportMap.set(elementObj.$Function, elementName);
                }
            });
        }
    });

    // if mockServerUc='true' and EntityContainer has no content, we set the value to false
    if (parserContext.mockServerUc &&
        parserContext.entityToEntitySetMap._.size === 0 &&
        parserContext.entityToSingletonMap._.size === 0 &&
        parserContext.actionToActionImportMap._.size === 0 &&
        parserContext.functionToFunctionImportMap._.size === 0)
    {
        parserContext.mockServerUc = false;
    }

    _collectSchemaElements(edmxAsJson, schemaDataList, parserContext);

    return schemaDataList;
}

function _generateCSN(edmxAsJson, ignorePersistenceSkip, parserContext, importerContext) {
    let csn = {};
    csn.meta = {};
    csn.meta.creator = 'cds-dk ' + versionInfo;
    csn.$version = '2.0';
    csn.definitions = {};
    let schemaDataList = _preProcess(edmxAsJson, parserContext, importerContext);

    for (let schemaData of schemaDataList) {
        // Step 1: parse all type definition
        csn.definitions = Object.assign(_parseCSNForTypeDefinition(schemaData, parserContext), csn.definitions);
        // Step 2: parse all enum types
        csn.definitions = Object.assign(_parseCSNForEnumType(schemaData, parserContext), csn.definitions);
        // Step 3: parse all complex types
        csn.definitions = Object.assign(_parserCSNForComplexType(schemaData, parserContext), csn.definitions);
        // Step 4: parse all entity type
        csn.definitions = Object.assign(_parseCSNForEntityType(schemaData, ignorePersistenceSkip, parserContext), csn.definitions);
        // Step 5: parse all bounded action & function
        _parseBoundedActionFunction(schemaData, csn.definitions, 'action', parserContext);
        _parseBoundedActionFunction(schemaData, csn.definitions, 'function', parserContext);
        // Step 6: parse all unbounded action & function
        csn.definitions = Object.assign(_parseUnBoundedActionFunction(schemaData, 'action', parserContext), csn.definitions);
        csn.definitions = Object.assign(_parseUnBoundedActionFunction(schemaData, 'function', parserContext), csn.definitions);
        // Step 7: parse all annotations
        if (schemaData.$Annotations) {
            _parseAnnotations(schemaData.$Annotations, csn.definitions, parserContext);
        }
    }

    // add Service object and EntityContainer items only if it is mock server use case
    if (parserContext.mockServerUc) {
        csn.definitions[parserContext.primarySchema] = {};
        csn.definitions[parserContext.primarySchema].kind = 'service';
        csn.definitions[parserContext.primarySchema]['@cds.external'] = true;

        // Step 8: parse entity container contents and their annotations
        let schemaData = schemaDataList[parserContext.schemaToSchemaDataIndex[parserContext.primarySchema]];
        let entityContainerElements = schemaData[parserContext.entityContainerName];
        csn.definitions = Object.assign(_parseEntityContainer(csn.definitions, entityContainerElements, parserContext), csn.definitions);
    }

    return JSON.stringify(csn, null, 4);
}

function _generateEDMX2JSON(edmx, name_space) {
    return new Promise(function getJson(resolve, reject) {
        try {
            const inputBuffer = edmx;
            // create converter
            const v4Conv = MetadataConverterFactory.createEdmxV40XmlToV40Json(name_space);
            v4Conv.execute(inputBuffer, (error, json, missingReferencedDocuments) => {
                if (missingReferencedDocuments?.length > 0) {
                    console.log(missingReferencedDocuments); // eslint-disable-line no-console
                }
                resolve(json);
            });
        } catch (err) {
            reject(err);
        }
    });
}

async function getEdmxv4CSN(edmx, ignorePersistenceSkip, mockServerUc, importerContext) {
    let csn;
    let edmjConverted;
    let name_space = [];

    const parserContext = {};
    _initialize(parserContext);
    parserContext.mockServerUc = mockServerUc;

    if (importerContext.beta) {
        parserContext.beta = importerContext.beta
    }

    if (importerContext.include_all_namespaces) {
        name_space.push(true);
    }
    else {
        name_space = importerContext.namespaces;
    }

    if (_isJson(edmx)) {
        return new Promise(function getCsn(resolve, reject) {
            try {
                edmjConverted = JSON.parse(edmx);
                csn = _generateCSN(edmjConverted, ignorePersistenceSkip, parserContext, importerContext);
                if (csn) resolve(csn);
            } catch (err) {
                reject(err);
            }
        });
    }
    const edmj = await _generateEDMX2JSON(edmx, name_space);
    return _generateCSN(edmj, ignorePersistenceSkip, parserContext, importerContext);
}

module.exports = {
    getEdmxv4CSN
};
