/* eslint-disable no-prototype-builtins */
'use strict';

let convert = require('xml-js');
let axios = require('axios');
const messages = require("./message").getMessages();
const cds = require('../cds');
const { fs, path, write, mkdirp, exists, read } = cds.utils;
const cdsCompiler = require('..').compile.to;
const md5 = data => require('crypto').createHash('md5').update(data).digest('hex');

let optionsMapping = {
    'keep-namespace': 'keepNamespace',
    'include-namespaces': 'includeNamespaces',
    'no-copy': 'no_copy',
    'no-save': 'no_save'
};

let apiOptions = ['includeNamespaces', 'keepNamespace', 'beta'];
let commonOptions = ['no_copy', 'no_save', 'out', 'dry', 'as', 'from', 'force', 'config'];

async function generateEDMX2JSON(edmx) {
    let cjson = convert.xml2json(edmx, {
        compact: true,
        spaces: 4
    });
    return JSON.parse(cjson);
}

async function _isValidXML(edmx) {
    let isValid = false;
    try {
        generateEDMX2JSON(edmx);
        isValid = true;
    } catch (err) {
        isValid = false;
    }
    return isValid;
}

async function _getODataVersion(edmx) {
    let oDataVersion = "";

    let checkForV2 = edmx.match(/m:DataServiceVersion="[^"]+"/);
    if (checkForV2) {
        oDataVersion = checkForV2[0].split('"')[1];
        return oDataVersion;
    }

    let edmxMatching = edmx.match(/<edmx:Edmx[^>]+"/);
    if (edmxMatching) {
        let checkForV4 = edmxMatching[0].match(/Version="[^"]+"/);
        oDataVersion = checkForV4[0].split('"')[1];
    }

    return oDataVersion;
}

// method to find the version, input is in XML format
async function getVersion(fileInputStream){
    let oDataVersion;
    const version = await _getODataVersion(fileInputStream);

    if (version === '1.0' || version === '2.0') {
        oDataVersion = 'V2';
    } else if (version === '4.0' || version === "4.01") {
        oDataVersion = 'V4';
    }
    else {
        throw new Error(messages.INVALID_EDMX_METADATA_VERSION);
    }

    return oDataVersion;
}

function checkForEmptyKeys(element, oDataVersion) {
    if (oDataVersion === "V2") {
        return (element.includes(["cds.Association"]) && !element.includes(['"on":']));
    }
    else {
        return (['cds.Association'].includes(element.type)) && !element.on && !element.keys;
    }
}

// to replace the alias value with original schema namespace value
function replaceAliasValue(schemaContent, schemaNamespaceValue, aliasValue) {
    const re = RegExp(`([("/])${aliasValue}([/").])`, 'g');
    const val = `$1${schemaNamespaceValue}$2`;
    schemaContent = schemaContent.replace(re, val);
    return JSON.parse(schemaContent);
}

async function getContentFromFile(path) {
    let fileContent;
    fileContent = await read(path, "utf-8");
    return fileContent;
}

async function getContentFromURL(url) {
    let edmx;
    const response = await axios.get(url);
    edmx = response["data"];
    if (edmx && (await _isValidXML(edmx))) {
        return edmx;
    } else {
        throw new Error(messages.INVALID_EDMX_METADATA);
    }
}

function _getSuffix(outputFormat) {
    const suffix = {
        edmx: 'xml', "edmx-v2": 'xml', "edmx-v4": 'xml', "edmx-w4": 'xml',
        "edmx-x4": 'xml', openapi: 'openapi3.json', sql: 'sql', edm: 'json', "cdl": "cds"
    };
    // find the output file extension based on the target conversion selected
    return (outputFormat) ? (suffix[outputFormat] || outputFormat) : 'csn';
}

function _supportedAsFormats() {
    return ["cds", "csn", "json"];
}

function _supportedFileExtensions() {
    return ["edmx", "xml", "json"];
}

function _getInputFileExtension(inputFile) {
    let startIndex = inputFile.lastIndexOf(".");
    return inputFile.substring(startIndex + 1);
}

async function isValidInputFile(inputFileLoc) {
    const fileResolved = await fs.isfile(inputFileLoc);
    if (!fileResolved) throw new Error(messages.SPECIFY_INPUT_FILE);
    let fileExtension = _getInputFileExtension(inputFileLoc);
    if (_supportedFileExtensions().includes(fileExtension)) return fileResolved;
    else throw new Error(messages.INVALID_INPUT_FILE);
}

async function _copyToSrvExternal(file, dst, cwd) {
    const dstDir = path.dirname(dst), srcDir = path.dirname(file);
    if (!file.startsWith(dstDir + path.sep)) {
        await mkdirp(dstDir);
        const copyOrMove = srcDir === cwd || srcDir == process.cwd() ? fs.renameSync : fs.copyFileSync;
        await copyOrMove(file, dst);
        return dst;
    }
    return file;
}

async function preProcess(file, options, cwd) {
    let srcFilePath = await isValidInputFile(path.resolve(cwd, file));
    if (options.as && !_supportedAsFormats().includes(options.as))
        throw new Error(messages.INVALID_AS_OPTION);
    return srcFilePath;
}

async function processOptions(cliOptions, odataOptions) {
    // maps to renaming of variables
    for (let [key, value] of Object.entries(optionsMapping)) {
        if (cliOptions[key]) {
            cliOptions[value] = cliOptions[key];
            delete cliOptions[key];
        }
    }
    // segregating cli/odata options
    apiOptions.forEach(function (item) {
        odataOptions[item] = cliOptions[item];
        delete cliOptions[item];
    });
    // reads cli options from environment
    readEnvVariables(cliOptions, true);
}

function _getServiceNames(csn) {
    let serviceList = [];
    for (let each in csn.definitions) {
        if (csn.definitions[each].kind === 'service') serviceList.push(each);
    }
    return serviceList;
}

function _validateAndComputeOutputFilePath(outputFileLoc, as, destFilePath) {
    let index, extension, expectedExtension, supportedExtension;
    if (typeof (outputFileLoc) !== 'boolean') {
        index = outputFileLoc.lastIndexOf(".");
        extension = outputFileLoc.substring(index + 1);
        expectedExtension = (as) ? _getSuffix(as) : "csn";
        supportedExtension = (index > 0) ? _supportedAsFormats().includes(extension) : false;
    }

    if (outputFileLoc === true || // if output file is not mentioned
        outputFileLoc[0] === "-" || // if output file is missing and "--as" is considered as output file
        outputFileLoc.trim() === "") {
        throw new Error(messages.SPECIFY_OUTPUT_FILE);
    } else if (index > 0 && !supportedExtension) {
        // extension not supported, eg., "test.abs", "./sv/external.test.abcs", "./a."
        throw new Error(messages.INVALID_OUTPUT_FILE);
    } else if (index > 0 && !as && extension != "json" && extension != "csn") {
        // --as option is not provided but output file is like: "test.cds", "./srv/external/test.cds"
        throw new Error(messages.INCORRECT_EXTENSION);
    } else if (index > 0 && as && extension != expectedExtension) {
        // extension not supported by --as option, e.g., "cds import <file> --out test.yml --as cds"
        throw new Error(messages.OUTPUT_FILE_MISMATCH);
    } else if (supportedExtension || (!outputFileLoc.endsWith("\\") && !outputFileLoc.endsWith("/"))) {
        // eg., "./a.csn", "tst.cds", "./srv/external/test", "test", "c:\windows\output\test"
        return outputFileLoc;
    } else if (outputFileLoc.endsWith("/") || outputFileLoc.endsWith("\\")) {
        // File name not specified ("./srv/external/", "c:\windows\output\test\")
        return outputFileLoc + path.parse(destFilePath).name;
    }
}

async function _generateChecksumValidate(dest, output, force) {
    let fileExists = await exists(dest);

    // force flag disabled and cds file already exists, then throw error
    if (!force && fileExists) {
        throw new Error(messages.FILE_MODIFIED);
    }

    const currentChecksum = md5(output);
    let existingFileContent, existingFileContentWithoutChecksum;
    let existingFileContentChecksum, existingChecksumValue;

    if (fileExists) {
        existingFileContent = await read(dest, "utf-8");
        const checksumStartIndex = existingFileContent.indexOf(`/* checksum : `);
        const checksumEndIndex = existingFileContent.indexOf(" */");

        if (checksumStartIndex >= 0) {
            existingFileContentWithoutChecksum = existingFileContent.substring(
                checksumEndIndex + 4
            );
            existingChecksumValue = existingFileContent.substring(
                checksumStartIndex + 14, checksumEndIndex
            );
            existingFileContentChecksum = md5(existingFileContentWithoutChecksum);
        }
    }

    // if force flag enbabled
    if (force) {
        // current and existing file content are same, and the existing
        // checksum is not modified, then return the existing file content
        if (currentChecksum == existingFileContentChecksum &&
            currentChecksum == existingChecksumValue) {
            return existingFileContent;
        }
    }
    /**
     * 1. current and existing checksum are different.
     * 2. checksum is missing in the existing file:
     *     a. existing and current file content are same.
     *     b. existing and current file content are different.
     * 3. cds file doesn't exist.
     * 4. checksum of the existing file is modified.
     */
    return "/* checksum : " + currentChecksum + " */\n" + output;
}

async function _getResult(output, as, dest, force, kind) {
    let extension = dest.substring(dest.lastIndexOf(".") + 1);
    as = (as === "cds") ? "cdl" : as;

    // output filepath should simply contain .csn as extension
    if (kind === 'rest' &&  ['swagger', 'openapi3'].includes(extension)) {
        dest = dest.replace('.' + extension, '');
    }

    if (!_supportedAsFormats().includes(extension)) {
        // dest doesn't have any file extension, so get it
        extension = _getSuffix(as);
        dest += '.' + extension;
    }

    if (as && as != "csn" && as != "json") {
        // cdsCompiler[as] will convert the csn output into various output formats
        output = cdsCompiler[as](output);
    }

    switch (as) {
        case "cdl":
            output = await _generateChecksumValidate(dest, output, force);
            break;
        case undefined:
        case "csn":
        case "json":
            output = JSON.stringify(output, null, ' ');
            break;
        default:
            break;
    }

    return [output, dest];
}

async function _write(result, service, cwd) {
    let dest, output, using, message, extenstion;
    output = result[0];
    dest = result[1];
    await write(dest, output, "utf-8");
    extenstion = dest.substring(dest.lastIndexOf('.'));
    dest = dest.replace(extenstion, '');
     if (service.length > 1){
        using = `using { ${service.join(', ')}} from './${path.relative('srv', dest).replace(/\\/g, '/')}'`;
     }
     else{
        using = `using { ${service} as external } from './${path.relative('srv', dest).replace(/\\/g, '/')}'`;
     }
    using = require('../util/term').info(using);
    message = `[cds] - imported API to ${path.relative(cwd, dest)}
> use it in your CDS models through the like of:

${using}
`;

    console.log(message);
}

async function _updatePackageJson(dest, services, kind, cwd, config) {
    const package_json = path.resolve(cwd, 'package.json');
    const conf = await exists(package_json) ? require(package_json) : {};
    const requires = ['cds', 'requires'].reduce((p, n) => p[n] || (p[n] = {}), conf);
    if (kind !== 'rest') {
        kind = (kind === "V2") ? 'odata-v2' : 'odata';
    }
    let package_json_updated = false;
    for (let service of services) {
        if (!requires[service]) {
            const initial_model = path.relative(cwd, dest);
            const model = isLinux() ? initial_model.replace(/\\/g, '/') : initial_model;
            cds.env.requires[service] = requires[service] = { kind: kind, model, ...config };
            await write(package_json, JSON.stringify(conf, null, '  '));
            package_json_updated = true;
        }
    }
    if (package_json_updated) {
        console.log(`[cds] - updated ./package.json`);
    }
}

function _parseValidJsonConfig(config) {
    try {
        if (config) {
            return JSON.parse(config);
        }
    } catch (error) {
        throw new Error(messages.SPECIFY_CONFIG);
    }
}

async function postProcess(filePath, options, csn, cwd) {
    const services = _getServiceNames(csn);
    let config = _parseValidJsonConfig(options.config);
    const external = path.resolve(cwd, 'srv/external');
    const destFilePath = path.join(external, path.basename(filePath));
    if (options.out) options.out = _validateAndComputeOutputFilePath(options.out, options.as, destFilePath);
    const kind = options.inputFileKind;
    const result = await _getResult(csn, options.as, options.out || destFilePath.replace(/\.[^.]+$/, ''), options.force, kind);
    const written = options.dry || await _write(result, services, cwd);
    const registered = options.dry || options.no_save || await _updatePackageJson(result[1].replace(/\.[^.]+$/, ''), services, kind, cwd, config);
    if (!options.dry && !options.no_copy)
        await _copyToSrvExternal(filePath, destFilePath, cwd);
    if (options.dry) return console.log(result[0]);
    return Promise.all([written, registered]);
}

async function identifyFile(filepath) {
    let extension = _getInputFileExtension(filepath);
    if (["edmx", "xml"].includes(extension)) {
        return "edmx";
    } else if (["json", "yaml", "yml"].includes(extension)) {
        // based on the file content determine if it is openapi or asyncapi file and return the correct type
        filepath = await isValidInputFile(path.resolve(process.cwd(), filepath));
        const src = await getContentFromFile(filepath);
        // for openapi
        let jsonSrc = JSON.parse(src);
        if (jsonSrc.hasOwnProperty('openapi') || jsonSrc.hasOwnProperty('swagger')) {
            return "openapi";
        } else if (jsonSrc.hasOwnProperty('asyncapi')) {
            return "asyncapi";
        }
    } else
        return extension;
}

function isLinux() {
    let platform = process.platform;
    if (platform === 'linux' || platform === 'win32') {
        return true;
    }
}

function readEnvVariables(options, cliCheck) {
    if (cds.env.import) {
        if (cliCheck) {
            for (let key of commonOptions) {
                if (key !== 'force' && !options[key]) {
                    options[key] = cds.env.import[key];
                }
            }
            if (options.as && !options.force) options.force = cds.env.import.force;
        }
        else {
            for (let [key, value] of Object.entries(options)) {
                if (!value) options[key] = cds.env.import[key];
            }
        }
    }
}

module.exports = {
    generateEDMX2JSON,
    getVersion,
    checkForEmptyKeys,
    replaceAliasValue,
    getContentFromFile,
    getContentFromURL,
    isValidInputFile,
    preProcess,
    postProcess,
    identifyFile,
    readEnvVariables,
    processOptions
};
