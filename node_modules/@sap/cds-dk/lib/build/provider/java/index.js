const fs = require('fs')
const path = require('path')
const cds = require('../../../cds')
const EdmxBuildPlugin = require('../edmxBuildPlugin')
const { OUTPUT_MODE, OUTPUT_MODE_RESULT, FILE_EXT_CDS, CONTENT_LANGUAGE_BUNDLES, CONTENT_DEFAULT_CSN, DEFAULT_CSN_FILE_NAME,
    OUTPUT_MODE_FILESYSTEM, FLAVOR_LOCALIZED_EDMX, CONTENT_EDMX, CONTENT_LOCALIZED_EDMX } = require('../../constants')
const { getI18nDefaultFolder } = require('../../util')
const DEFAULT_COMPILE_DEST_FOLDER = path.normalize('src/main/resources/edmx')
const DEBUG = cds.debug('cli|build')

class JavaBuildPlugin extends EdmxBuildPlugin {
    init() {
        super.init()
        this.task.options.compileDest = path.resolve(this.task.dest, this.task.options.compileDest || DEFAULT_COMPILE_DEST_FOLDER)
    }

    async build() {
        const compileDest = this.task.options.compileDest
        const { src, dest } = this.task
        const model = await this.model()
        if (!model) {
            return
        }
        await this._compileForJava(model, compileDest)

        if (!this.hasBuildOption(CONTENT_EDMX, false)) {
            // generate edmx files containing all features
            // REVISIT: localized edmx for backward compatibility
            if (!this.hasBuildOption(CONTENT_LOCALIZED_EDMX, false)) {
                await this.compileToEdmx(model, compileDest, { [FLAVOR_LOCALIZED_EDMX]: true })
            }
            // non-localized edmx
            await this.compileToEdmx(model, path.join(compileDest, 'odata', cds.env.odata.version), { [FLAVOR_LOCALIZED_EDMX]: this.hasBuildOption(FLAVOR_LOCALIZED_EDMX, true) })
        }

        if (!this.hasBuildOption(CONTENT_LANGUAGE_BUNDLES, false)) {
            // collect and write language bundles containing all features
            const i18n = await this.collectLanguageBundles(model, path.join(compileDest, getI18nDefaultFolder()))
            if (i18n && this.hasBuildOption(OUTPUT_MODE, OUTPUT_MODE_RESULT)) {
                this._result.languageBundles = i18n.bundles
            }
        }
        if (this.isStagingBuild() && this.hasBuildOption(OUTPUT_MODE, OUTPUT_MODE_FILESYSTEM)) {
            await this._copyNativeContent(src, dest)
        }
        return this._result
    }

    async clean() {
        if (this.isStagingBuild()) {
            return super.clean()
        }
        DEBUG?.(`Deleting build target folder ${this.task.options.compileDest}`)
        await fs.promises.rm(this.task.options.compileDest, { force: true, recursive: true })
    }

    async _copyNativeContent(src, dest) {
        return super.copyNativeContent(src, dest, (entry) => {
            if (fs.statSync(entry).isDirectory()) {
                return true // using common filter for folders
            } else {
                const extname = path.extname(entry)
                return extname !== FILE_EXT_CDS
            }
        })
    }

    async _compileForJava(model, csnDest, compileOptions = {}) {
        // csn for service providers
        const m = cds.compile.for.java(model, {
            ...this._options4odata(),
            ...compileOptions
        })
        const csnFile = path.join(csnDest, DEFAULT_CSN_FILE_NAME)
        // adding csn to build result containing @source and _where persisted properties
        if (this.hasBuildOption(CONTENT_DEFAULT_CSN, true)) { //default true or undefined
            const csnStr = await this.compileToJson(model, csnFile)
            if (this.hasBuildOption(OUTPUT_MODE, OUTPUT_MODE_RESULT)) {
                const csnModel = JSON.parse(csnStr)
                csnModel.meta = model.meta
                this._result.csn = csnModel
            }
        } else {
            const csnStr = await this.compileToJson(m, csnFile)
            if (this.hasBuildOption(OUTPUT_MODE, OUTPUT_MODE_RESULT)) {
                const csnModel = JSON.parse(csnStr)
                csnModel.meta = m.meta
                this._result.csn = csnModel
            }
        }
        return m
    }
}
module.exports = JavaBuildPlugin
