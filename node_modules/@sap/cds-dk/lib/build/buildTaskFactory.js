const fs = require('fs')
const path = require('path')
const cds = require('../cds')
const BuildTaskProviderFactory = require('./buildTaskProviderFactory')
const { hasJavaNature, getProperty, flatten, getDefaultModelOptions, hasOptionValue } = require('./util')
const { FILE_EXT_CDS, BUILD_TASK_JAVA_CF, BUILD_TASK_JAVA, CONTENT_WS } = require("./constants")
const term = require('../util/term')
const DEBUG = cds.debug('cli|build')

class BuildTaskFactory {
    constructor(options) {
        this._providerFactory = new BuildTaskProviderFactory(options)
    }
    get providerFactory() {
        return this._providerFactory
    }
    get options() {
        return this.providerFactory.options
    }

    // the following order for determining build tasks is used
    // 1. create from command line input, e.g. cds build/all --for hana --src db --model srv --dest db
    // 2. read using cds.env.build.tasks
    // 3. create from cds.env.folders config data
    async getTasks() {
        const tasks = await this._createTasks()

        // log build tasks
        let tasksOutput = "{\n  build: {\n    target: " + term.info("'" + cds.env.build.target + "'") + ",\n    tasks: [\n"
        for (let i = 0; i < tasks.length; i++) {
            tasksOutput += "      " + BuildTaskFactory._stringifyTask(tasks[i]) + (i + 1 < tasks.length ? ",\n" : "\n")
        }
        tasksOutput += "    ]\n  }\n}\n"
        console.log(tasksOutput)

        // always resolve tasks for input validation
        const resolvedTasks = this.providerFactory.resolveTasks(tasks)
        if (this.options.resolve) {
            return resolvedTasks
        }
        return tasks
    }

    createPlugin(task) {
        return this.providerFactory.createPlugin(task)
    }

    async _createTasks() {
        DEBUG?.(`determining build tasks for project [${cds.root}].`)

        // clearing model cache (details https://github.tools.sap/cap/cds/pull/181) is no longer required
        // because of changes https://github.tools.sap/cap/cds/pull/1121
        // cds.resolve.cache = {}

        let tasks = BuildTaskFactory._getExistingTasks()
        if (tasks.length === 0) {
            tasks = await this.providerFactory.lookupTasks()
            this._applyCliOptions(tasks)
        } else {
            this._applyCliOptions(tasks)
            // 1. apply default values including task.for and task.use and ensure that for all tasks a provider exists - throwing error otherwise
            await this.providerFactory.applyTaskDefaults(tasks)
            // ensure that dependencies get wired up before filtering
            await this.providerFactory.lookupTasks(tasks, true)
        }

        // 2. filters the list of build tasks
        // Note: A new task might get created, e.g. 'cds build --for hana' will enforce a hana build even if sqlite has been configured
        let existingTasks = tasks
        tasks = await this._filterTasksForCli(tasks)
        if (tasks.length === 0) {
            return tasks
        }

        // 3. add dependencies
        existingTasks = [...tasks]
        await this.providerFactory.lookupTasks(tasks, true)
        if (tasks.length > existingTasks.length) {
            const newTasks = tasks.filter(task => !existingTasks.includes(task))
            // a dependant task was added
            this._applyCliOptions(newTasks)
        }

        // obligatory task defaults shared by all tasks
        await BuildTaskFactory._applyCommonTaskDefaults(tasks)

        this._setDefaultBuildTargetFolder(tasks)
        return tasks
    }

    static _getExistingTasks() {
        return Array.isArray(getProperty(cds.env, 'build.tasks')) ? JSON.parse(JSON.stringify(cds.env.build.tasks)) : []
    }

    static async _applyCommonTaskDefaults(tasks) {
        // normalize model options
        tasks.forEach(task => {
            if (task.options?.model && !Array.isArray(task.options.model)) {
                task.options.model = [task.options.model]
            }
        })
        // there must be at least one task without model options
        if (!tasks.some(task => !task.options?.model?.length > 0)) {
            return
        }
        const modelPaths = await getDefaultModelOptions()
        let wsModelPaths
        // calculate only once
        if (cds.cli.options?.ws || tasks.some(task => hasOptionValue(task.options?.[CONTENT_WS], true))) {
            wsModelPaths = await getDefaultModelOptions(true)
        }
        // set default model options
        tasks.forEach(task => {
            this._setTaskModelOptions(task, cds.cli.options?.ws || hasOptionValue(task.options?.[CONTENT_WS], true) ? wsModelPaths : modelPaths)
            if (!task.src) {
                throw new Error(`Invalid build task definition - value of property 'src' is missing in [${task.for || task.use}].`)
            }
        })
    }

    _setDefaultBuildTargetFolder(tasks) {
        const task = tasks.find(task => task.for === BUILD_TASK_JAVA_CF || task.for === BUILD_TASK_JAVA)
        const srv = task ? task.src : BuildTaskFactory._getModuleFolder(flatten([cds.env.folders.srv])) || "srv"

        // Java projects use "." as the default build target folder
        if (hasJavaNature([path.join(cds.root, srv), cds.root]) && BuildTaskFactory._adaptBuildTargetSettingForJava()) {
            DEBUG?.("using inplace build for java project instead of default staging build")
        }
    }

    /**
    * Use inplace build for java projects if build.target has not been configured.
    * @returns {boolean} true if changed, false otherwise
    */
    static _adaptBuildTargetSettingForJava() {
        if (cds.env.build.target !== ".") {
            // filter user settings of cds.env
            const userEnv = cds.env.for("cds", cds.root, false)

            // use helper as env.build might be undefined
            if (!userEnv.build?.target) {
                cds.env.build.target = "."
                return true
            }
        }
        return false
    }

    async _filterTasksForCli(tasks) {
        const options = this.options
        // filter tasks using either option for, use, src
        let resultTasks = tasks.filter(task => {
            return (!options.use || options.use === task.use)
                && (!options.for || options.for === task.for)
                && (!options.src || options.src === task.src)
        })
        if (resultTasks.length === 0) {
            if (options.for || options.use) {
                const task = this.providerFactory.getTask(options.for ? { for: options.for } : { use: options.use })
                if (options.src) {
                    task.src = options.src
                }
                resultTasks.push(task)
                this._applyCliOptions(resultTasks)
                await this.providerFactory.applyTaskDefaults(resultTasks)
            }
        } else if (resultTasks.length <= tasks.length) {
            // return the same array as long as it contains a subset of the given tasks
            tasks.length = 0
            resultTasks.forEach(task => tasks.push(task))
            resultTasks = tasks
        }
        return resultTasks
    }

    _applyCliOptions(tasks) {
        const options = this.options
        // apply remaining cli options to filtered tasks
        tasks.forEach(task => {
            if (options.dest) {
                task.dest = options.dest
            }
            if (options.opts) {
                const opts = BuildTaskFactory._scanTaskOptionParams(options.opts)
                task.options = task.options ? Object.assign(task.options, opts) : opts
            }
        })
    }

    static _setTaskModelOptions(task, defaultModelPaths) {
        task.options = task.options || {}
        if (!task.options.model?.length > 0) {
            defaultModelPaths = new Set(defaultModelPaths)
            if (task.src) {
                defaultModelPaths.add(task.src)
            }
            task.options.model = [...defaultModelPaths]
        }
    }

    static _stringifyTask(task) {
        // ensures identical order of properties
        const order = ["for", "use", "src", "dest", "options"]
        const keys = Object.keys(task).filter(key => order.includes(key)).sort((a, b) => order.indexOf(a) - order.indexOf(b))

        return keys.reduce((acc, key, i) => {
            const prefix = acc !== '{' ? ', ' : (i === 0 ? ' ' : '')
            if (!key.startsWith('_')) {
                // render either "for" OR "use" value
                if (key in { src: 1, for: 1 } || (!task.for && key === 'use')) {
                    return `${acc}${prefix}${key}: ${term.info(`'${task[key]}'`)}`
                } else if (key === 'options') {
                    const options = Object.entries(task.options)
                        .map(([key, value]) => {
                            if (Array.isArray(value)) {
                                return `${key}: [${value.map(v => term.info(`'${v}'`)).join(', ')}]`
                            } else if (typeof value === 'object') {
                                const nested = Object.entries(value)
                                    .map(([key, value]) => `${key}: ${term.info(`'${value}'`)}`)
                                    .join(', ')
                                return `${key}: { ${nested} }`
                            } else {
                                return `${key}: ${term.info(`'${value}'`)}`
                            }
                        })
                        .join(', ')
                    return `${acc}${prefix}${key}: { ${options} }`
                } else if (key !== 'use') {
                    return `${acc}${prefix}${key}: ${term.info(`'${task[key]}'`)}`
                }
            }
            return acc
        }, '{') + '}'
    }

    static _scanTaskOptionParams(optsParams) {
        // need to create new regex every call since a constant would keep the match state
        const quoteRegex = /([\w-]+)=([\w/.-]+|\[([\w/,.-]+)\])/g

        // captures a=1             => a:1
        //          a=[x,y,z]       => a:[x,y,z]
        //          a=1,b=[x,y,z]   => a:1 b=[x,y,z]
        let match = quoteRegex.exec(optsParams)
        const taskOptions = {}

        while (match != null) {
            const key = match[1]
            const value = match[3] || match[2]
            const valueArray = value.split(",")
            taskOptions[key] = valueArray.length > 1 ? valueArray.map((entry) => entry.trim()) : value
            match = quoteRegex.exec(optsParams)
        }
        return taskOptions
    }

    /**
     * Determines the module folder from the past list that may represent files or folders w or w/o .cds file extension.
     * @param {Array} filesOrFolders
     */
    static _getModuleFolder(filesOrFolders) {
        const resources = [...filesOrFolders]
        filesOrFolders.forEach(fileOrFolder => {
            if (path.extname(fileOrFolder) !== FILE_EXT_CDS) {
                resources.push(fileOrFolder + FILE_EXT_CDS)
            }
        })
        return resources.reduce((acc, resource) => {
            if (!acc) {
                let resourcePath = path.resolve(cds.root, resource)
                if (fs.existsSync(resourcePath)) {
                    if (fs.lstatSync(resourcePath).isDirectory()) {
                        acc = resource
                    } else {
                        // represents file
                        acc = path.dirname(resource)
                    }
                }
            }
            return acc
        }, null)
    }
}
module.exports = BuildTaskFactory
