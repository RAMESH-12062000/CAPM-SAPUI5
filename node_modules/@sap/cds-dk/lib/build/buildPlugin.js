const path = require('path')
const fs = require('fs').promises
const cds = require('../cds')
const { OUTPUT_MODE, OUTPUT_MODE_FILESYSTEM, SEVERITY_INFO, SEVERITY_WARNING, SEVERITY_ERROR } = require('./constants')
const { hasOptionValue, getProperty, relativePaths, BuildMessage, pathExists } = require('./util')
const DEBUG = cds.debug('cli|build')

/**
 * The build plugin creates the build output for a dedicated build task. It is uniquely identified
 * by the build task's <code>for</code> or <code>use</code>property. The <code>use</code> property represents 
 * the fully qualified node module path of the build plugin implementation.
 * <p>
 * The build task engine defines the following protocol. The methods are invoked in descending order:
 * <ul>
 *  <li>init() - optional</li>
 *  <li>get priority() - optional</li>
 *  <li>async clean()</li>
 *  <li>async build()</li>
 * </ul>
 * The reflected CSN can be accessed using the async method <code>model()</code>.
 */
class BuildPlugin {
    /**
     * @constructor
     */
    constructor() {
        this._written = new Set()
        this._messages = []
    }
    static hasTask() {
        return true
    }
    static INFO = SEVERITY_INFO
    static WARNING = SEVERITY_WARNING
    static ERROR = SEVERITY_ERROR
    /**
     * Returns the build context
     * @returns {object}
     */
    get context() {
        return this._context
    }
    /**
     * Returns the build task executed by this build plugin.
     * @return {object}
     */
    get task() {
        //injected by framework
        return this._task
    }

    /**
     * Returns a list of build and compiler messages created by this build plugin. 
     * Supported message severities are 'Info', 'Warning', and 'Error'.
     * @return {Array}
     */
    get messages() {
        return this._messages
    }

    /**
     * Returns the list of files written by this build plugin.
     * @return {Array}
     */
    get files() {
        return [...this._written]
    }

    /**
     * Returns the priority of this plugin as number, where 0 represents the minimum value and
     * Number.MAX_SAFE_INTEGER the maximum value.
     * Positive numbers mean higher and negative numbers lower priority. Build plugins
     * with higher priority value are executed before plugins with lower priority.
     * <br>
     * Note: Currently not supported for custom build plugins as they are always executed
     * before the built-in plugins.
     * @return {number} the priority for this plugin as integer.
     */
    get priority() {
        return 1
    }
    /**
     * Called by the framework immediately after this instance has been created.
     * The instance has already been fully initialized.
     */
    init() {
        if (cds.env.build.target === '.') {
            this.task.dest = path.join(this.task.dest, 'gen')
        }
    }

    /**
     * @abstract
     * Called by the framework to create the artifacts of this build plugin.
     */
    async build() {
    }

    /**
     * Called by the framework immediately before 'build' to delete any output created by this build plugin.
     * <p>
     * Note: The <code>BuildTaskEngine</code> is cleaning the common generation target folder if the build is
     * executed in staging mode, e.g. build.target: "gen".
     */
    async clean() {
        function isSubDirectory(parent, child) {
            return !path.relative(parent, child).startsWith('..')
        }
        if (cds.env.build.target === '.'
            && this.task.src !== this.task.dest
            && !isSubDirectory(this.task.dest, this.task.src)
            && await pathExists(this.task.dest)) {
            return fs.rm(this.task.dest, { force: true, recursive: true })
        }
    }

    /**
     * Asynchronously write the given content to a given file path.
     * If the file exists the content is replaced. If the file does not exist, a new file will be created.
     * The file name is stored in the list of files written by this build plugin.
     * @param {string} dest - absolute or relative file path. Relative paths will be resolved to this task's destination path.
     * @param {any} data - If data is of type object the JSON-stringified version is written.
     */
    write(data) {
        return {
            to: async (dest) => {
                if (this._hasBuildOption(OUTPUT_MODE, OUTPUT_MODE_FILESYSTEM)) {
                    if (!path.isAbsolute(dest)) {
                        // relative to build task's destination path
                        dest = path.resolve(this.task.dest, dest)
                    }
                    this.pushFile(dest)
                    await fs.mkdir(path.dirname(dest), { recursive: true })
                    await fs.writeFile(dest, typeof data === "object" && !Buffer.isBuffer(data) ? JSON.stringify(data, null, 2) : data)
                }
            }
        }
    }

    // TODO only works with files due to fs.copyFile, check usages
    /**
     * Copy a file or directory if the build task option 'outputMode' does not have the value 'resultOnly'.
     * The directory can have contents.
     * <p>
     * Note: The file name is stored in the list of files written by this build plugin.
     * </p>
     * @param {string} src The absolute or relative source path of the file or directory to copy.
     * Relative paths will be resolved to this task's source path.
     * @param {string} dest The absolute or relative target path. Relative paths will be resolved to this task's destination path.
     *
     */
    copy(src) {
        return {
            to: async (dest) => {
                if (this._hasBuildOption(OUTPUT_MODE, OUTPUT_MODE_FILESYSTEM)) {
                    if (!path.isAbsolute(src)) {
                        // relative to build task's source path
                        src = path.resolve(this.task.src, src)
                    }
                    if (!path.isAbsolute(dest)) {
                        // relative to build task's destination path
                        dest = path.resolve(this.task.dest, dest)
                    }
                    this.pushFile(dest)
                    return fs.cp(src, dest, { recursive: true })
                }
                return dest
            }
        }
    }

    /**
     * Adds the given user message and severity to the list of messages issued by this build task.
     * <p>
     * User messages will be logged after CDS build has been finished based on the log-level that has been set.
     * By default messages with severity <em>warning</em> and <em>error</em> will be logged.
     * @param {string} message the message text
     * @param {string} severity the severity of the message
     */
    pushMessage(message, severity) {
        this.messages.push(new BuildMessage(message, severity))
    }

    /**
     * Returns the reflected CSN model using this build task's model settings.
     * @return {object} the reflected CSN
     */
    async model() {
        const files = this._resolveModel()
        if (!files || files.length === 0) {
            console.log(`no CDS model found for [${this.task.for}] build task [${this.task.src}] - nothing to be done`)
            return null
        }
        DEBUG?.(`model: ${relativePaths(cds.root, files).join(", ")}`)
        // $location paths are relative to current working dir by default - make sure a given project root folder is taken
        const options = { ...this.options(), cwd: cds.root }

        const model = await cds.load(files, options)
        if (!model) {
            return null
        }
        return model
    }

    options() {
        return { messages: this._messages }
    }

    /**
     * Adds the given fully qualified file path to the list of files that are written by this build task.
     * @param {string} filePath
     */
    pushFile(filePath) {
        this._written.add(filePath)
    }
    /**
     * Returns a list of CDS model files defining the transitive closure of the CDS model based on the model options
     * defined for this build task.
     */
    _resolveModel() {
        const modelPaths = Array.isArray(this.task.options.model) && this.task.options.model.length > 0 ? this.task.options.model : !Array.isArray(this.task.options.model) && this.task.options.model || this.task.src
        return cds.resolve(modelPaths)
    }
    /** Determines whether the given build option value has been set for this build task.
      * If the value is omitted, the existence of the given property name is checked.
      */
    _hasBuildOption(qualifiedName, value) {
        return hasOptionValue(this._getBuildOption(qualifiedName), value)
    }

    // Returns the value of the given build option defined for this build task.
    _getBuildOption(qualifiedName) {
        // build task options overwriting other settings
        let value = getProperty(this.context.options, qualifiedName) // command line
        if (value === undefined) {
            value = getProperty(this.task.options, qualifiedName) // task options
        }
        return value
    }
}
module.exports = BuildPlugin
