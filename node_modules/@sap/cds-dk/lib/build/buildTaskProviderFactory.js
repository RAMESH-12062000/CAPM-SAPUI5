const fs = require('fs')
const path = require('path')
const cds = require('../cds')
const { OUTPUT_MODE_FILESYSTEM, DEFAULT_SRC_FOLDER } = require('./constants')
const InternalBuildTaskProvider = require('./provider/internalBuildTaskProvider')
const BuildTaskProvider = require('./buildTaskProvider')
const { BuildError } = require('./util')
const DEBUG = cds.debug('cli|build')

class BuildTaskProviderFactory {
    constructor(options = {}) {
        options.outputMode = options.outputMode || OUTPUT_MODE_FILESYSTEM
        if (options.clean === undefined) {
            options.clean = true
        }
        ['for', 'src', 'dest'].forEach(key => {
            if (options[key] && typeof options[key] !== 'string') {
                throw new BuildError(`Invalid build options - property '${key}' must be a string`)
            }
        })
        this._buildOptions = options
        this._context = { options, tasks: [] } // resolved tasks
    }
    get options() {
        return this._context.options
    }
    get context() {
        return this._context
    }
    get providers() {
        if (!this._providers) {
            this._providers = this._loadProviders()
        }
        return this._providers
    }

    getTask(key) {
        return this._getProvider(key).getTask(key)
    }

    async applyTaskDefaults(tasks) {
        return Promise.all(tasks.map(async (task) => {
            if (!task.for && !task.use) {
                throw new Error(`Invalid build task definition - property 'for' and property 'use' missing`)
            }
            const provider = this._getProvider(task)
            if (provider instanceof DefaultBuildTaskProvider) {
                DEBUG?.(`No provider found for build task '${task.use}', using default provider`)
            }
            return this._applyTaskDefaults(provider, [task])
        }))
    }

    async lookupTasks(tasks = [], dependencies) {
        for (let i = 0; i < this.providers.length; i++) {
            const provider = this.providers[i]
            const existingTasks = [...tasks]
            await this._lookupTasks(provider, tasks, dependencies)
            if (existingTasks.length < tasks.length) {
                // apply defaults
                const newTasks = tasks.filter(task => !existingTasks.includes(task))
                await this._applyTaskDefaults(provider, newTasks)
                DEBUG?.(`Build task provider ${provider.constructor.name} returned build tasks ${JSON.stringify(newTasks)}`)
            }
        }
        return tasks
    }

    /**
     * Create a BuildPlugin instance for the given build task.
     * The implementation is loaded based on the build task's 'for' or 'use' option.
     * @param {*} task
     */
    createPlugin(task) {
        const BuildPlugin = this.getPlugin(task)
        const resolvedTask = this._resolveTask(task)
        DEBUG?.(`loaded build plugin [${resolvedTask.use}]`)

        const plugin = new BuildPlugin()
        if (!(plugin instanceof BuildPlugin)) {
            throw new Error(`Invalid Build plugin type ${task.for}`)
        }
        plugin._task = resolvedTask
        plugin._context = this.context
        this.context.tasks.push(resolvedTask)
        DEBUG?.(`created build plugin [${resolvedTask.use}]`)
        return plugin
    }

    /**
     * Loads the build plugin implementation for the given build task.
     * 'for' defines an alias for built-in plugins like 'hana', 'java', 'node', 'fiori' or 'mtx'.
     * 'use' defines the fully qualified module name of custom build plugins implementations.
     * @param {object} task
     */
    getPlugin(task) {
        const provider = this._getProvider(task)
        try {
            return provider.getPlugin(task)
        } catch (e) {
            console.error(`Provider failed to load build plugin class - provider: ${provider.constructor.name}, task: ${task.for || task.use} :\n` + e)
            throw e
        }
    }

    resolveTasks(tasks) {
        return tasks.map(task => this._resolveTask(task))
    }

    /**
     * Resolves the given build task based on the project root folder.<br>
     * The task is validated in order to ensure that 'src' refers to a valid folder and 'for' or 'use' reference can be required.
     * @param {*} task
     */
    _resolveTask(task) {
        // second validate src path
        const resolvedTask = JSON.parse(JSON.stringify(task))

        // Do not store resolved symlinks as this is causing issues on Windows, e.g. if git projects are
        // located under 'C:\SAPDevelop\git\...' using a sym-link from '%USERHOME%\git' to 'C:\SAPDevelop\git'.
        // see cap/issues/#8694
        resolvedTask.src = path.resolve(cds.root, task.src)
        try {
            //validate source path
            fs.realpathSync(resolvedTask.src)
        } catch (e) {
            throw new Error(`Build task [${resolvedTask.for || resolvedTask.use}] could not be resolved - folder src [${path.resolve(cds.root, task.src)}] does not exist`)
        }
        resolvedTask.dest = path.resolve(cds.root, cds.env.build.target, task.dest || task.src)
        resolvedTask.options = task.options || {}
        return resolvedTask
    }

    _getProvider(key) {
        const provider = this.providers.find(provider => {
            try {
                return provider.providesTask(key)
            } catch (e) {
                console.error(`Build task provider ${provider.constructor.name} returned an error:\n` + e)
                throw e
            }
        })
        if (!provider) {
            throw new BuildError(`No provider found for build task '${key.for || key.use}'. Ensure that all required dependencies have been added and 'npm install' has been executed.`)
        }
        return provider
    }

    async _lookupTasks(provider, tasks, dependencies) {
        return provider.lookupTasks(tasks, dependencies)
    }

    async _applyTaskDefaults(provider, tasks) {
        return Promise.all(tasks.map(task => provider.applyTaskDefaults(task)))
    }

    _loadProviders() {
        // DefaultBuildTaskProvider must be last entry
        return [
            new InternalBuildTaskProvider(),
            new PluginBuildTaskProvider(),
            new DefaultBuildTaskProvider()
        ]
    }
}

/**
 * Default provider implementation handling fully qualified custom build task declarations.
 * Has to be the last entry in the providers list.
 */
class DefaultBuildTaskProvider extends BuildTaskProvider {
    constructor() {
        super()
    }

    providesTask(key) {
        return !!key.use
    }

    getPlugin(task) {
        try {
            return require(require.resolve(task.use, { paths: [cds.root] }))
        } catch (e) {
            throw new Error(`Build task could not be resolved - module [${task.use}] cannot be loaded:\n` + e)
        }
    }
}

/**
 * Default provider implementation handling fully qualified custom build task declarations.
 */
class PluginBuildTaskProvider extends BuildTaskProvider {
    constructor() {
        super()
        this._plugins = require('./plugins').plugins
    }

    get plugins() {
        return this._plugins
    }

    providesTask(key) {
        return this.plugins.has(key.for)
    }

    getPlugin(task) {
        return this.plugins.get(task.for)
    }

    async lookupTasks(tasks, dependencies) {
        if (!dependencies) {
            for (const [id, plugin] of this.plugins) {
                if (plugin.hasTask()) {
                    tasks.push(this.getTask({ for: id }))
                }
            }
        }
    }

    async applyTaskDefaults(task) {
        const defaultTask = this.getTask(task)
        const names = Object.getOwnPropertyNames(defaultTask)
        names.forEach(name => {
            task[name] ??= defaultTask[name]
        })
    }

    getTask(key) {
        const task = this.plugins.get(key.for).taskDefaults ?? {}
        task.for = key.for
        task.src ??= DEFAULT_SRC_FOLDER
        task.src = task.src.replace(/\/$/, '')
        return task
    }
}
module.exports = BuildTaskProviderFactory
