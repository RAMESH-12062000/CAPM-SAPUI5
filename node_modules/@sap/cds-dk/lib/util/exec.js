const { spawn, spawnSync } = require('child_process');

const cds = require('../cds');
const log = cds.log('exec');
const DEBUG = cds.debug('exec');

function* commandIterator(strs, args) {
    for (let i=0; i<strs.length; i++) {
        const str = strs[i];
        const regex = /((\s+)|(["'])|$)/g;
        let match;
        let lastIndex = 0;
        do {
            match = regex.exec(str);
            if (match.index > lastIndex) {
                yield { type: 'WORD', value: str.substr(lastIndex, match.index - lastIndex) };
            }
            if (match[2]) {
                yield { type: 'SPACE', value: match[2] };
            }
            if (match[3]) {
                yield { type: 'QUOTE', value: match[3] }
            }
            lastIndex = match.index + match[0].length;
        } while (lastIndex < str.length);

        if (args[i]) {
            if (Array.isArray(args[i])) {
                let sep = false;
                for (const value of args[i]) {
                    if (sep) yield { type: 'SPACE', value: ' '};
                    yield { type: 'WORD', value };
                    sep = true;
                }
            } else {
                yield { type: 'WORD', value: args[i] };
            }
        }
    }
}

function processTemplate(strs, ...args) {
    let quote;
    const result = [];
    let index = 0;

    const append = str => result[index] = (result[index] || '') + str;
    const push = () => { if (index < result.length) index++; };

    for (const token of commandIterator(strs, args)) {
        switch (token.type) {
            case 'WORD':
                append(token.value);
                break;
            case 'SPACE':
                if (quote) {
                    append(token.value);
                } else {
                    push();
                }
                break;
            case 'QUOTE':
                if (quote === token.value) {
                    quote = undefined;
                } else if (quote) {
                    append(token.value);
                } else {
                    quote = token.value;
                }
                break;
        }
    }

    return result;
}

function fetchOptions(cmd) {
    const { options, args } = cmd;
    if (typeof args[0] === 'object' && !Array.isArray(args[0])) {
        const newOptions = args[0];
        cmd.options      = {...options, ...newOptions};
        cmd.args         = args.slice(1);
        return true;
    } else {
        return false;
    }
}

function exec_func(...args) {
    const cmd = { options: {
            log,
            acceptStatuses: [ 0 ],
            stdio: 'inherit',
            shell: false,
            encoding: 'utf-8'
        }, args };

    let hasOptions = false;
    while (fetchOptions(cmd)) hasOptions = true;
    if (hasOptions && cmd.args.length === 0) {
        return (...args) => exec_func(cmd.options, ...args);
    }

    if (Array.isArray(cmd.args[0])) cmd.args = processTemplate(...cmd.args);
    return cmd.options.executer(cmd.options, ...cmd.args);
}

function getExecOptions(options) {
    const execOptions = {...options};
    [ 'acceptStatuses', 'appendEnv', 'exec', 'log', 'result' ].forEach( name => delete execOptions[name] );

    const { appendEnv, result } = options;
    if (appendEnv) {
        execOptions.env = {...(options.env || process.env),...appendEnv};
    }

    switch (result) {
        case 'stdout':
            execOptions.stdio = [ 'inherit', 'pipe', 'inherit' ];
            break;
        case 'stderr':
            execOptions.stdio = [ 'inherit', 'inherit', 'pipe' ];
            break;
        case undefined:
            break;

        default:
            throw new Error `Unexpected "result" option: "${result}"`;
    }

    return execOptions;
}

function toString(a) {
    return typeof a === 'string' ? a : Buffer.from(a).toString('utf-8');
}

function processResult(result, options) {
    switch (options.result) {
        case 'stdout':
            return toString(result.stdout);
        case 'stderr':
            return toString(result.stderr);
        case undefined:
            return result;

        default:
            throw new Error(`Unexpected "result" option: "${result}"`);
    }
}


function executeSync(options = {}, command, ...args) {
    const { acceptStatuses } = options;
    const execOptions = getExecOptions(options);

    DEBUG?.(`exec: ${command} ${args.map( v => v.match(/\s/) ? `"${v}"` : v ).join(' ')}`);
    const result = spawnSync(command, args, execOptions);

    if (acceptStatuses !== '*' && acceptStatuses.indexOf(result.status) === -1) throw new Error(`Command '${command} ${args.join(' ')}' returned with status code ${result.status}`);
    return processResult(result, options);
}

async function executeAsync(options = {}, command, ...args) {
    const { acceptStatuses } = options;
    const execOptions = getExecOptions(options);

//    ctx.log(`exec: ${command} ${args.map( v => v.match(/\s/) ? `"${v}"` : v ).join(' ')}`);


    const result = await new Promise( (resolve, reject) => {
        const child = spawn(command, args, execOptions);
        const stdoutChunks = [];
        const stderrChunks = [];

        if (child.stdout) {
            child.stdout.on('data', data => {
                stdoutChunks.push(Buffer.from(data));
            });
        }

        if (child.stderr) {
            child.stderr.on('data', data => {
                stderrChunks.push(Buffer.from(data));
            });
        }

        const exit = status => {
            if (acceptStatuses !== '*' && acceptStatuses.indexOf(status) === -1) reject(new Error(`Command '${command} ${args.join(' ')}' returned with status code ${status}`))
            else resolve({
                status,
                stdout: child.stdout ? Buffer.concat(stdoutChunks).toString("utf-8") : undefined,
                stderr: child.stderr ? Buffer.concat(stderrChunks).toString("utf-8") : undefined
            })
        };

        child.on('close', exit);
        child.on('exit', exit);
    });

    return processResult(result, options);
}

const exec = exec_func({ executer: executeAsync });
const execSync = exec_func({ executer: executeSync });

module.exports = {
    exec,
    execSync,
    $ : execSync
}
