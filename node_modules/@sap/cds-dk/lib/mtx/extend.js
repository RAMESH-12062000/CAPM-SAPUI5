const fs = require('fs');
const path = require('path');
const axios = require('axios');

const AuthManager = require('./auth_manager');

require('../util/axios').pruneErrors();
const { normalizePath, isParent } = require('./util/fs');
const Question = require('./util/question');
const { getMessage } = require('./util/logging');
const { handleHttpError } = require('./util/errors');
const { checkProject, getMtxApiUrl } = require('./util/legacy_ext');

const COMMAND_URL_SUFFIX = 'content';
const CUSTOM_FILE_URL_SUFFIX = 'customTenantContent';
const CUSTOM_FILE_FOLDERS = ['wsdl'];
const DB_FOLDER = 'db';
const SRV_FOLDER = 'srv';
const TEMPLATE_FOLDER = 'tpl';

function folderExists(folder) {
    return `${folder} already contains an extension project, use another directory or use --force.` +
        '\nWhen using --force, make sure you are using a version control system (like git) to avoid data loss';
}

module.exports = class Extend {

    static get COMMAND_URL_SUFFIX() { return COMMAND_URL_SUFFIX; }
    static get CUSTOM_FILE_URL_SUFFIX() { return CUSTOM_FILE_URL_SUFFIX; }

    static async storeFiles(content, targetDirectory, filter) {
        fs.mkdirSync(targetDirectory, { recursive: true });
        targetDirectory = fs.realpathSync(targetDirectory)
        const writtenFiles = new Set();
        const filesToWrite = new Map();
        for (const [filename, filecontent] of content) {
            const filepath = path.join(targetDirectory, filename);
            if (filepath.startsWith(targetDirectory) && (!filter || await filter(filepath))) {
                filesToWrite.set(filepath, filecontent);
            }
        }
        for (const [filepath, content] of [...filesToWrite.entries()]) {
            const normalizedFilepath = normalizePath(filepath);
            fs.mkdirSync(path.dirname(normalizedFilepath), { recursive: true });
            fs.writeFileSync(normalizedFilepath, content);
            writtenFiles.add(path.relative(process.cwd(), normalizedFilepath));
            Extend._logWrittenFile(normalizedFilepath);
        }
        return writtenFiles;
    }

    static async storeCustomFiles(directory, customFiles) {
        const customFileMap = new Map();
        customFiles.forEach(entry => {
            if (entry.category === 'wsdl') {
                const normalizedFilename = normalizePath(entry.name);
                const folder = normalizedFilename.split(path.sep)[0];
                if (CUSTOM_FILE_FOLDERS.includes(folder)) {
                    customFileMap.set(entry.name, entry.content);
                }
            }
        });
        await Extend.storeFiles([...customFileMap], directory);
    }

    static async storeTemplateFiles(templates, directory) {
        await Extend.storeFiles(templates, directory, async filepath => {
            const normalizedPath = normalizePath(filepath);
            if (!isParent(path.join(directory, DB_FOLDER), normalizedPath) && !isParent(path.join(directory, SRV_FOLDER), normalizedPath)) {
                console.log('Ignoring template', normalizedPath, ': not in', DB_FOLDER, 'or', SRV_FOLDER);
                return false;
            }
            return true;
        });
    }

    static async run(paramValues) {
        const params = await AuthManager.login(paramValues);

        if (process.env.DEBUG) {
            console.log('\n\nCreating extension project with parameters', JSON.stringify({
                appUrl: params.get('appUrl'),
                projectFolder: params.get('projectFolder'),
                subdomain: params.get('subdomain'),
                passcode: params.get('passcode'),
                username: params.get('username'),
                password: params.get('password') ? '***' : 'undefined'
            }));
        } else {
            console.log('\n\nCreating extension project for', params.get('appUrl'), 'subdomain', params.get('subdomain'), 'in folder', params.get('projectFolder'));
        }

        const runOnExistingProject = await checkProject(params.get('projectFolder'));
        if (runOnExistingProject && !(params.get('force') || params.get('templates'))) {
            throw getMessage(folderExists(params.get('projectFolder')), { command: 'extend' });
        }

        try {
            await Extend.runExtend(params);
        } catch (error) {
            await handleHttpError(error, params, { command: 'extend' });
        }
    }

    static async runExtend(params) {
        const contentUrl = getMtxApiUrl(params.get('appUrl'), COMMAND_URL_SUFFIX);
        const requestOptions = Object.assign({ retry: 0 }, params.get('reqAuth'));

        console.log('Retrieving files...');

        const [ response ] = (await axios.get(contentUrl, requestOptions)).data;

        console.log('\nWriting files to', params.get('projectFolder'));

        if (params.get('templates')) {
            await Extend.storeTemplateFilesToTpl(response.templates, params.get('projectFolder'));
            return; // only write templates
        }

        const content = response.base.concat(response.extension);

        await Extend.storeFiles(content, params.get('projectFolder'));

        await fs.promises.mkdir(path.join(params.get('projectFolder'), DB_FOLDER), { recursive: true });
        await fs.promises.mkdir(path.join(params.get('projectFolder'), SRV_FOLDER), { recursive: true });

        console.log('\nPut database extension models into', DB_FOLDER, 'folder.');
        console.log('Put service extension models into', SRV_FOLDER, 'folder.');

        if (response.templates && response.templates.length > 0) {
            // only write templates if there are no extensions so far
            if (response.extension && response.extension.length === 0) {
                console.log('Writing template files to', DB_FOLDER, 'and', SRV_FOLDER, 'folder');
                await Extend.storeTemplateFiles(response.templates, params.get('projectFolder'));
            } else {
                console.log('Ignoring templates because extension is already active.');
            }
        }

        if (params.get('wsdl')) {
            console.log('Writing custom files');
            const customFileUrl = getMtxApiUrl(params.get('appUrl'), CUSTOM_FILE_URL_SUFFIX);
            const customFiles = (await axios.get(customFileUrl, requestOptions)).data;
            await Extend.storeCustomFiles(params.get('projectFolder'), customFiles);
        }
    }

    static async storeTemplateFilesToTpl(templates, projectFolder) {
        if (templates && templates.length > 0) {
            const targetDirectory = path.join(projectFolder, TEMPLATE_FOLDER);
            const targetExists = fs.existsSync(targetDirectory);
            if (!targetExists || await this.promptTemplateOverwrite()) {
                if (targetExists) {
                    await fs.promises.rm(targetDirectory, { force: true, recursive: true });
                }
                console.log('Writing template files to', TEMPLATE_FOLDER, 'folder');
                await Extend.storeTemplateFiles(templates, targetDirectory);
            }

        } else {
            console.log('No templates available');
        }
    }

    static promptTemplateOverwrite() {
        return Question.askBooleanQuestion(`This  will overwrite existing templates in folder ${TEMPLATE_FOLDER}. Continue (yN)? `);
    }

    static _logWrittenFile(file) {
        console.log('CREATE:', file);
    }

}
