const fs = require('fs');
const path = require('path');

async function collectFileContent(filePaths, root) {
    const resultMap = new Map();
    return Promise.all(
        filePaths.map(filePath => fs.promises.readFile(filePath)
                .then(content => resultMap.set(toUnixPath(path.relative(root, filePath)), content.toString('utf-8'))))
    ).then(() => resultMap);
}

/**
 * Returns map of files with content for a given directory
 * @param root  Root directory
 * @param sourceDir Directory to start the traversal
 * @param filter Filter function
 * @returns {Promise.<Map>}
 */
function collectFiles(root, sourceDir, filter) {
    const files = new Map();
    _traverseFileSystem(root, sourceDir, files, filter);

    return files;
}

function _traverseFileSystem(root, sourceDir, files, filter) {
    let absoluteDir = path.resolve(root, sourceDir);
    if (!fs.existsSync(absoluteDir)) {
        return;
    }
    try {
        absoluteDir = fs.realpathSync(absoluteDir);
        fs.readdirSync(absoluteDir)
            .map(subDirEntry => path.join(absoluteDir, subDirEntry))
            .forEach(entry => {
                const stats = fs.statSync(entry)
                if (stats.isDirectory()) {
                    _traverseFileSystem(root, entry, files, filter);
                }
                if (stats.isFile() && (!filter || filter.call(this, entry))) {
                    const fileContent = fs.readFileSync(entry);
                    files.set(toUnixPath(path.relative(root, entry)), fileContent.toString('utf-8'));
                }
            });
    } catch(error) { /* ignored */}
}

/**
 * Converts Windows paths by using unix separators
 * @param aPath a path
 * @returns {string}
 */
function toUnixPath(aPath) {
    return aPath.replace(/\\/g, '/');
}

/**
 * Normalizes filename to os specific format (but does not check for existence)
 * @param {string} filename
 */
function normalizePath(filename) {
    return path.normalize(filename);
}

/**
 * Returns whether a given path is a parent of another path.
 * @param maybeParent a potential parent path
 * @param maybeChild a potential child path
 * @returns {boolean} whether `maybeParent` is a parent path of `maybeChild`
 */
function isParent(maybeParent, maybeChild) {
    return ! path.relative(maybeParent, maybeChild).startsWith('..');
}


module.exports = {
    collectFileContent,
    collectFiles,
    toUnixPath,
    normalizePath,
    isParent
};
