const axios = require('axios');

const cds = require('../cds');
const { SettingsManager } = require('./settings_manager');
const { ParamCollection } = require('./params');
const { getMessage } = require('./util/logging');

require('../util/axios').pruneErrors();

const DEBUG = cds.debug('cli');
const REASONS = { invalid_scope: /\binvalid_scope\b/ };

function assign(params, authData) {
    if (authData?.access_token) {
        params.set('token', authData.access_token);
        if (authData.expires_in) {
            params.set('tokenExpirationDate', Date.now() + authData.expires_in * 1000);
        } else {
            params.delete('tokenExpirationDate');
        }
        if (authData.refresh_token) {
            params.set('refreshToken', authData.refresh_token);
        } else {
            params.delete('refreshToken');
        }
    }
    if (authData?.passcode_url) {
        params.set('passcodeUrl', authData.passcode_url);
    }
}
function reqParams(method, params) {
    const url = params.get('tokenUrl');
    const d = {};
    if (params.has('subdomain')) {
        d.subdomain = params.get('subdomain');
    }
    if (params.has('refreshToken')) {
        d.refresh_token = params.get('refreshToken');
    } else if (params.has('passcode')) {
        d.passcode = params.get('passcode');
    }
    if (params.has('clientsecret')) {
        d.clientid = params.get('clientid');
        d.clientsecret = params.get('clientsecret');
    } else if (params.has('key')) {
        d.clientid = params.get('clientid');
        d.key = params.get('key');
    }
    const data = new URLSearchParams(d).toString();
    return method === 'post'
        ? { url, data }
        : { url: `${url}?${data}`, data: undefined };
}

async function retrieveTokenOrPasscodeUrl(params) {
    if (params.has('token') || !params.has('refreshToken') && !params.has('passcode') && params.has('passcodeUrl')) {
        return;
    }

    let response, error;
    reqParams: for (const method of ['post', 'get']) {
        do {
            const { url, data } = reqParams(method, params);
            try {
                DEBUG?.(`Getting authentication token or passcode URL from ${method.toUpperCase()} ${params.obfuscateQueryParams(url)}`);
                response = await axios[method](url, data);
            } catch (e) {
                error = e;
                if (error.status === 404) { // may represent 405 in case of wrong method
                    continue reqParams;
                } else if (params.has('refreshToken')) {
                    DEBUG?.('Discarding invalid refresh token');
                    params.delete('refreshToken');
                } else {
                    break reqParams;
                }
            }
        } while (!(response || error));
    }
    const data = response?.data ?? error?.auth;
    assign(params, data);
    if (!response) {
        throw new Error(REASONS.invalid_scope.test(error.message)
            ? 'Token has invalid scope. Check if your user has the required roles'
            : `No valid passcode or token provided. Get a passcode${
                params.get('passcodeUrl') ? ' from ' + params.get('passcodeUrl') : ''
            } and re-run the command with '-p <passcode>'`);
    }
}

module.exports = class AuthManager {

    static async login(paramValues) {
        SettingsManager.init();
        const params = new ParamCollection(paramValues);
        await SettingsManager.loadAndMergeSettings(params);
        if (params.has('username')) {
            params.set('reqAuth', { auth: { username: params.get('username'), password: params.get('password') } });
        } else if (!params.get('skipToken')) {
            try {
                await retrieveTokenOrPasscodeUrl(params);
            } catch (error) {
                if (params.get('saveData')) {
                    await SettingsManager.saveSettings(params);
                }
                throw getMessage('Failed to login', { error });
            }
            params.set('reqAuth', { headers: { Authorization: 'Bearer ' + params.get('token') } });
        }

        if (params.get('saveData')) {
            await SettingsManager.saveSettings(params); // saves token conditionally
        }

        return params;
    }

    static async logout(paramValues) {
        SettingsManager.init();
        const params = new ParamCollection(paramValues);
        await SettingsManager.setKeytar(params, true);
        if (params.get('clearInvalid')) {
            await SettingsManager.deleteInvalidSettings();
            await SettingsManager.deleteInvalidTokens();
        } else {
            await SettingsManager.deleteToken(params);
            if (params.get('deleteSettings')) {
                await SettingsManager.deleteSettingsWithoutToken(params);
            }
        }
    }

}
