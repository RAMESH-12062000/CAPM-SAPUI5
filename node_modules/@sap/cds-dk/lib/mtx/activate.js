const fs = require('fs').promises;
const path = require('path');
const axios = require('axios');

const cds = require('../cds');
const AuthManager = require('./auth_manager');

require('../util/axios').pruneErrors();
const { collectFileContent, collectFiles, toUnixPath } = require('./util/fs');
const { getMessage } = require('./util/logging');
const { handleHttpError } = require('./util/errors');
const { concatUrls } = require('./util/urls');
const { checkProject, getMtxApiUrl } = require('./util/legacy_ext');

const DEBUG = cds.debug('cli');

const COMMAND_URL_SUFFIX = 'asyncActivate';
const COMMAND_URL_SUFFIX_SYNC = 'activate';
const UPDATE_CUSTOM_FILE_URL_SUFFIX = 'updateCustomTenantContent';

const I18N_WHITELIST = ['.properties', '.csv'];

const JOB_STATUS = {
    QUEUED: 'QUEUED',
    RUNNING: 'RUNNING',
    FINISHED: 'FINISHED',
    FAILED: 'FAILED'
};

async function checkFinished(jobId, statusUrl, params, finisher) {
    const { status, error } = (await axios.get(statusUrl, params.get('reqAuth'))).data;

    if ((status === JOB_STATUS.FINISHED || status === JOB_STATUS.FAILED) && !finisher.finished) {
        finisher.finished = true;
        clearInterval(finisher.timer);
        if (status === JOB_STATUS.FAILED) {
            return finisher.reject(getMessage(`Job ${jobId} failed`, { error }));
        }
        console.log('Extension active');
        finisher.resolve();
    }
}

module.exports = class Activate {

    static get COMMAND_URL_SUFFIX() { return COMMAND_URL_SUFFIX; }
    static get COMMAND_URL_SUFFIX_SYNC() { return COMMAND_URL_SUFFIX_SYNC; }
    static get UPDATE_CUSTOM_FILE_URL_SUFFIX() { return UPDATE_CUSTOM_FILE_URL_SUFFIX; }

    static async run(injection, paramValues) {
        const params = await AuthManager.login(paramValues);

        if (process.env.DEBUG) {
            console.log('Activating extension with parameters', JSON.stringify({
                appUrl: params.get('appUrl'),
                projectFolder: params.get('projectFolder'),
                undeploy: params.get('undeploy'),
                sync: params.get('sync')
            }));
        } else {
            console.log('Activating extension located at', params.get('projectFolder'), 'to URL', params.get('appUrl'));
        }

        if (!await checkProject(params.get('projectFolder'))) {
            throw params.get('projectFolder') + ' is not a valid extension project';
        }

        try {
            await this.runActivate(injection.cds, params);
            if (params.get('wsdl')) {
                await this.runCustomFileUpload(params);
            }
        } catch (error) {
            handleHttpError(error, params, { command: 'activate' });
        }
    }

    static async collectExtensionFiles(cds, projectFolder) {

        const absoluteFolder = projectFolder;
        const dbFolder = path.join(absoluteFolder, 'db');
        const srvFolder = path.join(absoluteFolder, 'srv');

        const resolvedPathDb = cds.resolve(dbFolder, { root: dbFolder });
        const resolvedPathSrv = cds.resolve(srvFolder, { root: srvFolder });

        let resolvedPaths = [];
        if (resolvedPathSrv) {
            resolvedPaths = resolvedPaths.concat(resolvedPathSrv);
        }

        if (resolvedPathDb) {
            resolvedPaths = resolvedPaths.concat(resolvedPathDb);
        }

        let allFiles = new Map();

        if (resolvedPaths.length < 1) {
            console.warn('No extension files found');
            return allFiles;
        }

        const csn = await cds.load(resolvedPaths);
        const sources = csn.$sources || csn._sources;

        const filteredSources = sources && sources.filter((entry) => {
            if (! entry.startsWith(projectFolder)) {
                /* Current file might be below the base model's node_modules, in which case compilation on server should succeed.
                   Otherwise, compilation will probably fail, with this message giving a hint. */
                DEBUG?.(`Source file outside project folder will not be uploaded: ${entry}`);
                return false;
            }
            const unixFilename = toUnixPath(entry);
            return !/.*node_modules\/_base\/.*/.test(unixFilename);
        }) || [];

        const sourceFiles = await collectFileContent(filteredSources, projectFolder);
        allFiles = new Map([...allFiles, ...sourceFiles]);

        const modelFiles4I18n = { $sources: filteredSources };

        let i18nFolders = cds.localize.folders4(modelFiles4I18n);
        i18nFolders = i18nFolders.filter(i18nFolder => {
            const unixFilename = toUnixPath(i18nFolder);
            return !(/.*node_modules\/_base\/.*/.test(unixFilename));
        });

        i18nFolders.forEach(folder => {
            const i18nFiles = collectFiles(projectFolder, folder, entry => {
                const ext = path.extname(entry);
                return I18N_WHITELIST.includes(ext);
            });
            allFiles = new Map([...allFiles, ...i18nFiles]);
        });

        let pkgJson;
        try {
            pkgJson = await fs.readFile(path.join(absoluteFolder, 'package.json'), 'utf-8');
        } catch (error) {
            throw getMessage('No package.json file found', { error });
        }
        allFiles.set('package.json', pkgJson);

        return allFiles;
    }

    static collectCustomFiles(projectFolder) {
        const wsdlFolder = path.join(projectFolder, 'wsdl');

        const wsdlFiles = collectFiles(projectFolder, wsdlFolder);
        if (wsdlFiles.size === 0) {
            console.log('No custom files found');
        }
        return wsdlFiles;
    }

    static async runActivate(cds, params) {
        let activationUrl;
        const isSync = params.get('sync');

        return this.collectExtensionFiles(cds, params.get('projectFolder'))
        .then(allFiles => {
            if (allFiles.size === 0) {
                return null;
            }

            console.log('Activating extension...');

            const urlSuffix = isSync ? this.COMMAND_URL_SUFFIX_SYNC : this.COMMAND_URL_SUFFIX;
            activationUrl = getMtxApiUrl(params.get('appUrl'), urlSuffix);
            const requestOptions = Object.assign({
                headers: {}
            }, params.get('reqAuth'));
            requestOptions.headers['Content-Type'] = 'application/json';

            return axios.post(activationUrl, {
                extension: [...allFiles],
                undeployExtension: params.get('undeploy')
            }, requestOptions);
        })
        .then(response => {
            if (isSync || response === null) {
                return;
            }

            const { jobID: jobId, statusPath } = response.data;

            if (jobId === undefined) {
                throw 'Activation failed: did not receive job ID';
            }

            if (!statusPath) {
                throw `Job ${jobId} failed: did not receive job-status path`;
            }

            DEBUG?.(`Job ID: ${jobId}`);

            return new Promise((resolve, reject) => {
                const statusUrl = concatUrls(params.get('appUrl'), statusPath);
                const finisher = {
                    resolve,
                    reject,
                    finished: false,
                    timer: null
                };
                finisher.timer = setInterval(checkFinished.bind(undefined, jobId, statusUrl, params, finisher), 250);
            });
        });
    }

    static async runCustomFileUpload(params) {
        console.log('Uploading custom files to', params.get('appUrl'), '...');

        const customFiles = this.collectCustomFiles(params.get('projectFolder'));

        const customFilesSerialized = [];
        customFiles.forEach((value, key) => {
            customFilesSerialized.push({
                category: "wsdl",
                name: key,
                content: value
            });
        });

        const customFileUrl = getMtxApiUrl(params.get('appUrl'), this.UPDATE_CUSTOM_FILE_URL_SUFFIX);
        const requestOptions = Object.assign({
            headers: {},
        }, params.get('reqAuth'));
        requestOptions.headers['Content-Type'] = 'application/json';

        await axios.post(customFileUrl, {
            content: customFilesSerialized
        }, requestOptions);

        console.log('Custom file upload finished');
    }

}
