const cds = require ('../cds')
const { local, tar } = cds.utils;

const fs = require('fs');
const { join } = require('path');
const axios = require('axios');

const { login } = require('./auth_manager');

require('../util/axios').pruneErrors();
const { getMessage } = require('./util/logging');
const { handleHttpError } = require('./util/errors');

module.exports = class Pull {

    static async run(paramValues) {
        if (!tar) {
            throw `cds pull requires @sap/cds version >= 6.2. Current version is ${cds.version}\n`;
        }

        const params = await login(paramValues);
        const url = params.get('appUrl')
        const projectFolder = params.get('projectFolder');
        const env = cds.env.for('cds', projectFolder);
        const target = join(projectFolder, 'node_modules', this.getAppPackageName(env));
        const subdomain = params.get('subdomain') // REVISIT: Why are subdomains not transparently encoded in URLs?

        this.amendPackageJson(projectFolder, env);

        console.log(`Pulling app base model`, Object.assign({ from: url, to: local(target) }, subdomain && {subdomain}))

        fs.rmSync(target, { force: true, recursive: true });
        fs.mkdirSync(target, { recursive: true });

        const baseModelTgz = await this.getTgz(params);
        await tar.xz(baseModelTgz).to(target);

        console.log(`Finished. Refer to the base model like so:   using from '${this.getAppPackageName(env)}'`);
    }

    static getAppPackageName(env) {
        return env.extends || '_base';
    }

    static async getTgz(params) {
        const pullUrl = `${(params.get('appUrl'))}/-/cds/extensibility/pull`;
        const options = { ...params.get('reqAuth'), responseType: 'arraybuffer' };

        return axios.post(pullUrl, {}, options)
            .then(response => Buffer.from(response.data))
            .catch(error => handleHttpError(error, params, { url: pullUrl }));
    }

    static getPackageJsonIndentation(packageContents) {
        return /^ +/m.exec(packageContents)?.[0].length ?? 2;
    }

    static formatPackageJson(newObj, oldContents) {
        return JSON.stringify(newObj, undefined, this.getPackageJsonIndentation(oldContents));
    }

    static amendPackageJson(projectFolder, env) {
        if ('extends' in env) {
            return;
        }
        console.log(`Amending extension package.json with project configuration`);
        const packageJson = join(projectFolder, 'package.json');
        let packageContents;
        try {
            packageContents = JSON.parse(fs.readFileSync(packageJson, { encoding: 'utf-8' }));
        } catch (error) {
            throw getMessage('package.json missing or unreadable', { error });
        }
        fs.writeFileSync(packageJson, this.formatPackageJson({
            ...packageContents,
            cds: {
                ...(packageContents.cds ?? {}),
                extends: this.getAppPackageName(projectFolder) // Default unless configured through current process.env
            }
        }));
    }
}
