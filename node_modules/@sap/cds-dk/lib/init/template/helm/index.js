const { join } = require('path');
const cds = require('../../../cds')
const { exists, rimraf, copy } = cds.utils
const { readProject } = require('../../projectReader');
const { merge } = require('../../merge')

module.exports = class HelmTemplate extends require('../../plugin') {

    async canRun() {
        if (cds.cli.options.force) {
            await rimraf(join('chart'))
            return true
        }
        return true
    }

    // Won't need this any more with plugin approach: package not there -> plugin not pulled
    static hasInProduction() {
        const { add } = cds.cli.options
        return exists(join('chart', 'charts', 'web-application')) && exists(join('chart', 'values.yaml') || add.has('helm'))
    }

    async run() {
        const project = readProject()
        await copy(join(__dirname, 'files', 'chart')).to('chart')
        await merge(__dirname, 'files/Chart.yaml.hbs').into('chart/Chart.yaml', { with: project })
        await merge(__dirname, 'files/values.yaml.hbs').into('chart/values.yaml', { with: project })
        await this._mergeDependency('web-application', 'srv')

        await copy(join(__dirname, 'files', 'web-application')).to('chart/charts/web-application')
    }

    async combine() {
        const { hasDestination, hasEnterpriseMessaging, hasHana, hasMultitenancy, hasXsuaa, hasHtml5Repo, hasApprouter, hasKafka } = readProject()
        let hasContentDeployment = false

        if (!exists('chart/charts/service-instance') && (hasHtml5Repo || hasMultitenancy || hasDestination || hasEnterpriseMessaging || hasXsuaa || hasHana || hasKafka)) {
            await copy(join(__dirname, 'files', 'service-instance')).to('chart/charts/service-instance')
        }
        if (hasApprouter) {
            await this._mergeDependency('web-application', 'approuter')
        }

        if (hasHtml5Repo) {
            hasContentDeployment = true
            await this._mergeDependency('service-instance', 'html5-apps-repo-host')
            await this._mergeDependency('content-deployment', 'html5-apps-deployer')
            if (hasApprouter) {
                await this._mergeDependency('service-instance', 'html5-apps-repo-runtime')
            }
        }
        if (hasMultitenancy) {
            await this._mergeDependency('web-application', 'sidecar')
            await this._mergeDependency('service-instance', 'saas-registry')
        }
        if (hasDestination) {
            await this._mergeDependency('service-instance', 'destination')
        }
        if (hasEnterpriseMessaging) {
            await this._mergeDependency('service-instance', 'event-mesh')
        }
        if (hasXsuaa) {
            await this._mergeDependency('service-instance', 'xsuaa')
        }
        if (hasHana) {
            if (hasMultitenancy) {
                await this._mergeDependency('service-instance', 'service-manager')
            } else {
                hasContentDeployment = true
                await this._mergeDependency('service-instance', 'hana')
                await this._mergeDependency('content-deployment', 'hana-deployer')
            }
        }
        if (hasKafka) {
            await this._mergeDependency('service-instance', 'kafka')
        }
        if(!exists('chart/charts/content-deployment') && hasContentDeployment) {
            await copy(join(__dirname, 'files', 'content-deployment')).to('chart/charts/content-deployment')
        }
    }

    async _mergeDependency(name, alias) {
        const project = readProject()
        await merge({
            dependencies: [{
                name,
                alias,
                version: '>0.0.0'
            }]
        }).into('chart/Chart.yaml', {
            project,
            additions: [{
                in: 'dependencies',
                where: { alias }
            }]
        })
    }
}
