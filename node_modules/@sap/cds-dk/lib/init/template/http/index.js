const cds = require('../../../cds')
const cf = require("../../../util/cf")
const { write, exists } = cds.utils

module.exports = class HttpTemplate extends require('../../plugin') {

  #defaultHost = "http://localhost:4004"
  #defaultPathPrefix = "/odata/v4/"
  #defaultDirName = "*"
  #defaultOutputDir = "http"
  #defaultAuth = `Authorization: Basic yves:`

  options() {
    return {
      'filter': {
        type: 'string',
        short: 'f',
        help: `Specify the path to the service definition file or directory. Default is ${this.#defaultDirName}.`
      },
      'for-app': {
        type: 'string',
        short: 'a',
        help: 'Specify the name of the app to generate requests for. If not specified, localhost and default auth will be used.'
      },
      'out': {
        type: 'string',
        short: 'o',
        help: 'The output directory. By default, an `http` dir will be created in one of the following: test/tests/__tests__, whichever already exists. If none exists, an `http` dir will be created at the root level.'
      }
    }
  }

  async run() {

    const path = cds.cli.options['filter'] || this.#defaultDirName
    const csn = await cds.load(path)
    cds.linked(csn)

    let [hostname, auth] = await this.#getHostnameAndAuth()

    let endpoints = this.#collectEndpointInfo(csn)

    this.#generateRequests(endpoints, hostname, auth)
  }

  async #getHostnameAndAuth() {
    if (!cds.cli.options['for-app']) {
      return [this.#defaultHost, this.#defaultAuth]
    }

    const env = await cf.getEnv(cds.cli.options['for-app'])
    const hostname = `https://${env.application_env_json.VCAP_APPLICATION.application_uris[0]}`
    const { url, clientid, clientsecret } = env.system_env_json.VCAP_SERVICES?.xsuaa[0]?.credentials || {}

    const response = await fetch(`${url}/oauth/token?${new URLSearchParams({
      grant_type: 'client_credentials',
      response_type: 'token',
    })}`, {
      method: 'GET',
      headers: {
        'Authorization': `Basic ${Buffer.from(`${clientid}:${clientsecret}`).toString('base64')}`
      }
    })
    if (response.ok) {
      const { access_token } = await response.json()
      const auth = `x-approuter-authorization: bearer ` + access_token
      return [hostname, auth]
    } else {
      throw new Error('Error authenticating ', { url, response })
    }
  }

  #collectEndpointInfo(csn) {
    const mapping = {}

    csn.services.map((s) => {
      const protocols = this.#getProtocols(s)
      const paths = this.#getPaths(s, protocols)

      let entityInfo = []
      const entities = csn.entities(s.name)
      for (const e in entities) {
        if (entities[e].name.endsWith('.texts')) {
          continue
        }
        entityInfo.push(this.#addNameAndReadOnly(entities[e]))
      }

      mapping[s.name] = { entities: entityInfo, paths: paths, protocols: protocols, actions: [] }
    })

    csn.foreach('action', (a) => {
      mapping[a.name.split(".")[0]].actions.push(a)
    })

    return mapping
  }

  #getProtocols(s) {
    return s["@protocol"]
      ? typeof s["@protocol"] === "string"
        ? [s["@protocol"]]
        : s["@protocol"]
      : ["odata"]
  }

  #getPaths(s, protocols) {
    let paths = []
    if (s["@path"]) {
      paths.push(s["@path"])
    } else {
      const serviceName = s.name.replace("Service", "").toLowerCase()

      let prefix = ""
      if (protocols) {
        for (const p of protocols) {
          if (p === "odata-v2") {
            prefix = "/odata/v2/"
          } else if (p === "rest") {
            prefix = "/rest/"
          } else {
            prefix = this.#defaultPathPrefix
          }
          paths.push(prefix + serviceName)
        }
      }
    }
    return paths
  }

  #addNameAndReadOnly(e) {
    return {
      name: e.name.split(".")[1],
      readOnly: (e["@readonly"] || e["@cds.autoexpose"] || e['@odata.singleton']) ?? false,
    }
  }

  #generateRequests(mapping, hostname, auth) {
    for (const service in mapping) {
      let requests = []

      requests.push(`@server = ${hostname}\n@auth = ${auth}\n`)

      mapping[service].entities.forEach((e) => {
        for (const path of mapping[service].paths) {
          const url = `{{server}}${path}/${e.name}`
          const contentType = `Content-Type: application/json`
          const authHeader = `{{auth}}`

          requests.push(`GET ${url}\n${authHeader}\n${contentType}\n`)

          if (!e.readOnly) {
            const allHeaders = `${contentType}\n${authHeader}`
            requests.push(`POST ${url}\n${allHeaders}\n\n{}\n`)

            requests.push(`PATCH ${url}\n${allHeaders}\n\n{}\n`)
            requests.push(`DELETE ${url}\n${authHeader}\n`)
          }
        }
      })

      const outputPath = this.#determineOutputPath(service)
      write(requests.join("\n###\n")).to(outputPath)
      console.log(`${outputPath} has been created.`)
    }
  }

  #determineOutputPath(service) {
    let outputDir
    const { out } = cds.cli.options
    if (out) {
      outputDir = out.endsWith('/') ? out.slice(0, -1) : out
    } else if (exists('test') || exists('tests') || exists('__tests__')) {
      outputDir = exists('test') ? 'test/http' : (exists('tests') ? 'tests/http' : '__tests__/http')
    } else {
      outputDir = this.#defaultOutputDir
    }
    return `${outputDir}/${service}.http`
  }
}


