// const cds = require('../../../cds')

module.exports = async (data={}, csn, { headerOnly=false, queries=false, separator=',' }={}) => {
  if (!queries) { // remove all projection-like entities
    Object.keys(data)
      .map(name => csn.definitions[name])
      .filter (entity => entity.query)
      .forEach(entity => { delete data[entity.name] })
  }

  // We might need multiple passes if data for associations/compositions is created on the fly.
  // So loop as long as there is some non-string data left.
  while (Object.values(data).some(d => typeof d === 'object')) {
    Object.entries(data)
    .filter(([_, value]) => typeof value === 'object')
    .map(([name]) => csn.definitions[name])
    .forEach(entity => {
      const entityData = data[entity.name]
      const header = []
      const records = []
      for (let i = 0; i < entityData.length; i++) {
        let record = []
        for (const element of Object.values(entity.elements).sort(keyFirstSorter)) {
          const name = element.name
          let value = entityData[i][name]
          if (value === undefined)
            continue
          if (element._type === 'cds.Composition') {
            data[element.target] = value // Add object for a new entity. Next pass will process it.
          }
          else if (element._type === 'cds.Association') {
            if (i === 0) {
              header.push(...Object.keys(value).map(foreignKey => name + '_' + foreignKey))
            }
            record.push(...Object.values(value))
          }
          else {
            if (i === 0)  header.push(name)
            if (typeof value === 'string' && (value.includes('"') || value.includes(separator)))
              value = `"${value.replace(/"/g, '""')}"` // escape double quotes, then quote the value
            record.push(value)
          }
        }
        records.push(record.join(separator))
      }
      let res = header.join(separator)
      if (!headerOnly)
        res += '\n' + records.join('\n')

      data[entity.name] = res
    })
  }
  return data
}

function keyFirstSorter(e1, e2) {
  if (e1.key && !e2.key) return -1
  if (!e1.key && e2.key) return 1
  return 0 // preserve original order otherwise
}