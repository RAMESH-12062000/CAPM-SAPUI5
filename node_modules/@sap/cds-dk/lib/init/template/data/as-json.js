const { randomUUID } = require('node:crypto')
const { dirname } = require('node:path')
const cds = require('../../../cds')

let counter = Math.round(Math.random() * 10000) // Default random seed // Non-deterministic behaviour
const MAX_ASSOC_DEPTH = 1

module.exports = async (data, csn, numRecords=1, existingData) => {
  // if no entity restrictions are given, use all entities
  if (!data)  data = csn.all('entity').reduce((all, e) => { all[e.name] = []; return all }, {})

  if (!existingData)
    existingData = await cds.deploy.resources(csn)

  addSemantics(csn)

  // sort all entities first that are referenced by others, so that dependant entities can be created after them
  const { definitions: defs } = csn
  const entityNames = Object.keys(data).sort((n1, n2) => {
    const n1HasComp = Object.values(defs[n1].elements).some(el => el.type === 'cds.Composition')
    const n2HasComp = Object.values(defs[n2].elements).some(el => el.type === 'cds.Composition')
    if (n1HasComp && !n2HasComp)  return -1
    if (!n1HasComp && n2HasComp)  return 1
    return 0
  })

  for (const name of entityNames) {
    if (!data[name] // removed on purpose because records are created inline through compositions
      || data[name].length >= numRecords) { // already created by following associations
      continue
    }

    const records = data[name] = Array(numRecords).fill({}).map(() => ({}))
    const entity = defs[name]

    const idNum = randomNumber()
    for (let i = 0; i < numRecords; i++) {
      fillRecord(records[i], idNum+i, entity, csn, data, null, 0, existingData)
    }
  }
  return data
}

function fillRecord(record, recordID, entity, csn, data, parentEntity, depth, existingData) {
  Object.defineProperty(record, '$id', {value: recordID, enumerable: false})

  const { elements } = entity

  // fill in the keys first, to have them ready for foreign key refs
  const keys = Object.keys(entity.keys||{})
  for (const key of keys) {
    record[key] = dataForField(elements[key], entity, csn, record, data, parentEntity, depth, existingData)
  }
  // non-key elements
  Object.keys(elements).filter(name => !keys.includes(name)).forEach(name => {
    record[name] = dataForField(elements[name], entity, csn, record, data, parentEntity, depth, existingData)
  })
  return record
}

function dataForField(element, entity, csn, record, data, parentEntity, depth, existingData) {
  if (element.virtual || element['@Core.Computed'])
    return
  switch (element._type) {
    case 'cds.Time':
      return '22:59:53'

    case 'cds.Timestamp': {
      const range = {from: new Date('2000-01-01'), to: new Date('2024-01-01')}
      return randomDateInRange(range).toISOString()
    }
    case 'cds.Date': {
      const range = {from: new Date('2000-01-01'), to: new Date('2024-01-01')}
      annotatedDateRange(element, range)
      const generatedDate = randomDateInRange(range)
      const date = generatedDate.toISOString().split('T', 1)[0]
      return date
    }

    case 'cds.DateTime': {
      const range = {from: new Date('2000-01-01'), to: new Date('2024-01-01')}
      annotatedDateRange(element, range)
      const generatedDate = randomDateInRange(range)
      return generatedDate.toISOString()
    }

    case 'cds.LargeString':
    case 'cds.String': {
      if (element['@data.gen']?.startsWith('faker.')) {
        return fakerValue(element['@data.gen'], csn)
      }
      if (element.enum) {
        const enums = Object.entries(element.enum).map(([name, val]) => val.value ?? name)
        return randomFromList(enums)
      }
      if (entity['@Communication.Contact.email']?.some(mail => mail.address?.['='] === element.name)
        || element['@Communication.IsEmailAddress']
        || element['@cds.on.insert']?.['='] === '$user'
        || element['@cds.on.update']?.['='] === '$user') {
        return randomEmailAddress(element.name, record['$id'], csn)
      }

      let str = `${element.name}-${record['$id']}`

      if (element.key) {
        str = `${entity.name.split('.').pop()}-${record['$id']}`
        if (element.name === 'locale' && entity.name.endsWith('texts')) {
          const record = randomFromExistingData(entity, csn, existingData)
          if (record)  return record.locale
          return randomLanguage()
        }
      }
      if (element['@assert.format']) {
        str = randomStrForRegex(element['@assert.format'], csn)
      }

      if (element.length && str.length > element.length) {
        str = str.slice(-element.length) // truncate to length
      }
      return str
    }

    case 'cds.UUID': {
      // create a pseudo-random UUID based on the record ID
      const idStr = '' + record['$id']
      return idStr + randomUUID().slice(idStr.length)
    }

    case 'cds.Boolean':
      return (record['$id'].toString(2).at(-1)) < 0.5

    case 'cds.Int16':
    case 'cds.Integer64':
    case 'cds.Integer': {
      if (element.key)
        return record['$id']
      if (element.enum) {
        const enums = Object.values(element.enum).map((value) => value.val)
        return parseInt(randomFromList(enums))
      }
      const range = {from: 0, to: 100}
      annotatedIntRange(element, range)
      return randomIntInRange(range)
    }
    case 'cds.Decimal': {
      const range = {from: 0, to: 100}
      annotatedIntRange(element, range)
      return +(randomDecimalInRange(range).toFixed(element.scale ?? 2))
    }
    case 'cds.Double': {
      const range = {from: 0, to: 100}
      return randomDecimalInRange(range)
    }
    case 'cds.Composition': {
      const target = csn.definitions[element.target]
      if (!target)
        return
      delete data[target.name] // as data for the target is created inline below, no need to have it separately
      if (target === parentEntity || depth > MAX_ASSOC_DEPTH)
        return

      const targetRecords = []
      const targetRecordCount = element.is2many ? 2 : 1 // TODO: make this configurable
      const targetRecordID = randomNumber()
      for (let i = 0; i < targetRecordCount; i++) {
        targetRecords.push(fillRecord({}, targetRecordID+i, target, csn, data, entity, depth+1, existingData))
      }

      const [ownKey, ownKeyStructured, targetKey] = findKeysInOnCondition(element, target)
      if (ownKey && targetKey) {
        const value = ownKeyStructured ? { [ownKey]: record[ownKey] } : record[ownKey]
        targetRecords.forEach(targetRecord => {
          // Set parent in target as non-enumerable. Json serialization doesn't need it, but csv does.
          Object.defineProperty(targetRecord, targetKey, { value, enumerable: false })
        })
      }

      // set the entire target record inline
      return element.is2many ? targetRecords : targetRecords[0]
    }
    case 'cds.Association': {
      if (element.is2many)
        return
      const target = csn.definitions[element.target]
      if (!target || target === parentEntity || depth > MAX_ASSOC_DEPTH)
        return

      let targetRecord = randomFromExistingData(target, csn, existingData)
      if (targetRecord) {
        delete data[target.name] // indicate that existing data is used and no new data shall be created
        delete data[target.name + '.texts'] // also delete associated texts entity
      }
      else {
        let targetRecords = data[target.name]
        if (!targetRecords && (element['@mandatory']) || element['@assert.target'])
          targetRecords = data[target.name] = []
        else if (!targetRecords) // target entity is not in the list of entities to be created
          return

        targetRecord = fillRecord({}, randomNumber(), target, csn, data, entity, depth, existingData)
        targetRecords.push(targetRecord)
      }

      // TODO: handle foreign keys correctly
      const assoc = {}
      Object.keys(target.elements)
        .filter(keyName => target.elements[keyName].key)
        .forEach(keyName => assoc[keyName] = targetRecord[keyName])
      return assoc
    }
    default: {
      throw new Error(`Unknown type '${element.type}' in '${entity.name}:${element.name}'`)
    }
  }
}

function randomFromExistingData (entity, csn, existingData) {
  const files = Object.entries(existingData)
    .filter(([, name]) => matchesEntityOrProjection(name, entity, csn))
    .map(([file]) => file)
  if (files.length === 0)  return

  if (files[0].endsWith('.csv')) {
    const content = cds.utils.fs.readFileSync(files[0]).toString()
    const records = cds.parse.csv(content)
    if (records?.length > 1) {
      const header = records[0] // 0 is header line
      const randomRecord = records.length === 2 ? records[1] : records[randomIntInRange({from: 1, to: records.length-1} )]
      let result = {}
      for (let i = 0; i < records[0].length; i++) {
        result[header[i]] = randomRecord[i]
      }
      return result
    }
  }
  else {
    let content
    if (files[0].endsWith('.json')) {
      content = cds.utils.fs.readFileSync(files[0]).toString()
    } else {
      content = files[0] // for tests, assuming the content is given inline
    }
    if (content) {
      const records = JSON.parse(content)
      if (records.length === 1)
        return records[0]
      else if (records.length > 1)
        return records[randomIntInRange({from: 0, to: records.length-1} )]
    }
  }
}

/* whether the given name matches the entity or one of its projections */
function matchesEntityOrProjection(name, entity, csn) {
  if (name === entity?.name)  return true
  // follow simle projections
  const p = entity?.query?.SELECT || entity?.projection
  if (p?.from?.ref?.length === 1) {
    if (p.from.ref[0] === name)  return true
    return matchesEntityOrProjection(name, csn.definitions[p.from.ref[0]], csn)
  }
}

function findKeysInOnCondition(assocElement, target) {
  const { on } = assocElement
  let ownKey, targetKey, ownKeyStructured
  if (on?.length === 3 && on[1] === '=') {
    for (let { ref } of [on[0], on[2]]) {
      if (ref.length > 1 && ref[0] === assocElement.name && target.elements[ref[1]]) {
        targetKey = ref[1]
      }
      else if (ref[0] === '$self') {
        ownKey = Object.keys(assocElement.parent.keys)[0]  // TODO composite keys
        ownKeyStructured = true
      }
      else if (assocElement.parent.elements[ref[0]]) {
        ownKey = ref[0]
      }
    }
  }
  return [ownKey, ownKeyStructured, targetKey]
}

function annotatedDateRange(el, dateRange) {
  if (el['@assert.range']?.length === 2) {
    const dateFrom = new Date(el['@assert.range'][0])
    const dateTo = new Date(el['@assert.range'][1])
    if (dateRange.from < dateFrom) {
      dateRange.from = dateFrom
    }
    if (dateRange.to > dateTo) {
      dateRange.to = dateTo
    }
  }
}

function annotatedIntRange(el, intRange) {
  if (el['@assert.range']?.length === 2) {
    const rangeFrom = el['@assert.range'][0]
    const rangeTo = el['@assert.range'][1]
    if (Number.isInteger(rangeFrom) && intRange.from < rangeFrom) {
      intRange.from = rangeFrom
    }
    if (Number.isInteger(rangeTo) && intRange.to > rangeTo) {
      intRange.to = rangeTo
    }
  }
   //TODO : decimalRange
}

const langList = ['ar', 'cs', 'da', 'de', 'en', 'es', 'fi', 'fr', 'hu', 'it', 'ja', 'ko', 'ms', 'nl', 'pl', 'pt', 'ro', 'ru', 'sv', 'th', 'tr', 'zh']
function randomLanguage() {
  return randomFromList(langList)

}
function randomFromList(list) {
  return list[randomNumber() % list.length]
}

function randomEmailAddress(firstName, num, csn) {
  let addr = fakerValue('faker.internet.email', csn, false)
  if (addr)  return addr
  const provider = randomFromList(['example.com', 'example.org', 'example.net'])
  return `${firstName}.${num.toString(36)}@${provider}`
}

function randomStrForRegex(regexStr, csn) {
  // TODO make 'randexp' a hard dependency when this code is in a plugin
  const randexp = requirePackage('randexp', csn, regexStr)
  if (!randexp)  return `Install package 'randexp' to create data for regex ${regexStr}`
  return randexp.randexp(regexStr)
}

function fakerValue(expr, csn, useFallback=true, ...args) {
  // `en` bundle is way smaller than full faker. TODO use different Faker locales?
  const Faker = requirePackage('@faker-js/faker/locale/en', csn)
  if (!Faker && !useFallback)  return
  if (!Faker)  return `Install package '@faker-js/faker' to create data for ${expr}`

  let resultPart
  let [, category, func] = expr.split('.')
  const cat = Faker.faker[category]
  if (typeof cat !== 'object')  return `Unknown faker category ${category} in ${expr}`
  const funcParts = func.split('::')
  if (funcParts.length === 2) {
    resultPart = funcParts.pop()
    func = funcParts.pop()
  }
  const fn = cat[func]
  if (typeof fn !== 'function')  return `Unknown faker function ${func} in ${expr}`
  if (category === 'internet' && func === 'email') {
    // only allow domains that cannot be registered
    const provider = randomFromList(['example.com', 'example.org', 'example.net'])
    return fn({ provider })
  }
  let res = args ? fn(...args) : fn()
  if (res && resultPart) {
    return res[resultPart]
  }
  return res
}

const packages = {}
function requirePackage(id, csn) {
  try {
    if (!packages[id]) {
      const pkg = resolvePackage(id, csn)
      if (pkg)
        packages[id] = require(pkg)
    }
    return packages[id]
  } catch (err) {
    if (err.code !== 'MODULE_NOT_FOUND')  throw err
  }
}

function resolvePackage(id, csn) {
  try {
    return require.resolve(id, { paths: [...csn.$sources.map(dirname), cds.root, __dirname] })
  } catch (err) {
    if (err.code !== 'MODULE_NOT_FOUND')  throw err

  }
}

// add semantics to well-known entities
function addSemantics(csn) {
  if (resolvePackage('@faker-js/faker', csn)) { // only if faker is installed
    csn.all('entity').forEach(entity => {
      const { elements } = entity
      if (entity.name === 'sap.common.Countries') {
        elements.code['@data.gen'] = 'faker.location.countryCode'
        elements.name['@data.gen'] = elements.descr['@data.gen'] = 'faker.location.country'
      }
      else if (entity.name === 'sap.common.Currencies') {
        elements.code['@data.gen'] = 'faker.finance.currency::code'
        elements.name['@data.gen'] = elements.descr['@data.gen'] = 'faker.finance.currency::name'
        elements.symbol['@data.gen'] = 'faker.finance.currency::symbol'
      }
      else if (entity.name === 'sap.common.Timezones') {
        elements.code['@data.gen'] = 'faker.location.timeZone'
        elements.name['@data.gen'] = elements.descr['@data.gen'] = 'faker.location.timeZone'
      }
    })
  }
}

function randomDateInRange(dateRange) {
  const dateFrom = dateRange.from
  const returnDate = new Date(dateFrom.getUTCFullYear(), dateFrom.getUTCMonth(), dateFrom.getUTCDate())//needed to avoid overwriting the original dateFrom when generating a random Date
  const diffTime = dateRange.to.valueOf() - dateRange.from.valueOf();
  const diffDays = Math.ceil(diffTime / (1000 * 60 * 60 * 24));
  const step = randomNumber() % diffDays
  returnDate.setUTCDate(returnDate.getUTCDate() + step);
  return returnDate
}

function randomDecimalInRange(decimalRange) {
  const max = decimalRange.to
  const min = decimalRange.from
  const num = min + (randomNumber() % (max - min))
  let dec = randomNumber()
  const divider = Math.pow(10, dec.toString().length)
  dec = dec / divider
  const returnValue = num + dec
  return returnValue
}

function randomIntInRange(intRange) {
  const max = intRange.to
  const min = intRange.from
  return min + (randomNumber() % max)
}

const p = 5651;
const q = 5623;
const M = p * q;
function randomNumber() {
  counter = (counter * counter) % M
  return counter;
}
