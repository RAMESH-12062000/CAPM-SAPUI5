const path = require('path');

const term = require('../util/term');

const { OPTIONS, COMMAND_INIT, PROJECT_FILES, REGEX_PROJECT_NAME } = require('./constants')
const {
    NODEJS, JAVA,
    HANA, APPROUTER, XSUAA, APPLICATION_LOGGING, ENTERPRISE_MESSAGING,
    MTA, MULTITENANCY, PIPELINE,
    TINY_SAMPLE, SAMPLE
} = OPTIONS

const cds = require('..'), { exists, readdir } = cds.utils
const DEBUG = /\b(y|all|cli)\b/.test(process.env.DEBUG) ? console.debug : undefined

module.exports = class CDSGenerator {
    constructor() {
        this.cwd = process.cwd()

        this.uiConfig = [{
            title: 'Project Name',
            description: 'Enter your project name.',
            default: '',
            target: 'projectName',
            validate: async (value) => {
                try {
                    cds.root = path.resolve(this.cwd, value || '.');

                    await this._validateProjectName(value);
                    await this._validateProjectFolder(path.join(this.cwd, value), this.cwd);
                } catch (e) {
                    return e
                }

                return true;
            },
            guiOptions: {
                hint: 'This name is restricted to certain characters. A valid project name is compatible across platforms.',
                mandatory: true
            }
        }, {
            title: 'Type',
            description: `Select your runtime.`,
            default: NODEJS,
            choices: [
                { name: 'Node.js', value: NODEJS },
                { name: 'Java', value: JAVA }
            ],
            multiple: false,
            target: 'add',
            guiOptions: {
                hint: `The preferred runtime can't be changed afterwards. To use a different runtime, create a new project.`,
                mandatory: true
            }
        }, {
            title: 'Features',
            description: 'Choose productive runtime capabilities for your application.',
            default: '',
            choices: [
                { name: 'SAP HANA Cloud', value: HANA },
                { name: 'SAP Application Router', value: APPROUTER },
                { name: 'User Authentication via XSUAA', value: XSUAA },
                { name: 'Application Logging', value: APPLICATION_LOGGING },
                { name: 'SAP BTP Event Mesh', value: ENTERPRISE_MESSAGING }
            ],
            multiple: true,
            target: 'add',
            guiOptions: {
                hint: `Choose any combination of features enriching the capabilities of your project. You can also add features later with ${term.bold('cds add')}`
            }
        }, {
            title: 'Deployment',
            description: 'Choose which way to deploy your project.',
            default: '',
            choices: [
                { name: 'Cloud Foundry: MTA Deployment', value: MTA },
                // { name: 'Kyma: Helm Deployment', value: HELM },
                { name: 'Multitenancy', value: MULTITENANCY },
                { name: 'CI/CD Pipeline Integration', value: PIPELINE },
            ],
            multiple: true,
            target: 'add',
            guiOptions: {
                hint: `Choose any combination of features enriching the capabilities of your project. You can also add features later with ${term.bold('cds add')}`
            }
        }, {
            title: 'Samples',
            description: `Add sample content to your project.`,
            default: '',
            choices: [
                { name: 'Minimal Sample', value: TINY_SAMPLE },
                { name: 'Extended Sample with UI', value: SAMPLE }
            ],
            multiple: true,
            target: 'add',
            guiOptions: {
                hint: 'Speed up your ramp-up phase with sample files in your project.'
            }
        }]
    }

    /**
     * @param {string} facets, comma separated list of facets
     * @param {any} options, additional options
     */
    async add(facets) {
        if (!facets?.length) throw 'You must specify a facet to add to the project.'

        this._initialize(null);
        this._greetings();

        if (!PROJECT_FILES.find(exists)) {
            throw `The current folder doesn't seem to contain a project. None of the following files found: ${PROJECT_FILES.join(', ')}.`
        }

        await this._process(facets);
        await this.stepEnd();
    }

    /**
     * @param {string} projectName, the project name
     */
    async initCmd(projectName) {
        await this.stepInit(projectName);
        await this.stepEnd();
    }

    async stepInit(projectName, options) {
        if (options) {
            // called from CAP generator with options
            cds.cli = {
                command: COMMAND_INIT,
                // keep caller independent from internal names
                options: {
                    cwd: options.cwd,
                    add: new Set(options.add)
                }
            }

            // must be called after above code to ensure cds.cli.options.add is set
            cds.add = require('./add')
        }

        this._initialize(projectName);
        this._greetings();

        await this._process();
    }

    _initialize(projectName) {
        const { options } = cds.cli
        this.cwd = options.cwd || process.cwd();
        cds.root = path.resolve(this.cwd, projectName || '.');
        this.projectName = path.basename(cds.root);

        this._cleanupOptions();
    }

    _greetings() {
        if (cds.cli.command === COMMAND_INIT) {
            const relativeProjectPath = path.relative(this.cwd, cds.root)
            const folderName = relativeProjectPath ? `.${path.sep}${relativeProjectPath}` : 'current folder'
            console.log(`Creating new CAP project in ${term.bold(folderName)}\n`)
        }
        if (cds.cli.options.for && typeof cds.cli.options.for !== 'string') {
            throw 'The --for argument must not be empty.'
        }
        if (cds.cli.options.force) {
            console.log(`Using '--force' ... existing files will be overwritten`)
        }
    }

    async _process(facets) {
        DEBUG?.(`Project path: ${cds.root}`);

        await this._validateOptions();
        await this._fillTemplateList(facets);

        for (const template of this.templateList) {
            console.log(`Adding feature '${template.name}'...`);
            await template.run();
            await template.combine();
            await template.combineSupported();
        }

        if (cds.cli.command === COMMAND_INIT) {
            const relativeProjectPath = path.relative(this.cwd, cds.root)
            let message = 'Successfully created project.'
            if (relativeProjectPath) {
                message = message + ` Continue with '${term.bold('cd ' + relativeProjectPath)}'.`
            }
            console.log('\n' + message)
        } else {
            console.log(`\nSuccessfully added features to your project.`)
        }
    }

    async _createTemplate(plugin) {
        try {
            const Plugin = cds.add.registered.get(plugin) ?? require(`./template/${plugin}`)
            return new Plugin(this)
        } catch (err) {
            if (err.code === 'MODULE_NOT_FOUND') {
                const entries = (await readdir(path.join(__dirname, 'template')))
                    .filter(entry =>
                        !entry.startsWith('_') &&
                        !entry.endsWith('.js') &&
                        entry !== 'nodejs' &&
                        entry !== 'java'
                    );
                const fuzzySearch = require('../../bin/util/fuzzySearch')
                const [bestMatch] = fuzzySearch(plugin, entries)
                throw `Unknown facet '${term.bold(plugin)}'. Did you mean ${term.bold(`cds add ${bestMatch}`)}?\n\nHaven't found the proper facet yet? Here are all supported facets:\n\n  ${term.bold(entries.join('\n  '))}\n`
            }
            throw err
        }
    }

    async _fillTemplateList(facets) {
        const templates = new Map
        const { command, options } = cds.cli

        const plugins = command === COMMAND_INIT ? options.add : new Set(facets)

        for (let plugin of plugins) {
            // Compat
            if (plugin === 'helm' && cds.cli.options['internal-unified-runtime-charts']) {
                plugin = 'helm-unified-runtime'
                cds.cli.options.add.delete('helm')
                cds.cli.options.add.add('helm-unified-runtime')
            }
            if (plugin === 'sample-tiny') plugin = 'tiny-sample'
            if (plugin in { 'kibana-logging':1, 'kibana':1 }) plugin = 'application-logging'
            if (plugin === 'postgresql') plugin = 'postgres'

            if (!templates.has(plugin)) {
                const template = await this._createTemplate(plugin)
                if (await template.canRun()) {
                    DEBUG?.(`Adding feature '${template.name}'`)
                    templates.set(plugin, template)
                    const dependencies = await template.requires()
                    dependencies?.forEach(d => plugins.add(d))
                }
            }
        }

        const cmds = Object.values(OPTIONS)
        this.templateList = Array.from(templates.entries())
            .sort(([lhs], [rhs]) => {
                const a = cmds.indexOf(lhs), b = cmds.indexOf(rhs)
                if (a === -1 && b === -1) return 0
                if (a === -1) return 1
                if (b === -1) return -1
                return a - b
            })
            .map((entry) => entry[1])

        // check debug to avoid lengthy computation when not in debug mode
        DEBUG?.(`Features: ${this.templateList.map(({name}) => name).join(', ')}`);
    }

    // CAP Generator API
    async stepEnd() {
        for (const template of this.templateList) {
            await template.finalize();
        }
    }

    _cleanupOptions() {
        let tokens = [];

        const { options } = cds.cli
        if (typeof options.add === 'string') {
            tokens = options.add.split(/[,\s+]/g);

        } else if (Array.isArray(options.add)) {
            tokens = options.add

        } else if (options.add instanceof Set) {
            tokens = [...options.add];
        }

        const trimmedTokens = tokens.map((token) => {
            token = token.replace(/\s+/g, '');
            const tokens = token.split(':'), [facet] = tokens
            if (tokens.length > 1) {
                if (options[facet]) {
                    options[facet].add(token);
                } else {
                    options[facet] = new Set([token]);
                }
            }
            return facet;
        }).filter(Boolean);

        // set is ordered ... always
        options.add = new Set(trimmedTokens);

        if (cds.cli.command === COMMAND_INIT && !options.add.has(JAVA)) {
            options.add.add(NODEJS);
        }
    }

    async _validateOptions() {
        const { options, command } = cds.cli
        if (options.force) {
            return;
        }

        if (command === COMMAND_INIT) {
            await this._validateProjectName(this.projectName);
            await this._validateProjectFolder(this.cwd);
        }
    }

    async _validateProjectName(projectName) {
        if (!projectName) {
            throw 'Specify a project name.'
        }

        // remove duplicates by using a set
        const invalidChars = new Set(projectName.match(REGEX_PROJECT_NAME));
        if (invalidChars.size > 0) {
            throw `Project name '${projectName}' contains at least one character ('${[...invalidChars]}') which is not supported in npm package names.
Specify a different project name by replacing characters with '_' or '-', for example '${projectName.replace(REGEX_PROJECT_NAME, '_')}' or '${projectName.replace(REGEX_PROJECT_NAME, '-')}'.`
        }
    }

    async _validateProjectFolder(cwd) {
        const existingProjectFile = PROJECT_FILES.find(exists)
        if (existingProjectFile) {
            let message;
            if (cwd === cds.root) {
                message = `You seem to be working in a project which is already initialized. Use ${term.bold('cds add')} to add more features.`;
            } else {
                message = `You seem to be trying to initialize an existing project. Use a different project name instead.`;
            }
            throw `${message}\nDetails: File '${existingProjectFile}' exists in the project folder which indicates an existing project. Use ${term.bold('cds add')} to add more features.`
        }
    }
}
