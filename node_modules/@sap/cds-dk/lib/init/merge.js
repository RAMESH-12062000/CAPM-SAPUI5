const YAML = require('@sap/cds-foss').yaml
const cds = require('../cds')
const { copy, read, write, exists } = cds.utils
const { readYAML, writeYAML, readJSON } = require('../util/fs')
const { EOL } = require('node:os')
const { detectIndent } = require('./indent')

function _isObject(item) {
  return item && typeof item === 'object' && !Array.isArray(item)
}

function _mergeObject(target, source) {
  const unique = array => [...new Set(array.map(JSON.stringify))].map(JSON.parse)
  if (_isObject(target) && _isObject(source)) {
      for (const key in source) {
          if (_isObject(source[key])) {
              if (!target[key]) Object.assign(target, { [key]: source[key] })
              else _mergeObject(target[key], source[key])
          } else if (Array.isArray(source[key]) && Array.isArray(target[key])) {
              target[key] = unique([...source[key], ...target[key]])
          } else {
              Object.assign(target, { [key]: target[key] || source[key] })
          }
      }
  } else if (Array.isArray(target) && Array.isArray(source)) {
      target = unique([...source, ...target])
  }
  return target ?? source
}

async function sort(path, key) {
  const json = await read(path)
  json[key] = Object.fromEntries(
      Object.entries(json[key]).sort(([a],[b]) => a>b ? 1 : -1)
  )
  await write(path, json, { spaces: 2 });
}

/**
 * @param {string} into - file path to merge into
 * @param {string | string[]} from - either path to file (string) or lines from source gitignore (string[])
 * @returns {Promise<string[]>} the lines of the updated .gitignore
 */
async function mergeGitignore (into, from) {
    const source = typeof from === 'string' ? (await read(from)).split(EOL) : from

    if (typeof into === 'string' && !exists(into)) {
      return write(into, source.join(EOL))
    }

    const target = (await read(into)).split(EOL)
    const enhanced = target.concat(source.filter(line => !target.includes(line)))
    await write(into, enhanced.join(EOL))
    return enhanced
  }

/**
 * @typedef {Object} MatchedNode
 * @property {string | MatchedNode} in - key path or matched node to start search from
 * @property {Object} where - list of constraints
 */

/**
 * @typedef {Object} Overwrites
 * @property {(string | MatchedNode)[]} item - path to item to be overwritten
 * @property {string} withValue - replacement string
 */

/**
 * @typedef {Object} Deletion
 * @property {MatchedNode} item - matched node to delete
 * @property {Object[]} relationships - list of relationships to delete
 * @property {string} relationships[].removeProperty - key path to to-be-removed property
 * @property {string[]} relationships[].allWithin - key path to relationship
 */

/**
 * @typedef {Object} Relationship
 * @property {(string | MatchedNode)[]} insert - source path to matched node
 * @property {(string | MatchedNode)[]} into - target path for inserted relationship
 */

/**
 * @typedef {Object} MergingSemantics
 * @property {boolean} [forceOverwrite] - overwrite values for existing keys
 * @property {MatchedNode[]} [additions] - matched nodes to be added from source template
 * @property {Overwrites[]} [overwrites] - matched keys to be overwritten with given string
 * @property {Deletion[]} [deletions] - matched nodes to be deleted
 * @property {Relationship[]} [relationships] - relationships to be inserted
 */

/**
 * @param {string | JSON} into - file path or JSON to merge into
 * @param {string | JSON} from - file path or JSON to merge from
 * @param {import('./projectReader').readProject} [project] - project descriptor used for Mustache replacements
 * @param {MergingSemantics} [semantics] - merging algorithm semantics
 * @returns {Promise<JSON>} - merged JSON
 */
async function _mergeJSON(into, from, project, semantics) {
    const source = typeof from === 'string' ? await readJSON(from, project) : from

    let result
    if (typeof into === 'string' && !exists(into)) {
        result = source
    } else if (semantics) {
        const target = await read(into)
        const targetYAML = YAML.parseDocument(YAML.stringify(target))
        const sourceYAML = YAML.parseDocument(YAML.stringify(source))
        const resultYAML = await _mergeYAML(targetYAML, sourceYAML, project, semantics)
        result = YAML.parse(YAML.stringify(resultYAML))
    } else {
        const target = typeof into === 'string' ? await read(into, 'json') : into
        result = _mergeObject(target, source)
    }
    // we need to stringify result on site to be able to apply the appropriate indentation.
    // cds-utils.write is currently hardcoded to use spaces for indentation.
    if (typeof into === 'string') {
        const indent = exists(into) && detectIndent((await read(into, 'utf-8')).split(EOL)) || '  '
        await write(into, JSON.stringify(result, null, indent) + EOL)
    }
    return result
}

/**
 * @param {string | YAML.Document} into - file path or YAML to merge into
 * @param {string | YAML.Document} from - file path or YAML to merge from
 * @param {Object} [project] - project descriptor used for Mustache replacements
 * @param {MergingSemantics} [semantics] - merging algorithm semantics
 * @returns {Promise<YAML.Document>} - merged YAML
 * @throws {Error} Throws an error if empty target YAML is passed in
 */
async function _mergeYAML(into, from, project, semantics = {}) {
    const target = typeof into === 'string' ? await readYAML(into) : into instanceof YAML.Document ? into : new YAML.Document(into)
    const source = typeof from === 'string' ? await readYAML(from, project) : from instanceof YAML.Document ? from : new YAML.Document(from)

    if (!target?.contents) {
        if (typeof into === 'string' && typeof from === 'string') {
            project ? await writeYAML(into, source) : await copy(from, into)
            return source
        }
        throw new Error(`Target YAML doesn't exist`)
    }

    const entryMap = new Map, templateEntryMap = new Map

    const { additions, overwrites, deletions, relationships } = semantics
    additions?.forEach(entry => {
        entryMap.set(entry, undefined)
        templateEntryMap.set(entry, undefined)
    })
    deletions?.forEach(deletion => {
        entryMap.set(deletion.item, undefined)
    })
    relationships?.forEach(relationship => {
        const [entry] = relationship.into
        const [insertEntry] = relationship.insert
        const hash = insertEntry + ' -> ' + entry
        entryMap.set(hash, undefined)
    })

    let collectionStack = [target.contents]

    const _getProperty = (object, keyPath) => keyPath.split('.').reduce((p, k) => p && p[k], object)
    const _getYAMLProperty = (object, keyPath) => keyPath.split('.').reduce((p, k) => p && p.get(k), object)

    const _validateWhere = (node, dict, index) => {
        const _addToMap = entries => entries?.filter(entry => {
                if (typeof entry.in === 'string') return true // just a key path on the document root
                const neededParent = dict.get(entry.in[0])?.node
                return collectionStack.includes(neededParent) // lookbehind in parent collection stack
                // REVISIT: Only look behind until sequence is reached?
        }).forEach(item => {
            const json = JSON.parse(String(node))
            const whereFulfilled = Object.entries(item.where).every(([key, value]) =>
                _getProperty(json, key) === value
            )
            if (whereFulfilled) {
                const [collection] = collectionStack
                dict.set(item, { json, node, index, collection })
            }
        })
        if (additions) _addToMap(additions)
        if (deletions) _addToMap(deletions.map(deletion => deletion.item))
        if (relationships) _addToMap(relationships?.map(({into: [entry]}) => entry).filter(e => e))
    }

    function _traverseYAMLNode(node, index, actions, templateNode) {
        let shifted = false
        if (YAML.isMap(node)) {
            actions.visitMap?.(node, index)
            const [collection] = collectionStack
            if (YAML.isSeq(collection)) {
                collectionStack.unshift(node)
                shifted = true
            }
        } else if (YAML.isPair(node) && node.value?.items) {
            collectionStack.unshift(node.value)
        } else if (YAML.isScalar(node) && semantics.forceOverwrite && templateNode) {
            node.value = templateNode.value ?? templateNode.items?.[0]?.value?.value
        }

        if (node.items) {
            if (YAML.isSeq(node) && templateNode?.items) {
                actions.mergeCollection?.(node, templateNode)
                _traverseYAMLCollection(node, actions, templateNode)
            } else {
                _traverseYAMLCollection(node, actions, templateNode)
            }
        } else if (node.value?.items || node.value && semantics.forceOverwrite) {
            _traverseYAMLNode(node.value, index, actions, templateNode?.value)
        }

        if (node.value?.items || shifted) {
            collectionStack.shift()
        }
    }
    _traverseYAMLNode.bind(this)

    function _traverseYAMLCollection (collection, actions, templateCollection) {
        if (!collection) return

        const keyToIndex = new Map, templateIndexToIndex = new Map

        // Map collection items to their semantic counterpart(s)
        collection.items.forEach((node, i) => {
            if (node.key) keyToIndex.set(node.key.value, i)
            const entry = [...entryMap.entries()].find(([,value]) => value?.node === node)
            if (entry) {
                const [entryKey] = entry
                const templateEntry = entryKey && templateEntryMap.get(entryKey)
                const templateIndex = templateEntry?.index
                if (templateIndex !== undefined) templateIndexToIndex.set(templateIndex, i)
            }
            if (!templateCollection) _traverseYAMLNode(node, i, actions)
        })

        if (!templateCollection?.items) return

        templateCollection.items?.forEach((templateNode, templateIndex) => {
            if (YAML.isScalar(templateNode)) {
                if (!collection.items.map(item => item.value).includes(templateNode.value)) {
                    collection.add(templateNode)
                }
            } else if (YAML.isPair(templateNode)) {
                const i = keyToIndex.get(templateNode.key.value)
                const [collection] = collectionStack
                const targetNode = collection.items?.[i]
                if (targetNode) {
                    _traverseYAMLNode(targetNode, templateIndex, actions, templateNode)
                } else {
                    actions.mergePair?.(collection, templateNode)
                }
            } else if (YAML.isMap(templateNode)) {
                const targetNode = collection.items[templateIndexToIndex.get(templateIndex)]
                actions.mergeCollection?.(targetNode, templateNode)
                if (targetNode) {
                    _traverseYAMLNode(targetNode, templateIndex, actions, templateNode)
                }
            }
        })
    }
    _traverseYAMLCollection.bind(this)

    // 1. Register the entries in the template
    _traverseYAMLNode(source.contents, null, {
        visitMap: (node, index) => _validateWhere(node, templateEntryMap, index)
    })

    // 2. Register the entries in the project
    _traverseYAMLNode(target.contents, null, {
        visitMap: (node, index) => _validateWhere(node, entryMap, index)
    })

    // 3. Apply overwrites to already found entries
    overwrites?.forEach(({ item, withValue }) => {
        const keyPath = Array.isArray(item) && typeof item[0] === 'string' ? item[0] : typeof item === 'string' ? item : item[1]
        const inEntry = Array.isArray(item) && typeof item[0] === 'object' ? item[0] : typeof item === 'object' ? item : item[1]
        const node = inEntry && entryMap.get(inEntry) ? entryMap.get(inEntry).node : collectionStack[collectionStack.length - 1]
        const keys = keyPath.split('.')
        if (!node.getIn(keys)) return
        _getYAMLProperty(node, keys.slice(0, keys.length - 1).join('.'))
            .set(keys[keys.length - 1], withValue)
    })

    // 4. Delete entries from the project (e.g. separate deployer module when adding mtx)
    deletions?.forEach(({ item, relationships }) => {
        const entry = entryMap.get(item)
        if (!entry) return
        entry.collection.delete(entry.index)

        relationships?.forEach(relationship => {
            const [allWithinKeyPath, inKeyPath, into] = relationship.allWithin
            const parent = _getYAMLProperty(target, allWithinKeyPath)
            for (const child of parent.items) {
                const grandchild = _getYAMLProperty(child, inKeyPath)
                const i = grandchild?.items?.findIndex(node =>
                    node.get(into) === _getProperty(entry.json, relationship.removeProperty)
                ) ?? - 1
                if (i > -1) grandchild.delete(i)
            }
        })
    })

    // 5. Create missing entries and pairs
    _traverseYAMLNode(target.contents, null, {
        mergePair: (collection, templateNode) => {
            if (YAML.isMap(collection)) {
                collection.add(templateNode)
            }
        },
        mergeCollection: (targetNode, templateNode) => {
            if (YAML.isSeq(templateNode)) {
                let [,parent] = collectionStack
                additions?.filter(addition => {
                        if (typeof addition.in === 'string' || Array.isArray(addition.in) && typeof addition.in[0] === 'string') return true
                        const inEntry = Array.isArray(addition.in) ? entryMap.get(addition.in[0]) : entryMap.get(addition.in)
                        return inEntry?.node === parent
                    })
                    .filter(addition => {
                        const keyPath = typeof addition.in === 'string' ? addition.in : Array.isArray(addition.in) && typeof addition.in[0] === 'string' ? addition.in[0] : addition.in[1]
                        const keys = keyPath.split('.')
                        if (keys.length > collectionStack.length + 1) return false
                        if (keys.length > 1) parent = collectionStack[keys.length]
                        return _getYAMLProperty(parent, keyPath) === targetNode
                    })
                    .filter(item => !entryMap.get(item))
                    .forEach(item => {
                        const templateNode = templateEntryMap.get(item).node
                        item.at !== undefined ? targetNode.items.splice(item.at, 0, templateNode) : targetNode.add(templateNode)
                    })
            }
        },
    }, source.contents)

    // 6. Re-register the entries in the project
    _traverseYAMLNode(target.contents, null, {
        visitMap: (node, index) => _validateWhere(node, entryMap, index)
    })

    // 7. Create missing relationships
    _traverseYAMLNode(target.contents, null, {
        mergeCollection: (targetNode, templateNode) => {
            if (YAML.isSeq(templateNode)) {
                const targetJSON = YAML.parse(String(targetNode))
                const relationship = semantics.relationships?.filter(r => r)
                    .find(relationship => {
                        const [entry, keyPath] = relationship.into
                        if (!entryMap.get(entry)) return false
                        const existingNode = _getYAMLProperty(entryMap.get(entry).node, keyPath)
                        return targetNode === existingNode
                })
                if (!relationship) return

                const intoKey = relationship.into[relationship.into.length - 1]
                const [entry, entryKeyPath] = relationship.insert
                const missingPairs = [entry]
                    .filter(item =>
                        !targetJSON.some(targetItem =>
                            _getProperty(entryMap.get(item).json, entryKeyPath) === targetItem[intoKey]
                        )
                    )
                    .map(item => entryMap.get(item).node.get(intoKey))
                missingPairs.forEach(pair => {
                    targetNode.add({ [intoKey]: pair })
                })
            }
        }
    }, source.contents)

    typeof into === 'string' && await writeYAML(into, target)
    return target
}

async function removeFromYAML(name, keyPaths) {
    const yaml = await readYAML(name)
    for (const keyPath of keyPaths) {
        let node = yaml
        const keys = keyPath.split('.')
        for (const [index, key] of keys.entries()) {
            if (index === keys.length - 1) {
                node.delete(key)
            } else {
                node = node.get(key)
                if(node === undefined) break;
            }
        }
    }
    await writeYAML(name, yaml)
}

async function removeFromYAMLArray(name, keyPath, aliasToRemove) {
    const yaml = await readYAML(name)

    let node = yaml
    // traverse to the array node
    const keys = keyPath.split('.')
    for (const key of keys) {
        node = node.get(key)
    }

    // find index of array entry with aliasToRemove entry
    let index = 0;
    let entryNode = node.getIn([index])
    while(entryNode !== undefined) {
        if(entryNode.toJSON().alias === aliasToRemove) {
            node.deleteIn([index])
            break;
        }
        index++;
        entryNode = node.getIn([index])
    }

    await writeYAML(name, yaml)
}


const path = require('path')

/**
 * @param {...(string | Object | YAML.Document)} src The source to merge from.
 * @returns {{
*   into: (dst: (string | Object | YAML.Document), options?: {project?: Object, semantics?: MergingSemantics}) => Promise<any>
* }} An object with an 'into' method to merge the sources into the specified destination.
*/
const merge = (...src) => {
    return {
        /**
         * Merges sources into the specified destination.
         * @param {(string | Object | YAML.Document)} dst File path or object to merge into.
         * @param {Object} [options] Merging options.
         * @param {Object} [options.project] Project descriptor used for Mustache replacements.
         * @param {MergingSemantics} [options.semantics] Merging algorithm semantics.
         * @returns {Promise} A promise resolving to the merged object.
         */
        into: (dst, { with: withProject, project, ...semantics } = {}) => {
            if (Object.keys(semantics).length === 0) semantics = undefined
            project ??= withProject // to allow { with: project } for a more fluent API
            const isYAML = typeof dst === 'string' && ['.yaml', '.yml', '.yaml.hbs', '.yml.hbs'].some(ext => dst.endsWith(ext))
            const _merge = isYAML ? _mergeYAML : _mergeJSON
            const target = typeof dst === 'string' ? path.resolve(cds.root, dst) : dst
            if (typeof src[src.length-1] === 'string') {
                return _merge(target, path.join(...src), project, semantics)
            } else {
                return _merge(target, ...src, project, semantics)
            }
        }
    }
}

module.exports = {
  merge,
  sort,
  mergeGitignore,
  removeFromYAML,
  removeFromYAMLArray
}
