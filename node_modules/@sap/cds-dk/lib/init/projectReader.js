const cds = require('../cds')
const { join, resolve, basename } = require('path')
const { fs, exists, isdir, path } = cds.utils
const { parseXml } = require('./xml')
const { REGEX_JAVA_VERSION } = require('./constants')
const DEBUG = cds.debug('cli')

module.exports = new class ProjectReader {

    constructor() {
        this.readProject = this.readProject.bind(this)

        // 1. Use project name and static default values
        this.appVersion = cds.cli.options.add?.has('java') ? '1.0.0-SNAPSHOT' : '1.0.0'
        this.appName = this.appId = basename(cds.root)
        this.appDescription = 'A simple CAP project.'

        // 2. Use either pom.xml or package.json
        if (exists('pom.xml')) {
            const { artifactId = [], description = [], version = [], properties = [] } = parseXml(resolve(cds.root, 'pom.xml')) ?? {}
            const v = version[0] === '${revision}' ? properties[0]?.revision[0] : version[0]
            if (v && REGEX_JAVA_VERSION.test(v)) this.appVersion = v
            if (artifactId[0])  this.appName = this.appId = artifactId[0].split(/-parent/)[0]
            if (description[0]) this.appDescription = description[0]
        }
        else if (exists('package.json')) {
            const { name, version, description } = JSON.parse(fs.readFileSync(join(cds.root, 'package.json')))
            this.appVersion = version
            const segments = name.trim().replace(/@/g, '').split('/').map(encodeURIComponent)
            this.appName = segments[segments.length - 1]
            this.appId = segments.join('.')
            this.appDescription = description ?? this.appDescription
        }
    }

    // REVISIT: There should an API provided by cds.env
    /**
     * Returns cds.env using 'production' profile by default as mta deployment is executed with having production profile set.
     */
    env4(profile = 'production') {
        const cdsEnv = process.env.CDS_ENV
        process.env.CDS_ENV = profile
        try {
            return cds.env.for('cds')
        } finally {
            cdsEnv ? process.env.CDS_ENV = cdsEnv : delete process.env.CDS_ENV
        }
    }

    /**
     * @typedef {Object} ProjectConfig
     * @property {string} appVersion The version of the application.
     * @property {string} appName The name of the application.
     * @property {string} appId The ID of the application.
     * @property {string} appDescription The description of the application.
     * @property {string} language The programming language of the project.
     * @property {string} srvPath The path to the server module.
     * @property {string} archiveName The name of the archive.
     * @property {Object} db Database configuration.
     * @property {string} configFile The name of the configuration file. This is typically the `package.json` for Node.js and `.cdsrc.json` for Java.
     * @property {string} appPath The path to the app folder.
     * @property {string} approuterPath The path to the approuter folder.
     * @property {boolean} hasUIEmbedded Indicates if the project uses an embedded UI.
     * @property {boolean} hasUIModule Indicates if the project is using a modular UI.
     * @property {boolean} hasUI Indicates if the project has a UI.
     * @property {boolean} isJava Indicates if the project is using Java.
     * @property {boolean} isNodejs Indicates if the project is using Node.js.
     * @property {boolean} hasHelmUnifiedRuntime Indicates if the project uses Unified Runtime Helm deployment.
     * @property {boolean} hasHelm Indicates if the project uses CAP Helm deployment.
     * @property {boolean} hasMta Indicates if the project uses MTA deployment.
     * @property {boolean} hasConnectivity Indicates if the project uses connectivity.
     * @property {boolean} hasMultitenancy Indicates if the project is multitenant.
     * @property {boolean} hasToggles Indicates if the project uses feature toggles.
     * @property {boolean} hasExtensibility Indicates if the project is extensible.
     * @property {boolean} hasXsuaa Indicates if the project uses XSUAA.
     * @property {boolean} hasHana Indicates if the project uses HANA.
     * @property {boolean} hasPostgres Indicates if the project uses PostgreSQL.
     * @property {boolean} hasEnterpriseMessaging Indicates if the project uses SAP BTP Event Mesh.
     * @property {boolean} hasApprouter Indicates if the project uses the SAP Application Router.
     * @property {boolean} hasHtml5Repo Indicates if the project uses the SAP BTP HTML5 Application Repository.
     * @property {boolean} hasDestination Indicates if the project uses the SAP BTP Destination service.
     *
     */

    /**
     * Reads the project configuration and constructs a project object.
     * This function dynamically resolves project properties and returns an object with these properties.
     *
     * @returns {ProjectConfig} An object representing the project configuration.
     */
    readProject() {
        const env = this.env4('production')
        const { appVersion, appName, appId, appDescription } = this
        DEBUG?.({ env })

        const _inProd = plugin => require(`./template/${plugin}`).hasInProduction(env)
        const reserved = {
            has: x => _inProd(x),
            shortcut: () => true,
            profile: () => cds.cli.options?.for,
            language: () => exists('pom.xml') ? 'java' : 'nodejs',
            isJava: () => exists('pom.xml') || cds.cli.options?.add?.has('java'),
            isNodejs: () => !exists('pom.xml') && !cds.cli.options?.add?.has('java'),
            srvPath: () => join(env.build.target, env.folders.srv.replace(/\/$/, '')).replace(/\\/g, '/'),
            archiveName: () => {
                const pom = parseXml(resolve(cds.root, env.folders.srv, 'pom.xml'))
                return (pom?.artifactId?.[0] ?? basename(cds.root)) + '-exec.' + pom?.packaging?.[0]
            },
            db: () => {
                const folder = env.folders.db
                const name = folder.replace(/\/$/, '')
                const path = join(env.build.target, name).replace(/\\/g, '/')
                return { folder, name, path }
            },
            configFile: () => exists('pom.xml') ? '.cdsrc.json' : 'package.json',
            apps: () => (fs.readdirSync(path.resolve(cds.root, cds.env.folders.app))).filter(e =>
                isdir(join(cds.root, cds.env.folders.app, e)) && e !== 'appconfig' && e !== '_i18n' && e !== 'router'
            ).map(app => ({ app })),
            appUIPaths: () => (fs.readdirSync(path.resolve(cds.root, cds.env.folders.app))).filter(e =>
                isdir(join(cds.root, cds.env.folders.app, e)) && e !== 'appconfig' && e !== '_i18n' && e !== 'router'
            ),
            appPath: () => env.folders.app,
            appVersion: () => appVersion,
            approuterPath: () => join(env.folders.app, 'router'),
            appName: () => appName,
            cleanedAppName: () => appName.replaceAll('_', '-'),
            appId: () => appId,
            appDescription: () => appDescription,
            hasUIEmbedded: () => exists(join(env.folders.app, 'xs-app.json')),
            hasUIModule: () => !this.hasUIEmbedded && isdir(env.folders.app) && fs.readdirSync(resolve(cds.root, env.folders.app)).length > 0,
            hasUI: () => this.hasUIEmbedded || this.hasUIModule
        }

        const project = (() => {
            const defined = {}
            return new Proxy({}, {
                get(_, p) { return _get(p) ?? defined[p] },
                set(_, p, value) { defined[p] = value; return true },
                has(_, p) { return _get(p) ?? p in defined }
            })
        })()

        const _get = property => { const p = property
            if (p in reserved) return reserved[p]()
            for (const prefix of ['has', 'is']) if (p.startsWith(prefix) && p.length > prefix.length) {
                return _inProd(p.slice(prefix.length).replace(/([a-z0-9])([A-Z])/g, '$1-$2').toLowerCase())
            }
        }

        DEBUG?.({ project })
        return project
    }
}
