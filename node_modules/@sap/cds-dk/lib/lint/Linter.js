const term = require("../util/term");

const io = require("./io");
const checks = require("./checks");
const generators = require("./generators");

const cds = require("../../lib/cds");
const { path, exists, isdir, isfile, readdir } = cds.utils
const { exit } = require("process");
const LOG = cds.debug("lint");
const LOG_CONFIG = cds.debug("lint:config");

class Linter {
  constructor() {
    this.eslintCmd = "";
    this.eslintCmdShort = "eslint";
    this.eslintCmdFileExpr = "";
    this.isFile = false;
    this.help = "";
    this.debug = "";
    this.flags = [];
    this.configPath = "";
    this.configContents = {};
    this.cdsdkPath = path.join(__dirname, "../..");
    this.globalPath = path.join(this.cdsdkPath, "../..");
    this.extendsPlugin = false;
    this.fileExtensions = [];
    this.pluginPath = "";
    this.pluginApi = {};
    this.lintType = "global";
    this.ruleOpts = {};
    this.customRulesOpts = [];
    this.pluginRules = [];
    this.init = this.init.bind(this);
    this.lint = this.lint.bind(this);
  }

  /**
   * Initializes `cds lint` call and generates the required content
   * object for `cds` executable
   * @returns object containing help, options, flags and shortcuts
   */
  init(help = "", options = [], flags = [], shortcuts = []) {
    this.eslintCmd = checks.resolveEslint(this.cdsdkPath, this.globalPath);
    if (this.eslintCmd) {
      help = generators.genEslintHelp(this.eslintCmd);
      flags = generators.genEslintFlags(help);
      [help, options, shortcuts, flags] = generators.genEslintShortcutsAndOpts(help, flags);
      this.help = help;
      this.flags = flags;
    } else {
      console.log(`${term.error("Cannot call 'eslint -h', install and try again.")}\n`);
    }
    return { help, options, flags, shortcuts };
  }

  /**
   * Runner for 'cds lint' which is a wrapper for eslint cmd calls
   * that detects and adds the required cmd line arguments
   * @param {*} args files/globs for eslint to lint
   * @param {*} options options/flag passed by user
   */
  async lint(args, options) {
    this.eslintCmdOpts = this._sanitizeUserOpts(options);
    this.eslintCmdFileExpr = args.length ? args : ["."];
    if (this.eslintCmdOpts.help) {
      this._printHelp();
    } else {
      // Determine if case "local" or "global" and resolve plugin accordingly
      await this._getConfigFileAndSetProjectPath(args);

      if (this.pluginPath) {
        const overwriteRules = checks.hasEslintConfigContent(this.configContents, "rules");
        // Overwrite rules severities
        if (overwriteRules) {
          await this._overwriteRuleSeverities();
        }

        // Limit to CDS file extensions
        this._addExtensions();
      }

      // Run ESLint with collected options
      try {
        await this._runEslint();
      } catch (err) {
        term.error(err);
      }
    }
  }

  _printHelp() {
    console.log(this.help.replace(/ \*([^*]+)\*/g, ` ${term.codes.bold}$1${term.codes.reset}`));
    return;
  }

  _sanitizeUserOpts(options) {
    for (let key in options) {
      let value = options[key];
      if (value && typeof value === "string") {
        value = value.replace(/'/g, "").replace(/"/g, "");
      }
    }
    return options;
  }

  /**
   * Searches for ESLint config file types (in order or precedence)
   * and returns corresponding directory (usually project's root dir)
   * https://eslint.org/docs/user-guide/configuring#configuration-file-formats
   * @param {string} currentDir start here and search until root dir
   * @returns {string} dir containing ESLint config file (empty if not exists)
   */
  async _getConfigPath(currentDir = ".") {
    const configFiles = [
      ".eslintrc.js",
      ".eslintrc.cjs",
      ".eslintrc.yaml",
      ".eslintrc.yml",
      ".eslintrc.json",
      ".eslintrc",
      "package.json",
    ];
    let configDir = path.resolve(currentDir);
    while (configDir !== path.resolve(configDir, "..")) {
      for (let i = 0; i < configFiles.length; i++) {
        const configPath = path.join(configDir, configFiles[i]);
        if (configFiles[i] !== "package.json" || (
          configFiles[i] === "package.json" && require(configPath).eslintConfig
        )) {
          if (exists(configPath) && await isfile(configPath)) {
            return configPath;
          }
        }
      }
      configDir = path.join(configDir, "..");
    }
    return "";
  }

  _addExtensions() {
    // Add CDS file extensions to lint
    this.fileExtensions = this.pluginApi.getFileExtensions().map((ext) => path.extname(ext));
    // Only lint file extensions prescribed by plugin
    this.ignorePatterns = [];
    this.fileExtensions.forEach((ext) => {
      this.ignorePatterns.push(`!${ext}`);
    });
    return;
  }

  async _runEslint() {
    try {
      const currentDir = process.cwd();

      const { ESLint } = require("eslint");

      let eslintOpts = {
        cwd: currentDir,
        extensions: this.fileExtensions,
        overrideConfig: {
          ...this.configContents,
        },
        useEslintrc: false,
      };

      if (this.lintType === "global") {
        eslintOpts = {
          cwd: process.cwd(),
          extensions: this.fileExtensions,
          overrideConfig: {
            plugins: ["@sap/eslint-plugin-cds"],
            extends: "plugin:@sap/cds/recommended"
          },
          useEslintrc: false,
          resolvePluginsRelativeTo: this.cdsdkPath
        };
      }

      if (this.customRulesOpts && this.customRulesOpts.length > 0) {
        eslintOpts.rulePaths = [this.customRulesOpts]
      }

      LOG_CONFIG && LOG_CONFIG(eslintOpts);

      let lintString = `eslint`;
      if (this.fileExtensions) { lintString += ` --ext "${this.fileExtensions.join(",")}"`}
      for (const ruleOpt of Object.entries(this.ruleOpts)) {
        lintString += ` --rule ${ruleOpt[0]}:${ruleOpt[1]}`;
      }
      if (this.customRulesOpts && this.customRulesOpts.length > 0) {
        lintString += ` --rulesdir "${this.customRulesOpts}"`
      }

      LOG && LOG(lintString);

      if (!process.env.isTest) {
        const eslint = new ESLint(eslintOpts);
        const formatter = await eslint.loadFormatter("stylish");

        let results = (await eslint.lintText("")).map((result) => {
          result.filePath = path.resolve(currentDir);
          return result;
        }).filter(result => result.messages.length > 0);

        const files = await readdir(currentDir);
        const hasFiles = files.some(file => isfile(file));
        if (hasFiles) {
          const resultsModel = await eslint.lintFiles(this.eslintCmdFileExpr);
          results = results.concat(resultsModel);
        }

        if (results && results.length > 0) {
          console.log(formatter.format(results));
        }
      }
    } catch (err) {
      // Report identically to ESLint CLI
      if (typeof err.messageTemplate === "string") {
        try {
          const eslintBase = `${require.resolve('eslint').split('eslint')[0]}/eslint`;
          const template = require(path.join(eslintBase, `messages/${err.messageTemplate}.js`));
          console.log(template(err.messageData || {}));
          exit(1)
        } catch {
            // Ignore template error then fallback to use `error.stack`.
        }
        console.log(err.stack);
     }
      exit(1)
    }
  }

  async _getConfigFileAndSetProjectPath(args) {
    let input;
    // Get config path
    if (args.length > 0) {
      const firstArg = args[0];
      if (firstArg === "." || (isfile(firstArg) || isdir(firstArg))) {
        this.isFile = true;
      }
      input = args.join(" ");
      if (!input) {
        input = ".";
      }
    }
    this.configPath = await this._getConfigPath(process.cwd());
    if (!this.configPath) {
      this.lintType === "global";
      this.configContents = await io.sanitizeEslintConfig({}, false, LOG);
    } else {
      const configContents = await io.readEslintConfig(this.configPath);
      this.configContents = await io.sanitizeEslintConfig(configContents, false, LOG);
      if (this.configContents) {
        if ("extends" in this.configContents) {
          this.extendsPlugin = checks.hasEslintConfigContent(
            this.configContents,
            "extends"
          );
          if (this.extendsPlugin) {
            this.lintType = "local";
            try {
              this.pluginPath = require.resolve("@sap/eslint-plugin-cds", {
                paths: [path.dirname(this.configPath)],
              });
              this.pluginApi = require(this.pluginPath.replace("index.js", "api"));
            } catch (err) {
              // CLI will report (no locally installed plugin)
            }
          }
        }
      }
    }
    if (!this.pluginPath) {
      try {
        this.pluginPath = require.resolve("@sap/eslint-plugin-cds", {
          paths: [this.cdsdkPath],
        });
        this.pluginApi = require(this.pluginPath.replace("index.js", "api"));
      } catch (err) {
        // CLI will report (no globally installed plugin)
      }
    }
    return;
  }

  async _overwriteRuleSeverities() {
    let configContents = {};
    if (this.configPath) {
      configContents = await io.readEslintConfig(this.configPath);
    } else {
      configContents = await io.readEslintConfig(await this._getConfigPath(this.cdsdkPath));
    }
    let rules = configContents.rules;
    // Allow recommended plugin rules in cds-dk to be overwritten
    // by user by adding rule to cmd line (because of precedence)
    const pluginRules = require(this.pluginPath).configs.recommended.rules;
    if (rules && pluginRules) {
      for (const rule of Object.keys(rules)) {
        if (typeof rules[rule] !== "undefined" && rules[rule] != pluginRules[rule] ||
          isfile(path.relative(".", ".eslint", "rules", rule))) {
          pluginRules[rule] = rules[rule];
          this.ruleOpts[rule] = rules[rule];
          this.pluginRules = pluginRules;
        }
      }
    }
    return;
  }
}

module.exports = Linter;
