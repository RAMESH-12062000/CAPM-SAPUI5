const yaml = require('@sap/cds-foss')('yaml');
const { exec } = require('../util/exec');

class KubernetesApiAccessor {

    constructor() {

        this.config = once( async() => {
            const configString = await exec({result: 'stdout'}) `kubectl config view --raw`;
            const config = yaml.parse(configString);

            const currentContextName = config['current-context'];
            if (!currentContextName) throw new Error(`No current context in kubectl config.`);
            const currentContextEntry = config.contexts && config.contexts.find( entry => entry.name === currentContextName && entry.context && entry.context.cluster && entry.context.user );
            if (!currentContextEntry) throw new Error(`Current context not found in kubectl config.`);
            const currentContext = currentContextEntry.context;
            const clusterEntry = config.clusters && config.clusters.find( entry => entry.name === currentContext.cluster && entry.cluster && entry.cluster.server );
            if (!currentContextEntry) throw new Error(`Cluster ${currentContext.cluster} not found in kubectl config.`);
            const { cluster } = clusterEntry;

            const serverToContext = {};
            for (const clusterEntry of config.clusters) {
                const contextEntries = config.contexts.filter( contextEntry => contextEntry.context.cluster === clusterEntry.name );
                // Collect only cluster servers that are used in exactly one context, to clearly identify the context to be used
                if (contextEntries.length === 1) {
                    serverToContext[clusterEntry.cluster.server] = contextEntries[0];
                }
            }

            return {
                namespace: currentContext.namespace || 'default',
                context: currentContextEntry,
                cluster,
                serverToContext
            }
        });
    }

    async context({cluster, namespace}) {
        const config = await this.config();
        let contextEntry;

        if (cluster && cluster !== config.cluster.server) {
            contextEntry = config.serverToContext[cluster] || throwError(`Cluster ${cluster} not found in kubectl configuration`);
        } else {
            contextEntry = config.context;
        }

        return {
            context: contextEntry.name,
            cluster: cluster || config.cluster.server,
            namespace: namespace || contextEntry.context.namespace || 'default'
        };
    }

    async get(options) {
        const {context, namespace, kind, name} = options;

        const result = await exec({stdio: ['ignore', 'pipe', 'ignore'], acceptStatuses: [0, 1]}) `kubectl --output json --context ${context} --namespace ${namespace} get ${kind} ${name}`;
        if (result.status === 0)
            return JSON.parse(result.stdout);
        else
            return null;
    }
}

function once(func) {
    let result;
    return function(...args) {
        if (!result) result = func(...args);
        return result;
    }
}

function throwError(msg = 'Internal Error') {
    throw new Error(msg);
}

module.exports = KubernetesApiAccessor;
