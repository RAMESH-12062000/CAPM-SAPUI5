
const KindToRequiresNameMap = {
    xsuaa: 'auth', // REVISIT: remove with ^8
    'xsuaa-auth': 'auth',
    'ias-auth': 'auth',
    'hana-cloud': 'db',
    hana: 'db',
    'hana-mt': 'db', // For compatibility only
    'sql-mt': 'db', // For compatibility only
    destinations: 'destinations',
    connectivity: 'connectivity',
    'audit-log': 'auditlog',
    'audit-log-to-restv2': 'auditlog',
    'enterprise-messaging': 'messaging',
    'enterprise-messaging-amqp': 'messaging',
    'enterprise-messaging-http': 'messaging',
    'enterprise-messaging-shared': 'messaging',
    'multitenancy': 'multitenancy'
}

const PreferredKinds = {
    multitenancy:1, 'hana-cloud':1, xsuaa:1, 'xsuaa-auth':1, 'ias-auth':1, 'saas-registry':1
};

const PLATFORM_TYPES = {
    'cf': 'Cloud Foundry',
    'k8s': 'Kubernetes'
}

class BindingUtil {
    static getRequiresNameFromKind(service, kind) {
        const requiresName = KindToRequiresNameMap[kind];
        if (!requiresName) throw new Error(`Unknown CDS service name for service "${service}". Please specify as argument for "cds bind".`)
        return requiresName;
    }

    /**
     * Determine kind value for services based on VCAP binding
     * information in the configuration.
     */
    static determineKinds(services) {
        const vcapServices = {}

        // Build VCAP_SERVICES
        for (const service of services) {
            service.kindCandidates = []

            const { vcap = {} } = service.binding || {};
            let { label, type } = vcap;
            type = type || label;
            if (!type) continue;

            if (!vcapServices[type]) vcapServices[type] = [];
            vcapServices[type].push({ credentials: { dummy: 'dummy' }, ...vcap, service });
        }

        // Auto configure services based on VCAP_SERVICES

        const cds = require('../cds');
        const env = cds.env.for('cds', process.cwd()); // REVISIT: This might load cds.env too early!

        if (!env._find_credentials_for_required_service) {
            throw new Error(`Please provide a service kind or update @sap/cds version to use the kind detection.`);
        }

        const requires = env.requires.kinds || {};
        for (const [kind, service] of Object.entries(requires)) {
            const vcapService = env._find_credentials_for_required_service(kind, service, vcapServices);
            if (!vcapService) continue;
            const isUniqueKind = !Object.values(requires).some(otherService =>
                otherService !== service && otherService.kind === kind
            )
            if (isUniqueKind) vcapService.service.kindCandidates.push(kind);
        }

        // Check if one "kind" per service was found
        for (const service of services) {
            const preferredKind = service.kindCandidates.find(kind => kind in PreferredKinds);
            if (preferredKind) {
                service.kind = preferredKind;
            } else if (service.kindCandidates.length === 1) {
                service.kind = service.kindCandidates[0];
            }
            delete service.kindCandidates;
        }
    }

    static async checkIsJavaProject(projectPath) {
        const { constants, promises: fsp } = require('fs');
        const path = require('path');
        const pomXmlPath = path.join(projectPath, 'pom.xml');
        try {
            await fsp.access(pomXmlPath, constants.F_OK);
            return true;
        } catch (err) {
            return false;
        }
    }

    static platformText(binding) {
        if (!PLATFORM_TYPES[binding.type]) throw new Error(`Unexpected binding type "${binding.type}"`);
        return PLATFORM_TYPES[binding.type]
    }

    static bindingText(binding, highlight = t => t) {
        switch (binding.type) {
            case 'cf':
                if (binding.key) {
                    return `managed service ${highlight(binding.instance + ':' + binding.key)}`
                } else {
                    return `user provided service ${highlight(binding.instance)}`
                }
            case 'k8s':
                if (binding.name) {
                    return `service binding ${highlight(binding.name)}`
                } else {
                    return `secret ${highlight(binding.secret)}`
                }
            default:
                throw new Error('Internal Error');
        }
    }

    static logger = { log: console.log }
}

module.exports = BindingUtil
