const cds = require('../cds');

const BindingResolver = require('./bindingResolver');
const { determineKinds, getRequiresNameFromKind, checkIsJavaProject, platformText, bindingText, logger } = require('./bindingUtil');
const { highlight, bold, info } = require('../util/term');


module.exports = { bind, parseProfile }

/**
 * Executes cds build in the directory defined by cds.root.
 *
 * @param {object} options - command options as defined by build command.
 */
async function bind(options) {

    options.for = options.for || 'hybrid';

    let on;
    switch(options.on) {
        case 'k8s':
        case 'kubernetes':
            on = 'k8s';
            break;
        case undefined:
        case null:
        case 'cf':
        case 'cloudfoundry':
            on = 'cf';
            break;
        default:
            throw `Invalid value '${options.on}' for option --on.`;
    }

    const onText = { 'cf': 'Cloud Foundry', 'k8s': 'Kubernetes' }[on];
    if (!options['to-app-services']) logger.log(`Retrieving data from ${onText}...`);
    let resolvedServices

    const targets = options.to.split(/,/g);
    try {
        resolvedServices = await Promise.all(targets.map(async target => {
            let binding;
            if (on === 'k8s') {
                binding = { type: on, name: target };
            } else if (on === 'cf') {
                const [instance, key] = target.split(/:/);
                binding = { type: on, instance, key };
            } else {
                throw new Error('Internal Error');
            }
            const resolvedService = await BindingResolver.resolveBinding(undefined, binding);
            resolvedService._target = target;
            delete resolvedService.credentials;
            resolvedService.binding.resolved = false;
            return resolvedService;
        }));
    } catch (error) {
        if (error.name === 'AxiosError') {
            const errors = error.response?.data?.errors ?? []
            const responseInfo = errors.map(e => `${e.title}: ${e.detail} (${e.code})`).join('  \n')
            const requestInfo = error.request?.path
            throw new Error(`${error.toString()}\nResponse: ${responseInfo}\nRequest:${requestInfo}}`)
        }
        throw error
    }

    if (options.kind) {
        resolvedServices.forEach(service => service.kind = options.kind);
    } else {
        determineKinds(resolvedServices);
    }

    for (const resolvedService of resolvedServices) {
        if (options.serviceArg) {
            resolvedService.name = options.serviceArg;
        } else if (resolvedService.kind) {
            resolvedService.name = getRequiresNameFromKind(resolvedService.binding.instance, resolvedService.kind);
        }

        let { kind, name, binding } = resolvedService;
        name = name ?? `custom-service:${binding.instance || binding.secret}`
        resolvedService.name = resolvedService.name ?? name
        const kindText = kind ? ` with kind ${highlight(kind)}` : ''
        const nameText = highlight(name)

        logger.log(`Binding ${nameText} to ${platformText(binding)} ${bindingText(binding, highlight)}${kindText}`);
    }

    // prepare for different providers
    const userCdsrcJsonStorageProvider = require('./userCdsrcJsonStorageProvider');

    await userCdsrcJsonStorageProvider.storeServices(resolvedServices, {
        ...options
    });

    const isJavaProject = await checkIsJavaProject(cds.root);
    if (!cds.cli.options['to-app-services']) {
        logger.log(`${info('TIP:')} Run with cloud bindings: ${bold(runCmd(options.for, isJavaProject))}`);
    }
}

function runCmd(profile, isJavaProject) {
    profile = parseProfile(profile);
    if (isJavaProject) {
        const p = profile === 'hybrid' ? '' : ` --profile ${profile}`;
        return `cds bind --exec${p} mvn spring-boot:run`;
    } else {
        const p = profile === 'development' ? '' : ` --profile ${profile}`;
        return `cds watch${p}`;
    }
}

function parseProfile(profile) {
    if (!profile) return 'hybrid';
    else if (profile === '-') return 'development';
    else return profile;
}
