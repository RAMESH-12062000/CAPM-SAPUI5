const cds = require('../cds');
const DEBUG = cds.debug('cli')

const cfUtil = require('../util/cf');

const axios = require('axios');
require('../util/axios').pruneErrors();
const { URL } = require('url');
const { bold, highlight } = require('../util/term');

module.exports = new class CFKeyProvider {
    async getCfSpaceInfo() {
        DEBUG?.('getting space info');

        const target = await cfUtil.getCfTarget();
        const authorization = await cfUtil.getCfAuthorization();
        const targetWithAuth = Object.assign({}, target, { authorization });


        const { org, space } = target;
        const orgs = await BatchRequest.req(targetWithAuth, `/v3/organizations?names=${encodeURIComponent(encodeURIComponent(org))}`);
        if (!(orgs && orgs.resources.length === 1)) {
            throw `CF org ${org} not found!`;
        }

        const orgGuid = orgs.resources[0].guid;
        const spaces = await BatchRequest.req(targetWithAuth, `/v3/spaces?names=${encodeURIComponent(encodeURIComponent(space))}&organization_guids=${encodeURIComponent(encodeURIComponent(orgGuid))}`)
        if (!(spaces && spaces.resources.length === 1)) {
            throw `CF space ${space} not found in org ${org}!`;
        }

        const spaceGuid = spaces.resources[0].guid;

        return Object.assign({}, target, { orgGuid, spaceGuid, authorization });
    }

    async init() {
        const target = this.target = await this.getCfSpaceInfo();
        this.getOrg = BatchRequest.create({ target, url: '/v3/organizations' });
        this.getSpace = BatchRequest.create({
            target, url: '/v3/spaces', extractors: {
                organization_guids: resource => resource.relationships.organization.data.guid
            }
        });
        this.getInstance = BatchRequest.create({
            target, url: '/v3/service_instances', extractors: {
                space_guids: resource => resource.relationships.space.data.guid
            }
        });
        this.getKey = BatchRequest.create({
            target, url: '/v3/service_credential_bindings', extractors: {
                service_instance_guids: resource => resource.relationships.service_instance.data.guid
            }
        });
        this.getPlans = BatchRequest.create({ target, url: '/v3/service_plans' });
        this.getOfferings = BatchRequest.create({ target, url: '/v3/service_offerings' });
    }

    async resolve(name, binding) {
        if (!this.initPromise) {
            this.initPromise = this.init();
        }
        await this.initPromise;
        this._checkApiEndpoint(name, binding)

        let { instance, org, space } = binding;
        let spaceGuid;
        if (org && space) {
            // org and space can be overwritten by currently logged in org and space
            const orgObj = await this.getOrg({ names: org });
            const spaceObj = await this.getSpace({ names: space, organization_guids: orgObj.guid });
            spaceGuid = spaceObj.guid;
        } else {
            org = this.target.org;
            space = this.target.space;
            spaceGuid = this.target.spaceGuid;
        }

        let instanceObj;
        try {
            instanceObj = await this.getInstance({ names: instance, space_guids: spaceGuid });
        } catch (error) {
            throw `Service instance "${instance}" not found.`;
        }
        switch (instanceObj.type) {
            case 'managed':
                return this._resolveManagedService(instanceObj, instance, binding.key || `${instance}-key`, org, space);
            case 'user-provided':
                return this._resolveUserProvidedService(instanceObj, instance, org, space);
            default:
                throw `Service type ${instanceObj.type} not supported`;
        }
    }

    async _resolveManagedService(instanceObj, instance, key, org, space) {
        const create = (cds.cli.command === 'bind' || cds.cli.command === 'deploy') && !cds.cli.options['no-create-service-key']
        const silent = (cds.cli.options.json || cds.cli.command === 'env') && !DEBUG
        const credentials = await cfUtil.getOrCreateServiceKey(instanceObj, key, {}, { create, silent });

        if (!credentials) {
            let message = `No service key ${highlight(key)} found for service instance ${highlight(instance)}.\n\n`;
            message += `Use ${bold(`cf create-service-key ${instanceObj.name} ${key} [-c ...]`)} to create the required service key.`;
            throw message;
        }

        const planObj = await this.getPlans({ guids: instanceObj.relationships.service_plan.data.guid });
        const offeringObj = await this.getOfferings({ guids: planObj.relationships.service_offering.data.guid });
        const resolvedBinding = {
            binding: {
                type: "cf",
                apiEndpoint: this.target.apiEndpoint,
                org: org,
                space: space,
                instance: instance,
                key: key,
                vcap: {
                    label: offeringObj.name,
                    plan: planObj.name,
                    tags: offeringObj.tags
                },
                resolved: true,
            },
            credentials
        };

        return resolvedBinding;
    }

    async _resolveUserProvidedService(instanceObj, instance, org, space) {
        const credentialsObj = await BatchRequest.req(this.target, `/v3/service_instances/${encodeURIComponent(instanceObj.guid)}/credentials`);
        const resolvedBinding = {
            binding: {
                type: "cf",
                apiEndpoint: this.target.apiEndpoint,
                org: org,
                space: space,
                instance: instance,
                vcap: {
                    label: instanceObj.type,
                    tags: instanceObj.tags
                },
                resolved: true,
            },
            credentials: credentialsObj
        };
        return resolvedBinding;
    }

    _checkApiEndpoint(name, binding) {
        const { apiEndpoint, key, instance } = binding

        // if no api endpoint is configured the currently logged in endpoint will be used
        if (apiEndpoint && apiEndpoint !== this.target.apiEndpoint) {
            name = `${name || instance}:${key || instance + '-key'}`;
            let message = `Current Cloud Foundry API endpoint ${highlight(this.target.apiEndpoint)} differs from API endpoint ${highlight(apiEndpoint)} for service binding ${highlight(name)}.\n\n`;
            message += `Use ${bold(`cf login -a ${apiEndpoint}`)} to log in to the target API endpoint.`;
            throw message;
        }
    }
}

class BatchRequest {
    constructor({ target, url, extractors = {} }) {
        this.target = target;
        this.url = url;
        this.filters = [];
        this.timeout = undefined;
        this.extractors = Object.assign({ names: resource => resource.name, guids: resource => resource.guid }, extractors);
    }

    static create(options) {
        const obj = new BatchRequest(options);
        return (...args) => obj.request(...args);
    }

    async request(filter) {
        let resolve;
        let reject;
        const promise = new Promise((_resolve, _reject) => {
            resolve = _resolve;
            reject = _reject;
        });
        this.filters.push({ filter, resolve, reject });

        if (this.timeout) clearTimeout(this.timeout);
        this.timeout = setTimeout(() => this.executeRequest(), 0);

        return promise;
    }

    async executeRequest() {
        const filters = this.filters;
        this.filters = [];
        const filterParams = {};
        for (const filter of filters) {
            for (const name of Object.keys(filter.filter)) {
                if (!filterParams[name]) filterParams[name] = [];
                filterParams[name].push(filter.filter[name]);
            }
        }

        const params = Object.keys(filterParams).map(
            name => `${name}=${encodeURIComponent(filterParams[name].map(encodeURIComponent).join(','))}`
        ).join("&");

        const url = this.url + (this.url.match(/\?/) ? '&' : '?') + params;

        let data;
        try {
            data = await this.httpRequest(url);
        } catch (error) {
            for (const filter of filters) {
                filter.reject(error);
            }
            return;
        }
        const fmt = filter => Object.keys(filter).map(key => `${key}: ${filter[key]}`).join(', ');
        const resources = data.resources;
        for (const filter of filters) {
            let filteredResources = resources;
            for (const name of Object.keys(filter.filter)) {
                filteredResources = filteredResources.filter(resource => this.extractors[name](resource) === filter.filter[name]);
            }
            if (filteredResources.length === 1) {
                filter.resolve(filteredResources[0]);
            } else if (filteredResources.length === 0) {
                filter.reject(`Couldn't find resource for url "${this.url}" with filter "${fmt(filter.filter)}"`);
            } else {
                filter.reject(`Found more than one resources for url "${this.url}" with filter "${fmt(filter.filter)}"`);
            }
        }
    }

    async httpRequest(urlPath) {
        return BatchRequest.req(this.target, urlPath);
    }

    static async req(target, urlPath) {
        const url = new URL(urlPath, target.apiEndpoint);
        DEBUG?.(`_req: ${url.toString()}`);
        const result = await axios.get(url.toString(), {
            headers: {
                authorization: target.authorization
            }
        });
        return result.data;
    }
}
