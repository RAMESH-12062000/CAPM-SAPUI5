/**
 * Custom ESLint parser:
 * https://eslint.org/docs/developer-guide/working-with-custom-parsers
 * This file must:
 * - Expose 'parseForESLint' method on the parser which should return the AST,
 *   optional properties services, a scopeManager, and visitorKeys
 * - Expose default method 'parse' which should return the AST
 * Both methods should take in the source code and an optional configuration
 * (parserOptions).
 */
const cds = require('@sap/cds')
const Cache = require('./utils/Cache')
const LOG = cds.debug('lint:plugin')
const colors = require('./utils/Colors')
const { splitDefName } = require('./utils/rules')

module.exports = {
  parse: function (code, options) {
    return module.exports.parseForESLint(code, options).ast
  },
  parseForESLint: function (code) {
    return {
      ast: createProgramAST(code),
      services: {
        getParsedCsn: function () {
          let compiledModel
          let reflectedModel
          const messages = []
          try {
            compiledModel = cds.parse(code)
          } catch (err) {
            // Do nothing
          }
          if (compiledModel) {
            try {
              reflectedModel = cds.linked(compiledModel)
              if (messages) {
                reflectedModel.messages = messages
              }
            } catch (err) {
              LOG && LOG(colors.red + 'ERROR:' + colors.reset, err)
              LOG && LOG('COMPILED', compiledModel)
              LOG && LOG('REFLECTED', reflectedModel)
            }
          }
          return reflectedModel
        },
        getInferredCsn: function () {
          const rootPath = Cache.get('rootpath')
          if (Cache.has('test')) {
            return Cache.get(`model:${rootPath}`)
          }
          let compiledModel
          let reflectedModel
          cds.resolve.cache = {}

          if (!Cache.has(`model:${rootPath}`) && rootPath) {
            const roots = Cache.get(`roots:${rootPath}`)
            const messages = []
            if (roots) {
              try {
                compiledModel = cds.load(roots, {
                  cwd: rootPath,
                  sync: true,
                  locations: true,
                  messages
                })
                Cache.remove('errRootModel')
              } catch (err) {
                Cache.set('errRootModel', err)
              }
              if (compiledModel) {
                reflectedModel = cds.linked(compiledModel)
                Cache.set(`model:${Cache.get('rootpath')}`, reflectedModel)
                if (messages) {
                  reflectedModel.messages = messages
                }
              }
            }
          } else {
            reflectedModel = Cache.get(`model:${rootPath}`)
          }
          return reflectedModel
        },
        updateInferredCsn: compileModelFromDict,
        getEnvironment: function () {
          const options = Cache.get('options')
          return (options && options[0] && options[0].environment) ? options[0].environment : undefined
        },
        getLocation: function (name, obj, model) {
          let loc
          const defaultLoc = {
            start: { line: 0, column: 0 },
            end: { line: 1, column: 0 }
          }
          if (obj.$location) {
            const objLoc = obj.$location
            if (objLoc) {
              // CSN entry with column 0 is equivalent to 'undefined'
              // It means that the column in that line cannot be determined,
              // so we assign a value 1 to get a column location of 0
              if (objLoc.col === 0) {
                objLoc.col = 1
              }
              loc = defaultLoc
              loc.start.column = objLoc.col - 1
              loc.start.line = objLoc.line
              let colLength = name?.length // use length of `name` property
              // TODO bug in reflect? : `annotate` elements have an unusable index-like `name`, e.g. "1"
              if (obj.annotate) colLength = 0
              loc.end.column = objLoc.col - 1 + colLength
              loc.end.line = objLoc.line
            } else if (obj.parent) {
              this.getLocation(name, obj.parent, model)
            }
          }
          // Empty locations default to line 0, column 0
          if (!loc) {
            loc = defaultLoc
          }
          return loc
        },
        getNode: function (obj) {
          let loc
          if (obj) {
            let name = obj.name
            if (['action', 'entity', 'function', 'service'].includes(obj.kind)) {
              name = splitDefName(obj).name
            }
            loc = this.getLocation(name, obj)
          }
          return createProgramAST(code, loc)
        }
      },
      scopeManager: null,
      tokensAndComments: [],
      visitorKeys: []
    }
  },
  createProgramAST,
  compileModelFromDict
}

/**
 * Generates dummy AST with just single Program node
 * @param code Parse file contents
 * @returns AST
 */
function createProgramAST (code, loc) {
  loc = loc || {
    start: {
      line: 1,
      column: 0
    },
    end: {
      line: 1,
      column: 0
    }
  }
  return {
    type: 'Program',
    body: [],
    sourceType: 'module',
    tokens: [],
    comments: [],
    range: [0, code.length],
    loc
  }
}

function compileModelFromDict (dictFiles, options) {
  let reflectedModel
  const messages = []
  const compiledModel = cds.compile(dictFiles, {
    sync: true,
    locations: true,
    messages,
    ...options
  })
  if (compiledModel) {
    reflectedModel = cds.linked(compiledModel)
    if (messages) {
      reflectedModel.messages = messages
    }
  }
  return reflectedModel
}
