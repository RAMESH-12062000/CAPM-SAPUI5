const cds = require('@sap/cds')

/** @type {import('../types').Rule} */

module.exports = {
  meta: {
    schema: [{/* to avoid deprecation warning for ESLint 9 */}],
    docs: {
      description:
        'Ambiguous key with a `TO MANY` relationship since entries could appear multiple times with the same key.',
      category: 'Model Validation',
      recommended: true
    },
    type: 'problem',
    model: 'inferred'
  },
  create (context) {
    return checkAssocs

    function checkAssocs () {
      let csnOdata
      const m = context.getModel()
      if (!m) return
      if (m && m.definitions) {
        csnOdata = cds.compile.for.odata(m)
        const csnOdataLinked = cds.linked(csnOdata)
        associationCardinalityFlaw(csnOdataLinked, context)
      }
    }
  }
}

function associationCardinalityFlaw (csn, context) {
  processEntity(csn, (definition, sourceEntity, sourceAlias) => {
    let refCardinalityMult = false
    let refPlainElement = false
    processElement(
      csn,
      definition,
      sourceEntity,
      sourceAlias,
      () => {
        refCardinalityMult = false
        refPlainElement = false
      },
      (refEntity, refElement) => {
        if (refElement.type === 'cds.Association' || refElement.type === 'cds.Composition') {
          if (refElement.cardinality && refElement.cardinality.max === '*') {
            refCardinalityMult = true
          }
        } else {
          refPlainElement = true
        }
      },
      (column) => {
        if (
          definition.keys &&
          Object.keys(definition.keys).length === 1 &&
          Object.keys(definition.keys)[0] === 'ID' &&
          refCardinalityMult &&
          refPlainElement
        ) {
          const keyName = Object.keys(definition.keys)[0]
          const key = definition.keys[keyName]
          const keyLoc = context.getLocation(keyName, key, csn)
          const colName = column.as ? column.as : column.name
          context.report({
            message: `Ambiguous key in '${definition.name}'. Element '${colName}' leads to multiple entries so that key '${keyName}' is not unique.`,
            loc: keyLoc,
            file: key.$location.file
          })
        }
      }
    )
  })
}

function processEntity (csn, eachCallback) {
  Object.keys(csn.definitions).forEach((name) => {
    if (name.startsWith('localized.')) {
      return
    }
    const definition = csn.definitions[name]
    if (
      definition.kind === 'entity' &&
      definition.query &&
      definition.query.SELECT &&
      definition.query.SELECT.columns
    ) {
      let sourceEntity
      const sourceAlias = []
      if (definition.query.SELECT.from.ref) {
        // From
        sourceEntity = csn.definitions[definition.query.SELECT.from.ref.join('_')]
        sourceAlias.push({
          from: sourceEntity.name,
          as: definition.query.SELECT.from.as || definition.query.SELECT.from.ref.slice(-1)[0].split('.').pop()
        })
      } else if (definition.query.SELECT.from.args && definition.query.SELECT.from.args[0].ref) {
        // Join
        sourceEntity = csn.definitions[definition.query.SELECT.from.args[0].ref.join('_')]
        definition.query.SELECT.from.args.forEach((arg) => {
          sourceAlias.push({
            from: arg.ref.join('_'),
            as: arg.as || arg.ref.slice(-1)[0].split('.').pop()
          })
        })
      }
      if (!sourceEntity) {
        return
      }
      eachCallback(definition, sourceEntity, sourceAlias)
    }
  })
}

function processElement (csn, definition, sourceEntity, sourceAlias, beforeCallback, eachCallback, afterCallback) {
  definition.query.SELECT.columns.forEach((column) => {
    if (column.ref && column.ref.length > 1) {
      let refEntity = sourceEntity
      let refAlias = sourceAlias
      beforeCallback()
      column.ref.forEach((ref) => {
        ref = ref.id || ref
        // Alias
        const matchAlias = refAlias.find((alias) => {
          return alias.as === ref
        })
        let refElement
        if (matchAlias) {
          refEntity = csn.definitions[matchAlias.from]
        } else {
          refElement = refEntity.elements[ref]
          // Mixin
          if (!refElement) {
            refElement = definition.elements[ref]
            if (!refElement && definition.query.SELECT.mixin) {
              refElement = definition.query.SELECT.mixin[ref]
              if (!refElement && definition.query.SELECT.mixin[column.ref[0]]) {
                refElement = definition.query.SELECT.mixin[column.ref[0]]._target.elements[ref]
              }
            }
          }
          eachCallback(refEntity, refElement)
          if (refElement.type === 'cds.Association' || refElement.type === 'cds.Composition') {
            refEntity = csn.definitions[refElement.target]
          }
        }
        refAlias = []
      })
      afterCallback(column)
    }
  })
}
