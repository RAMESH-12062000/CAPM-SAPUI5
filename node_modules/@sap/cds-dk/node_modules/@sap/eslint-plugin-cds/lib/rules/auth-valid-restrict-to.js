const { isEmptyString, isStringInArray, findFuzzy, isEmptyObject } = require('../utils/rules')

const VALID_PSEUDO_ROLES = ['authenticated-user', 'system-user', 'any']

module.exports = {
  meta: {
    schema: [{/* to avoid deprecation warning for ESLint 9 */}],
    docs: {
      description: '`@restrict.to` must have valid values.',
      category: 'Model Validation',
      recommended: true
    },
    hasSuggestions: true,
    messages: {
      InvalidItem: "Invalid item '{{invalid}}'. Did you mean '{{candidates}}'?",
      ReplaceItemWith: "Replace '{{invalid}}' with '{{candidates}}'"
    },
    type: 'problem',
    model: 'inferred'
  },
  create (context) {
    return {
      entity: checkRestrictTo
    }

    function checkRestrictTo (e) {
      const USER_ROLES = []
      const model = context.getModel()

      model.foreach('entity', (e) => {
        if (e['@restrict']) {
          e['@restrict'].forEach((p) => {
            if (p.to) {
              switch (typeof p.to) {
                case 'string':
                  if (p.to !== p.to.toLowerCase() && !USER_ROLES.includes(p.to)) {
                    USER_ROLES.push(p.to)
                  }
                  break
                case 'object':
                  for (const r in p.to) {
                    if (r !== r.toLowerCase() && !USER_ROLES.includes(r)) {
                      USER_ROLES.push(r)
                    }
                  }
              }
            }
          })
        }
      })
      const ROLES = USER_ROLES.concat(VALID_PSEUDO_ROLES)

      if (e['@restrict']) {
        const node = context.getNode(e)
        const file = e.$location.file

        // TODO: For hierachies, check whether service restriction exists
        // const { prefix } = splitDefName(e)
        // const prefixSplit = prefix.split('.')
        // const serviceName = prefixSplit[prefixSplit.length - 1]
        // const services = model.services
        // let grantAllTo;
        // Object.values(services).map((s) => {
        //   if (s.name === serviceName && s['@requires']) {
        //     grantAllTo = s['@requires'];
        //   }
        // })

        for (const entry of e['@restrict']) {
          if (Object.keys(entry).includes('to')) {
            const toValue = entry.to

            switch (typeof toValue) {
              case 'string': {
                if (isEmptyString(toValue)) {
                  context.report({
                    message: `Missing role on ${e.name} for \`@restrict.to\`.`,
                    node,
                    file
                  })
                } else {
                  const isPseudoRole = entry.to && entry.to === entry.to.toLowerCase()
                  if (!isStringInArray(toValue, ROLES, isPseudoRole)) {
                    const candidates = findFuzzy(toValue, ROLES.sort())
                    context.report({
                      messageId: 'InvalidItem',
                      data: { invalid: toValue, candidates },
                      node,
                      file
                    })
                  }
                }
                break
              }

              case 'object':
                if (isEmptyObject(toValue)) {
                  context.report({
                    message: `Missing roles on ${e.name} for \`@restrict.to\`.`,
                    node,
                    file
                  })
                } else {
                  // If values contain 'any', 'any' only is enough
                  if (toValue.length > 1 && toValue.includes('any')) {
                    context.report({
                      messageId: 'InvalidItem',
                      data: { invalid: `[${toValue}]`, candidates: ['["any"]'] },
                      node,
                      file
                    })
                  }
                  toValue.forEach((value) => {
                    if (!ROLES.includes(value)) {
                      const candidates = findFuzzy(value, ROLES.sort(), undefined, false, 2)
                      if (candidates.length > 0) {
                        context.report({
                          messageId: 'InvalidItem',
                          data: { invalid: value, candidates },
                          node,
                          file
                        })
                      }
                    }
                  })
                }
                break
            }
          }
        }
      }
    }
  }
}
