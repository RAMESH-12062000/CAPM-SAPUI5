const fs = require('fs')
const path = require('path')

const { RuleTester } = require('eslint')
const Cache = require('./Cache')
const createRule = require('./createRule')
const isConfiguredFileType = require('./isConfiguredFileType')
const { compileModelFromDict } = require('../parser')

/**
 * ESLint RuleTester (used by custom rule creator api)
 * Calls ESLint's RuleTester with custom cds parser and input for
 * valid/invalid checks:
 * Model checks require input 'code' entries
 * Env checks require input 'options' with selected parameters
 * @param { CDSRuleTestOpts } options RuleTester input options
 * @returns RuleTester results
 */
module.exports = (options) => {
  let parser
  let rule = {}
  Cache.set('rules', require(path.join(__dirname, '../rules')))
  const rulename = path.basename(options.root)
  if (options.root.startsWith(path.resolve(__dirname, '../..'))) {
    // For plugin's internal tests, resolve parser from here
    parser = require.resolve('../parser')
    const pluginPath = path.join(path.dirname(options.root), '../..')
    rule = createRule(require(`../rules/${path.basename(options.root)}`))
    Cache.set('pluginpath', pluginPath)
  } else {
    // Otherwise from project root
    const resolvedPlugin = require.resolve('@sap/eslint-plugin-cds', {
      paths: [options.root]
    })
    parser = path.join(path.dirname(resolvedPlugin), 'parser')
    rule = require(path.join(options.root, `../../rules/${path.basename(options.root)}`))
    const pluginPath = path.join(path.dirname(options.root), '../../..')
    Cache.set('pluginpath', pluginPath)
  }
  let tester = new RuleTester({})
  if (parser) {
    tester = new RuleTester({ parser })
  }
  const testerCases = {};
  ['valid', 'invalid'].forEach((type) => {
    const filePath = path.join(options.root, `${type}/${options.filename}`)
    Cache.set('rootpath', path.dirname(filePath))
    _initModelRuleTester(filePath, rule.meta?.model)
    testerCases[type] = [
      {
        filename: filePath
      }
    ]
    if (!isConfiguredFileType(options.filename, 'FILES')) {
      const fileContents = JSON.parse(fs.readFileSync(filePath, 'utf8'))
      testerCases[type][0].code = ''
      testerCases[type][0].filename = '<text>'
      testerCases[type][0].options = [{ environment: fileContents }]
    } else {
      testerCases[type][0].code = fs.readFileSync(filePath, 'utf8')
      if (options.options) {
        testerCases[type][0].options = options.options
      }
    }
    if (type === 'invalid') {
      testerCases[type][0].errors = options.errors
      const fileFixed = path.join(options.root, `fixed/${options.filename}`)
      if (fs.existsSync(fileFixed) && rule.meta.type !== 'suggestion') {
        testerCases[type][0].output = fs.readFileSync(fileFixed, 'utf8')
      }
    }
  })
  if (Cache.get('testerCases')) {
    Cache.set(`testerCases:${rulename}`, testerCases)
  }
  return tester.run(rulename, rule, testerCases)
}

/**
 * Creates a model for ESLint unit tests
 */
function _initModelRuleTester (filePath, flavor) {
  Cache.set('test', true)
  const rootPath = path.dirname(filePath)
  Cache.set('rootpath', rootPath)
  if (flavor !== 'none') { // not for env rules
    const files = fs.readdirSync(rootPath)
    const modelfiles = files.map((f) => path.join(rootPath, f)).filter((fp) => isConfiguredFileType(fp, 'MODEL_FILES'))
    Cache.set(`modelfiles:${rootPath}`, modelfiles)
    const dictFiles = _getDictFiles(rootPath, modelfiles)
    Cache.set(`dictfiles:${rootPath}`, dictFiles)
    const reflectedModel = compileModelFromDict(dictFiles, { flavor })
    Cache.set(`model:${rootPath}`, reflectedModel)
  }
}

/**
   * Creates or updates a dictionary of files/file contents for a given
   * project path.
   * @param input
   * @param files
   * @returns dictFiles
   */
function _getDictFiles (input, files) {
  let dictFiles = {}
  if (Cache.has(`dictfiles:${input}`)) {
    dictFiles = Cache.get(`dictfiles:${input}`)
  } else {
    files.forEach((file) => {
      dictFiles[file] = Cache.has(`file:${file}`)
        ? Cache.get(`file:${file}`)
        : fs.readFileSync(file, 'utf8')
    })
  }
  return dictFiles
}
