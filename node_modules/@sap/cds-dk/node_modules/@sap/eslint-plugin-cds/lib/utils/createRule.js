/**
 * Wrapper for ESLint's Rule creator:
 * https://eslint.org/docs/developer-guide/working-with-rules
 * - Must follow the ESLint prescribed convention for all rule exports
 * - ESLint uses 'create' function to traverse its AST nodes
 * - Since we do not work with an AST for cds models, a dummy 'Programm' node is used as an entry point
 * - More eslint-like API
 * - More convenience for error reports
 * @param {CDSRuleSpec} spec
 * @returns {RuleModule}
 */

const { SourceCode } = require('eslint')
const fs = require('fs')
const path = require('path')
const Cache = require('./Cache')
const constants = require('../constants')
const isConfiguredFileType = require('./isConfiguredFileType')
const getProjectRootPath = require('./getProjectRootPath')
const cds = require('@sap/cds')
const { exit } = require('process')
const LOG = cds.debug('lint:plugin')
let filePrev = ''

const REGEX_COMMENT_START = '(/\\*|(.+)?//)(\\s?)+eslint-'
const REGEX_COMMENTS = `${REGEX_COMMENT_START}(enable|disable)(-next)?(-line)?(.+)?`

module.exports = (spec) => {
  let { meta, create } = spec
  meta = setMetaDefaults(meta)

  return {
    meta,
    create: (context) => {
      // do a fast check to exclude most cases, i.e. irrelevant files
      const isRelevant =
        context.getSourceCode().lines[0] === '' || // env. rules
        isConfiguredFileType(context.getFilename(), 'FILES') // file rules
      if (!isRelevant) {
        return {}
      }

      return {
        Program: (node) => {
          try {
            const file = context.getFilename()
            if (file !== filePrev) {
              LOG && LOG(`File: ${context.getFilename()}`)
            }
            const cdscontext = extendContext(node, context, meta)
            Cache.set('context', cdscontext)
            const { isTest, isValidFile, doEnvironmentChecks, doRootModelChecks } = checkEntryCriteria(meta, cdscontext)
            switch (meta.model) {
              case 'none':
                if (doEnvironmentChecks) {
                  if (isTest || !Cache.has(`rule:${cdscontext.id}`)) {
                    LOG && LOG(`  Model: "${meta.model}" Rule: ${context.id}`)
                    Cache.set(`rule:${cdscontext.id}:${Cache.get('rootpath')}`, 'done')
                    createReport(node, cdscontext, meta, create)
                  }
                }
                break

              case 'inferred':
                if (isValidFile && doRootModelChecks) {
                  if (isTest || !Cache.has(`rule:${cdscontext.id}:${Cache.get('rootpath')}`)) {
                    LOG && LOG(`  Model: "${meta.model}" Rule: ${context.id}`)
                    Cache.set(`rule:${cdscontext.id}:${Cache.get('rootpath')}`, 'done')
                    createReport(node, cdscontext, meta, create)
                  } else {
                    if (Cache.has(`report:${context.getFilename()}:${context.id}`)) {
                      const reports = Cache.get(`report:${context.getFilename()}:${context.id}`)
                      for (const r of Array.from(reports)) {
                        context.report(JSON.parse(r))
                      }
                      Cache.remove(`report:${context.getFilename()}:${context.id}`)
                      Cache.set(`rule:${cdscontext.id}:${Cache.get('rootpath')}`, 'done')
                    }
                  }
                }
                break

              default:
                if (isValidFile) {
                  LOG && LOG(`  Model: "${meta.model}" Rule: ${context.id}`)
                  createReport(node, cdscontext, meta, create)
                }
                break
            }
            filePrev = file
          } catch (err) {
            console.error(err)
          }
        }
      }
    }
  }
}

function isRunningWithCDSLint () {
  return process.argv[0].endsWith('node') && process.argv[1].endsWith('cds') && process.argv[2] === 'lint'
}

function isRunningWithESLint () {
  return process.argv[0].endsWith('node') && process.argv[1].endsWith('eslint')
}

function checkEntryCriteria (meta, cdscontext) {
  const isTest = Cache.has('test')
  const hasProjectRoots = Cache.has(`roots:${Cache.get('rootpath')}`)
  const isValidFile = isConfiguredFileType(cdscontext.getFilename(), 'FILES')
  const doRootModelChecks = isTest || (hasProjectRoots && (isRunningWithCDSLint() || isRunningWithESLint() || cdscontext.options.includes('show')))
  // Also lint empty folders (i.e. lintText "" API)
  const doEnvironmentChecks =
    isTest || (hasProjectRoots && isRunningWithCDSLint() && cdscontext.getSourceCode().lines[0] === '')
  return { isTest, isValidFile, doRootModelChecks, doEnvironmentChecks }
}

function setMetaDefaults (meta) {
  if (!meta.severity) meta.severity = constants.DEFAULT_RULE_SEVERITY
  if (meta.docs && !meta.docs.category) meta.docs.category = constants.DEFAULT_RULE_CATEGORY
  if (!meta.model) meta.model = 'parsed'
  return meta
}

/**
 * Get report descriptors from created rules. These can take varios forms,
 * from minimal return, up to fully defined ESLint report descriptors values,
 * with or without visitor keys:
 * - String is interpreted as the 'message' property
 * - Object with known CDS Visitor keys and ESLint report descriptor values
 * - Object with ESLint report dedscriptor keys/ values
 * @param {*} cdscontext
 * @param {*} create
 * @returns
 */
function createReport (node, cdscontext, meta, create) {
  const handlers = create(cdscontext)
  /**
   * TODO: Can these be rewritten to have a visitor? Note, that so far,
   * rules without a visitor cannot use eslint disable comments
   * A rule have no visitors and just return a single check:
   *  - Model Validation rules which have no well-defined CSN entry point
   *  - Environment rules
   */
  switch (typeof handlers) {
    case 'function':
      handlers()
      break

    case 'object': {
      if (meta.model !== 'none') {
        const model = cdscontext.getModel()

        if (model) {
          model.forall((d) => {
            d = (meta.model === 'inferred') ? sanitizeFileLocation(d) : d
            const isValidLocation = (meta.model === 'parsed' && d.$location) ||
              (meta.model === 'inferred' && d.$location?.file)
            Object.entries(handlers)
              .filter(([type, lazy]) => d.is(type) && isValidLocation)
              .forEach(([lazy, handler]) => {
                try {
                  handler(d)
                } catch (err) {
                  console.log(`Error in rule "${cdscontext.id}" at ${d.name}`, err)
                }
              })
          })
        }
      }
      break
    }
  }
}

function sanitizeFileLocation (d) {
  let parent = d
  while (!parent.$location && parent.parent && !parent.parent.definitions) parent = d.parent
  if (parent.$location) d.$location = parent.$location
  return d
}

function extendContext (node, context, meta) {
  if (!Cache.has('test')) {
    const filePath = context.getFilename()
    const rootPath = filePath && fs.existsSync(filePath) ? getProjectRootPath(filePath) : ''
    if (rootPath) {
      Cache.set('rootpath', rootPath)
    }
  }

  const reportWrapper = (r) => {
    const line = r.loc ? r.loc.start.line : r.node.loc.start.line
    if (!isRuleDisabled(line, context)) {
      if (meta.model === 'inferred') {
        if (!r.file) {
          console.error(`Rule ${context.id} must return a "file" property in the rule report!`)
          exit(1)
        }
        const file = Cache.get('rootpath') ? resolveFilePath(r.file) : r.file
        if (cdscontext.getFilename() === file) {
          delete r.file
          context.report(r)
        }
        if (r.file) {
          cacheReport(r, file, context, meta)
        }
      } else {
        context.report(r)
      }
    }
  }

  const descriptors = Object.getOwnPropertyDescriptors(context)
  descriptors.report = {
    value: reportWrapper,
    writable: false,
    enumerable: true,
    configurable: false
  }

  const cdscontext = Object.create(Object.getPrototypeOf(context), descriptors)
  const { parserServices } = context.sourceCode || context
  cdscontext.getModel =
    meta.model === 'inferred' ? parserServices.getInferredCsn : parserServices.getParsedCsn
  cdscontext.getEnvironment = () => {
    const options = context.options
    return options && options[0] && options[0].environment ? options[0].environment : undefined
  }
  cdscontext.getLocation = parserServices.getLocation
  cdscontext.getNode = Object.keys(parserServices).length > 0 ? parserServices.getNode : () => node
  return cdscontext
}

function isRuleDisabled (line, cdscontext) {
  let isDisabled = false
  if (cdscontext) {
    const sourcecode = cdscontext.getSourceCode()
    const rulesDisabled = getDisabled(sourcecode.getText(), sourcecode, line)
    const id = cdscontext.id
    isDisabled = line && id in rulesDisabled && rulesDisabled[id] === 'off'
  }
  return isDisabled
}

function cacheReport (r, file, context, meta) {
  delete r.file
  if (r.node && r.node.range) {
    r.node.range = []
  }
  if (r.messageId) {
    r.message = meta.messages[r.messageId]
    delete r.message
  }
  if (r) {
    let reports = new Set()
    if (Cache.has(`report:${file}:${context.id}`)) {
      reports = Cache.get(`report:${file}:${context.id}`)
    }
    reports.add(JSON.stringify(r))
    Cache.set(`report:${file}:${context.id}`, reports)
  }
}

function getDisabled (code, sourcecode, line) {
  const listDisabled = []
  const rules = Cache.get('rules')
  const rulesDisabled = Object.keys(rules).reduce((o, key) => ({ ...o, [key]: 'on' }), {})
  let matches = []
  if (code) {
    matches = [...code.matchAll(REGEX_COMMENTS)]
    if (matches.length > 0) {
      matches.forEach((match) => {
        if (match) {
          const index = match.index
          match = match[0]
          if (match.includes('*/')) {
            match = match.split('*/')[0].replace('/*', '')
          } else if (match.includes('//')) {
            match = match.split('//')[1]
          }
          if (match) {
            match = match.trim()
          }
          ['disable', 'enable'].forEach((keyword) => {
            const loc = sourcecode.getLocFromIndex(index)
            const disableType = match.split(' ')[0]
            let disableRules = match.split(`${disableType} `)[1]
            disableRules = disableRules
              ? disableRules.split(',').map((rule) => rule.trim())
              : Object.keys(rules).map((rule) => `@sap/cds/${rule}`)
            let comment = {}
            if ([`eslint-${keyword}`, `eslint-${keyword}-line`, `eslint-${keyword}-next-line`].includes(disableType)) {
              comment = disableType.includes('-next-line')
                ? {
                    lineComment: loc.line,
                    lineDisabled: loc.line + 1,
                    rules: disableRules,
                    type: keyword
                  }
                : {
                    lineComment: loc.line,
                    lineDisabled: loc.line,
                    rules: disableRules,
                    type: keyword
                  }
              if (!disableType.includes('-line')) {
                comment.lineDisabled = 'EOF'
              }
            }
            listDisabled.push(comment)
          })
        }
      })
      for (const el of listDisabled.filter(
        (d) => d.lineComment > line && (d.lineDisabled === 'EOF' || d.lineDisabled === line)
      )) {
        if (el.lineDisabled === 'EOF') {
          el.lineDisabled = getLastLine(code)
        }
        if (el.rules) {
          el.rules.forEach((rule) => {
            if (el.type === 'disable') {
              rulesDisabled[rule] = 'off'
            } else if (el.type === 'enable') {
              rulesDisabled[rule] = 'on'
            }
          })
        }
      }
    }
  }
  return rulesDisabled
}

function getLastLine (code) {
  const lines = typeof code === 'string' ? SourceCode.splitLines(code) : code
  return lines.length - 1
}

function resolveFilePath (file) {
  return path.isAbsolute(file) ? file : path.join(Cache.get('rootpath'), file)
}
