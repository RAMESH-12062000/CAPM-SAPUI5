const cds = require('../../../')
const { INSERT, UPDATE } = cds.ql

const { toODataResult, postProcess } = require('../utils/result')
const { getKeysAndParamsFromPath, handleSapMessages } = require('../utils')
const { deepCopy } = require('../../_runtime/common/utils/copy')

// REVISIT: move to or rewrite in libx/odata
const { readAfterWrite } = require('../../_runtime/cds-services/adapter/odata-v4/utils/readAfterWrite')
const metaInfo = require('../../_runtime/cds-services/adapter/odata-v4/utils/metaInfo')

const _isUpsertAllowed = ({ target, data, event }) => {
  return (
    !(cds.env.runtime && cds.env.runtime.allow_upsert === false) &&
    !(target && target._isDraftEnabled && (!cds.env.fiori.lean_draft || (!data.IsActiveEntity && event === 'PATCH')))
  )
}

const _isNavigationWithKeyInParent = (keys, data, pathExpression, model) => {
  // keys not in data
  if (keys && Object.keys(keys).some(key => key in data)) {
    return false
  }

  const nav = pathExpression.ref && pathExpression.ref.length !== 0 && pathExpression.ref[1]
  const parent = pathExpression.ref && pathExpression.ref[0].id

  // not a navigation
  if (!parent || !nav) {
    return false
  }

  const navID = typeof nav === 'string' ? nav : nav.id
  const navElement = model.definitions[parent].elements[navID]

  // not a containment
  if (!navElement._isContained) {
    return false
  }

  const where = pathExpression.ref[0].where
  return parent && navElement && where
}

module.exports = srv =>
  function update(req, res, next) {
    // REVISIT: better solution for _propertyAccess
    const {
      SELECT: { one, from },
      target,
      _propertyAccess
    } = req._query

    // REVISIT: patch on collection is allowed in odata 4.01
    if (!one) {
      // REVISIT: don't use "ENTITY.COLLECTION" as that's an okra term
      throw Object.assign(new Error(`Method ${req.method} not allowed for ENTITY.COLLECTION`), {
        statusCode: 405
      })
    }

    if (_propertyAccess && req.method === 'PATCH') {
      throw Object.assign(new Error(`Method ${req.method} not allowed for PRIMITIVE.PROPERTY`), {
        statusCode: 405
      })
    }

    // payload & params
    let data = _propertyAccess ? { [_propertyAccess]: req.body.value } : deepCopy(req.body)
    const { keys, params } = getKeysAndParamsFromPath(from, srv)
    // add keys from url into payload (overwriting if already present)
    if (!_propertyAccess) Object.assign(data, keys)

    // assert payload
    if (!_propertyAccess) {
      // assert complex
      const assertOptions = { filter: true, http: { req }, mandatories: req.method === 'PUT' || undefined }
      const errs = cds.assert(data, target, assertOptions)
      if (errs) {
        if (errs.length === 1) throw errs[0]
        throw Object.assign(new Error('MULTIPLE_ERRORS'), { statusCode: 400, details: errs })
      }
    } else {
      // TODO: assert primitive
    }

    // query
    let query = UPDATE.entity(from).with(data)

    // we need a cds.Request for multiple reasons, incl. params, headers, sap-messages, read after write, ...
    let cdsReq = new cds.Request({ query, params, req, res })
    Object.defineProperty(cdsReq, 'protocol', { value: 'odata-v4' })

    let crudEvent = 'UPDATE'

    // REVISIT: adjust in getter?
    if (req.method === 'PUT') cdsReq.method = 'PUT'

    // rewrite event for draft-enabled entities
    if (target._isDraftEnabled) cdsReq.event = 'PATCH'

    // REVISIT: only via srv.run in combination with srv.dispatch inside
    //          we automatically either use a single auto-managed tx for the req (i.e., insert and read after write in same tx)
    //          or the auto-managed tx opened for the respective atomicity group, if exists
    return srv
      .run(() => {
        return srv
          .dispatch(cdsReq)
          .catch(async e => {
            // if no UPSERT is allowed, continue with error
            const is404 = e.code === 404 || e.status === 404 || e.statusCode === 404

            const isForcedInsert =
              (e.code === 412 || e.status === 412 || e.statusCode === 412) && req.headers['if-none-match'] === '*'

            if (
              _propertyAccess ||
              !((is404 || isForcedInsert) && _isUpsertAllowed({ target, data, event: req.method }))
            ) {
              throw e
            }

            // PUT / PATCH with if-match header means "only if already exists" -> no insert if it does not
            if (req.headers['if-match']) throw Object.assign(new Error('412'), { statusCode: 412 })

            // check only works with req.body and not with updateDate
            if (_isNavigationWithKeyInParent(target.keys, req.body, from, srv.model)) {
              // REVISIT: better error message
              throw Object.assign(new Error('Unprocessable Content'), { statusCode: 422 })
            }

            // REVISIT:
            //   can we somehow "replay" the request with POST?
            //   or should we call the create handler directly?

            // payload & params
            data = deepCopy(req.body)
            // add keys from url into payload (overwriting if already present)
            Object.assign(data, keys)

            // assert payload
            const assertOptions = { filter: true, http: { req }, mandatories: true }
            const errs = cds.assert(data, target, assertOptions)
            if (errs) {
              if (errs.length === 1) throw errs[0]
              throw Object.assign(new Error('MULTIPLE_ERRORS'), { statusCode: 400, details: errs })
            }

            crudEvent = 'CREATE'

            // query
            // REVISIT: up_XX needs to be looked up -> composition of aspect
            query = INSERT.into(from).entries(data)

            // we need a cds.Request for multiple reasons, incl. params, headers, sap-messages, read after write, ...
            cdsReq = new cds.Request({ query: query, params, req, res })

            return srv.dispatch(cdsReq)
          })
          .then(result => {
            // REVISIT: not great, but avoids try catch in catch callback above
            if (result.constructor.name === 'ServerResponse') return
            handleSapMessages(cdsReq, req, res)

            // TODO: any other checks needed?
            if (cdsReq._.readAfterWrite && !(_propertyAccess && !target._etag))
              return readAfterWrite(cdsReq, srv, { operation: { result } })

            return result
          })
      })
      .then(result => {
        // we use an extra then block, after getting the result, so the transaction is commited, before sending the response

        // REVISIT: metaInfo needs original query in case of property access, but why?
        const info = metaInfo(_propertyAccess ? req._query : query, crudEvent, srv, result, req)

        if (result == null) return res.sendStatus(204)

        const isMinimal = req._preferReturn === 'minimal'
        postProcess(cdsReq.target, srv, result, isMinimal)
        if (result['$etag']) res.set('etag', result['$etag'])

        if (crudEvent === 'CREATE') {
          // UPSERT
          return res
            .set('Content-Type', 'application/json;IEEE754Compatible=true')
            .status(201)
            .send(toODataResult(result, info))
        }

        if (isMinimal || (query._propertyAccess && result[query._propertyAccess] == null) || info.metadata.isStream) {
          return res.sendStatus(204)
        }

        result = toODataResult(result, info)

        return res.set('Content-Type', 'application/json;IEEE754Compatible=true').send(result)
      })
      .catch(next)
  }
