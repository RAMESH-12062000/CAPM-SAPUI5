const cds = require('../../../')

const { toODataResult, postProcess } = require('../utils/result')
const { cds2edm, calculateLocationHeader, getKeysAndParamsFromPath, handleSapMessages } = require('../utils')

const { deepCopy } = require('../../_runtime/common/utils/copy')

// REVISIT: move to or rewrite in libx/odata
const { readAfterWrite } = require('../../_runtime/cds-services/adapter/odata-v4/utils/readAfterWrite')
const metaInfo = require('../../_runtime/cds-services/adapter/odata-v4/utils/metaInfo')

const DRAFT_EVENTS = { draftActivate: 1, EDIT: 1, draftPrepare: 1 }

module.exports = srv =>
  function operation(req, res, next) {
    let { operation, args } = req._query.SELECT?.from.ref?.slice(-1)[0] || {}
    if (!operation) return next() //> create or read

    // unbound vs. bound
    let entity, /* keys, */ params
    if (srv.model.definitions[operation]) {
      operation = srv.model.definitions[operation]
    } else {
      req._query.SELECT.from.ref.pop()
      let cur = { elements: srv.model.definitions }
      for (const each of req._query.SELECT.from.ref) {
        cur = cur.elements[each.id || each]
        if (cur._target) cur = cur._target
      }
      operation = cur.actions[operation]
      entity = cur
      const keysAndParams = getKeysAndParamsFromPath(req._query.SELECT.from, srv)
      params = keysAndParams.params
    }

    // payload & params
    const data = args || deepCopy(req.body)

    // assert payload
    const assertOptions = { filter: true, http: { req }, mandatories: true }
    const errs = cds.assert(data, operation, assertOptions)
    if (errs) {
      if (errs.length === 1) throw errs[0]
      throw Object.assign(new Error('MULTIPLE_ERRORS'), { statusCode: 400, details: errs })
    }

    // event
    // REVISIT: when is operation.name actually prefixed with the service name?
    let event = operation.name.replace(`${srv.name}.`, '')
    // REVISIT: rewrite draft event -> do centrally in draft impl
    if (event === 'draftEdit') event = 'EDIT'

    const query = entity ? req._query : undefined

    // we need a cds.Request for multiple reasons, incl. params, headers, sap-messages, read after write, ...
    const cdsReq = new cds.Request({ query, event, data, params, target: query?.target, req, res })
    Object.defineProperty(cdsReq, 'protocol', { value: 'odata-v4' })

    // REVISIT: only via srv.run in combination with srv.dispatch inside
    //          we automatically either use a single auto-managed tx for the req (i.e., insert and read after write in same tx)
    //          or the auto-managed tx opened for the respective atomicity group, if exists
    return srv
      .run(() => {
        return srv.dispatch(cdsReq).then(result => {
          handleSapMessages(cdsReq, req, res)

          // FIXME: should be handled in draft impl
          if (event in /* { draftActivate: 1, EDIT: 1 } */ DRAFT_EVENTS /* && cdsReq._.readAfterWrite */) {
            let columns
            const queryOptions = req.url.split('?')[1]
            if (queryOptions) columns = cds.odata.parse(`/X?${queryOptions}`).SELECT.columns
            return readAfterWrite(cdsReq, srv, { operation: { result, returnType: operation.returns }, columns })
          }

          return result
        })
      })
      .then(result => {
        // we use an extra then block, after getting the result, so the transaction is commited, before sending the response
        if (!operation.returns || result == null) return res.status(204).end()

        if (operation.returns._type?.match?.(/^cds\./)) {
          // TODO: check result type
          return res.set('Content-Type', 'application/json;IEEE754Compatible=true').send({
            '@odata.context': `${entity ? '../' : ''}$metadata#${cds2edm[operation.returns._type]}`,
            value: result
          })
        }

        const info = metaInfo(req._query, event, srv, result, req)

        // FIXME: info.metadata.isCollection and contextUrl are incorrect for draft events
        if (event in /* { draftActivate: 1, EDIT: 1 } */ DRAFT_EVENTS) {
          info.metadata.isCollection = false
          info.metadata.contextUrl += '/$entity'
        }

        // FIXME: info.metadata.isCollection is incorrect
        if (!operation.returns.items) info.metadata.isCollection = false

        if (info.metadata.returnType) {
          postProcess(info.metadata.returnType, srv, result)
          if (result['$etag']) res.set('etag', result['$etag'])
        }

        result = toODataResult(result, info)

        // FIXME: draftActivate needs location header -> move to draft impl
        // FIXME: draftActivate needs HasActiveEntity and HasDraftEntity -> move to draft impl
        if (event in /* { draftActivate: 1, EDIT: 1 } */ DRAFT_EVENTS) {
          res.set('location', '../' + calculateLocationHeader(cdsReq.target, srv, result))
          result.HasDraftEntity = false
          if (event === 'draftActivate' || event === 'draftPrepare') result.HasActiveEntity = false
        }

        // // FIXME: draftEdit needs HasDraftEntity -> move to draft impl
        // if (event === 'EDIT') result.HasDraftEntity = false

        // FIXME: toODataResult() doesn't seem to handle this case
        if (entity && !result['@odata.context'].match(/^\.\.\//))
          result['@odata.context'] = '../' + result['@odata.context']

        res.set('Content-Type', 'application/json;IEEE754Compatible=true').send(result)
      })
      .catch(next)
  }
