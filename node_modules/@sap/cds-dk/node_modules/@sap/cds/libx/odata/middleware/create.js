const cds = require('../../../')
const { INSERT } = cds.ql

const { toODataResult, postProcess } = require('../utils/result')
const { calculateLocationHeader, getKeysAndParamsFromPath, handleSapMessages } = require('../utils')

const { deepCopy } = require('../../_runtime/common/utils/copy')

// REVISIT: move to or rewrite in libx/odata
const { readAfterWrite } = require('../../_runtime/cds-services/adapter/odata-v4/utils/readAfterWrite')
const metaInfo = require('../../_runtime/cds-services/adapter/odata-v4/utils/metaInfo')

module.exports = srv =>
  function create(req, res, next) {
    const {
      SELECT: { one, from },
      target
    } = req._query

    if (one) {
      // REVISIT: don't use "SINGLETON" or "ENTITY" as that are okra terms
      throw Object.assign(
        new Error(`Method ${req.method} not allowed for ${target._isSingleton ? 'SINGLETON' : 'ENTITY'}`),
        { statusCode: 405 }
      )
    }

    // payload & params
    const data = deepCopy(req.body)
    const { keys, params } = getKeysAndParamsFromPath(from, srv)
    // add keys from url into payload (overwriting if already present)
    Object.assign(data, keys)

    // assert payload
    const assertOptions = { filter: true, http: { req }, mandatories: true }
    const errs = cds.assert(data, target, assertOptions)
    if (errs) {
      if (errs.length === 1) throw errs[0]
      throw Object.assign(new Error('MULTIPLE_ERRORS'), { statusCode: 400, details: errs })
    }

    // query
    const query = INSERT.into(from).entries(data)

    // we need a cds.Request for multiple reasons, incl. params, headers, sap-messages, read after write, ...
    const cdsReq = new cds.Request({ query, params, req, res })
    Object.defineProperty(cdsReq, 'protocol', { value: 'odata-v4' })

    // rewrite event for draft-enabled entities
    if (target._isDraftEnabled) cdsReq.event = 'NEW'

    // REVISIT: only via srv.run in combination with srv.dispatch inside
    //          we automatically either use a single auto-managed tx for the req (i.e., insert and read after write in same tx)
    //          or the auto-managed tx opened for the respective atomicity group, if exists
    return srv
      .run(() => {
        return srv.dispatch(cdsReq).then(result => {
          handleSapMessages(cdsReq, req, res)

          if (cdsReq._.readAfterWrite) {
            return readAfterWrite(cdsReq, srv, { operation: { result } })
          }

          return result
        })
      })
      .then(result => {
        // we use an extra then block, after getting the result, so the transaction is commited, before sending the response
        if (result == null) return res.sendStatus(204)
        const isMinimal = req._preferReturn === 'minimal'
        postProcess(cdsReq.target, srv, result, isMinimal)
        if (result['$etag']) res.set('etag', result['$etag'])
        res.set('location', calculateLocationHeader(cdsReq.target, srv, result))
        if (isMinimal) return res.sendStatus(204)
        const info = metaInfo(query, 'CREATE', srv, result, req)
        result = toODataResult(result, info)
        res.status(201).set('Content-Type', 'application/json;IEEE754Compatible=true').send(result)
      })
      .catch(next) // should be outside, so tx can be rolled back in case of errors
  }
