const LOG = cds.log('mtx')
const { promisify } = require('util')

// REVISIT: eliminate usage of these helpers
const { ensureNoDraftsSuffix } = require('@sap/cds/libx/_runtime/common/utils/draft')
const { ensureUnlocalized } = require('@sap/cds/libx/_runtime/fiori/utils/handler')

const EXT_BACK_PACK = 'extensions__'

const getTargetRead = req => {
  let name = ''
  if (req.query.SELECT.from.join && req.query.SELECT.from.args) {
    // join
    name = req.query.SELECT.from.args.find(arg => arg.ref && arg.ref[0] !== 'DRAFT.DraftAdministrativeData').ref[0]
  } else if (req.target.name.SET) {
    // union
    name = req.target.name.SET.args[0]._target.name
  } else {
    // simple select
    name = req.target.name
  }

  return { name: ensureUnlocalized(ensureNoDraftsSuffix(name)) }
}

const getTargetWrite = (target, model) => {
  return model.definitions[ensureUnlocalized(ensureNoDraftsSuffix(target.name))]
}

const isExtendedEntity = (entityName, model) => {
  const entity = model.definitions[ensureUnlocalized(ensureNoDraftsSuffix(entityName))]
  if (!entity) return false

  return entity.elements[EXT_BACK_PACK] || Object.values(entity.elements).some(el => el['@cds.extension'])
}

const _hasExtendedEntityArgs = (args, model) => {
  return args.find(arg => {
    if (arg.ref) {
      return arg.ref[0] !== 'DRAFT.DraftAdministrativeData' && isExtendedEntity(arg.ref[0], model)
    }

    if (arg.join) {
      return _hasExtendedEntityArgs(arg.args, model)
    }
  })
}

const _hasExtendedExpand = (columns, targetName, model) => {
  for (const col of columns) {
    if (col.ref && col.expand) {
      let targetNameModel = ensureUnlocalized(ensureNoDraftsSuffix(targetName))
      if (cds.env.fiori?.lean_draft) targetNameModel = targetNameModel.replace(/\.drafts$/,'')
      const expTargetName = model.definitions[targetNameModel].elements[col.ref[col.ref.length - 1]].target
      if (isExtendedEntity(expTargetName, model)) return true
      _hasExtendedExpand(col.expand, expTargetName, model)
    }
  }
}

const hasExtendedEntity = (req, model) => {
  if (!req.query.SELECT) return false

  if (req.query.SELECT.columns && req.target && _hasExtendedExpand(req.query.SELECT.columns, req.target.name, model)) {
    return true
  }

  if (req.query.SELECT.from.join && req.query.SELECT.from.args) {
    return _hasExtendedEntityArgs(req.query.SELECT.from.args, model)
  }

  if (req.target) {
    if (req.target.name.SET) {
      return isExtendedEntity(req.target.name.SET.args[0]._target.name, model)
    }

    return isExtendedEntity(req.target.name, model)
  }
}

const getExtendedFields = (entityName, model) => {
  const elements = model.definitions[ensureUnlocalized(ensureNoDraftsSuffix(entityName))].elements

  return Object.values(elements)
    .filter(element => {
      return element['@cds.extension']
    })
    .map(element => {
      return element.name
    })
}

const getCompilerError = messages => {
  const defaultMsg = 'Error while compiling extension'
  if (!messages) return defaultMsg

  for (const msg of messages) {
    if (msg.severity === 'Error') return msg.message
  }

  return defaultMsg
}

// REVISIT: opt-in/out retry mechanism on runtime layer?
// Sketch: cds.tx({ tenant: 't1', retries: 2 }, ...)
// Not for all error cases a retry is an appropriate handling mechanism (e.g. 403)
// -> error code allow/blocklist

/**
 * @template T
 * @param {() => Promise<T>} fn
 * @param {number} [retryCount=5]
 * @param {number} [retryGap=5000]
 * @returns {Promise<T>}
 */
const retry = async(fn, retryCount = 5, retryGap = 5 * 1000) => {

  let errorCount = 0
  let finalError
  while (errorCount < retryCount - 1) {
    try {
      return await fn() // eslint-disable-line no-await-in-loop
    } catch (error) {
      if (error.code === 400) throw error
      if (error.code === 'SQLITE_ERROR') throw error // REVISIT: ugly -> shouldn't have to code for specific DBs
      finalError = error
      errorCount++
      LOG.error('attempt', errorCount, 'errored with', error, '- retrying attempt', errorCount + 1, 'of', retryCount)
      await promisify(setTimeout)(retryGap) // eslint-disable-line no-await-in-loop
    }
  }
  LOG.error(`exceeded maximum number of ${retryCount} retries`)
  throw finalError
}

const t0 = cds.env.requires.multitenancy?.t0 ?? 't0'
let _t0Csn
const t0_ = async (query) => retry(async () => {
  _t0Csn ??= cds.compile.for.nodejs(
    await cds.load(`${__dirname}/../db/t0.cds`, { silent: true })
  )
  return cds.tx({ tenant: t0 }, tx => { tx.model = _t0Csn; return tx.run(query) })
})

module.exports = {
  EXT_BACK_PACK,
  getTargetRead,
  getTargetWrite,
  isExtendedEntity,
  hasExtendedEntity,
  getExtendedFields,
  getCompilerError,
  t0_,
  retry,
}
