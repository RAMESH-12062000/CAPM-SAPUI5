const { EXT_BACK_PACK, getTargetWrite, isExtendedEntity } = require('../../../lib/utils')

// REVISIT: eleminiate usage of these helpers
const getTemplate = require('@sap/cds/libx/_runtime/common/utils/template') // bad
const templateProcessor = require('@sap/cds/libx/_runtime/common/utils/templateProcessor') // bad

const _pick = element => {
  return element['@cds.extension']
}

const _processorFn = ({ row, key }) => {
  if (row[key] === undefined) return

  if (!row[EXT_BACK_PACK]) {
    row[EXT_BACK_PACK] = '{}'
  }

  const json = JSON.parse(row[EXT_BACK_PACK])
  json[key] = row[key]
  row[EXT_BACK_PACK] = JSON.stringify(json)
  delete row[key]
}

function transformExtendedFieldsCREATE(req) {
  if (cds.db.cqn2sql) return // Is done properly in better-sqlite
  if (!req.query) return // FIXME: the code below expects req.query to be defined
  if (!req.target) return
  if (!req.query.INSERT.entries) return // REVISIT: breaks at cds.deploy -> should anyways not kick in during cds.deploy

  const target = getTargetWrite(req.target, this.model)
  const template = getTemplate('transform-write', this, target, { pick: _pick })

  if (template && template.elements.size > 0) {
    for (const row of req.query.INSERT.entries) {
      const args = { processFn: _processorFn, row, template }
      templateProcessor(args)
    }
  }
}

async function transformExtendedFieldsUPDATE(req) {
  if (!req.target || !(req.query.UPDATE.entity?.ref?.[0]?.where ||req.query.UPDATE.where)) return

  const target = getTargetWrite(req.target, this.model)
  const template = getTemplate('transform-write', Object.assign(req, { model: this.model }), target, { pick: _pick })

  if (template && template.elements.size > 0) {
    // In patch case we first should obtain backpack from db.
    // Patch can be only applied to the root.
    if (isExtendedEntity(target.name, this.model)) {
      const current = await SELECT.from(req.query.UPDATE.entity).columns([EXT_BACK_PACK]).where(req.query.UPDATE.where)

      if (current[0]) {
        // unpack back pack before and merge back flat
        if(current[0][EXT_BACK_PACK]) {
          Object.assign(current[0],JSON.parse(current[0][EXT_BACK_PACK]))
          delete current[0][EXT_BACK_PACK]
        }
        req.data[EXT_BACK_PACK] = req.data[EXT_BACK_PACK] || JSON.stringify(current[0])
      }
    }

    const args = { processFn: _processorFn, row: req.data, template }
    templateProcessor(args)
  }
}

module.exports = {
  transformExtendedFieldsCREATE,
  transformExtendedFieldsUPDATE
}
