const cds = require('@sap/cds/lib'), { fs, path, tar, rimraf } = cds.utils
const linter = require('./linter')

const main = require('../config')

const activate = require('./activate')
const { getCompilerError } = require('../../lib/utils')
const { addCodeAnnotations } = require('./code-extensibility/addCodeAnnotProd')
const { readData } = require('./utils')

const TEMP_DIR = fs.realpathSync(require('os').tmpdir())
const LOG = cds.log('mtx')

const _readProject = async function (extension, req) {
  const root = await fs.promises.mkdtemp(`${TEMP_DIR}${path.sep}extension-`)
  try {
    const { extCsn, bundles, csvs } = await readData(extension, root)

    if (main.requires.extensibility?.code) await addCodeAnnotations(root, extCsn, req.tenant)

    return { extCsn, bundles, csvs }
  } finally {
    rimraf (root)
  }
}

const pull = async function (req) {
  LOG.info(`pulling latest model for tenant '${req.tenant}'`)
  const { 'cds.xt.ModelProviderService': mps } = cds.services
  const csn = await mps.getCsn({
    tenant: req.tenant,
    toggles: Object.keys(cds.context.features || {}), // with all enabled feature extensions
    base: true, // without any custom extensions
    flavor: 'xtended'
  })

  req.http.res?.set('content-type', 'application/octet-stream; charset=binary')

  const temp = await fs.promises.mkdtemp(`${TEMP_DIR}${path.sep}extension-`)
  try {
    await fs.promises.writeFile(path.join(temp, 'index.csn'), cds.compile.to.json(csn))
    const config = linter.configCopyFrom(cds.env)
    await fs.promises.writeFile(path.join(temp, '.cdsrc.json'), JSON.stringify(config, null, 2))
    return await tar.cz(temp)
  } finally {
    rimraf (temp)
  }
}

const push = async function ExtensibilityService_push (req) {
  let { extension, tag } = req.data
  if (!req.user.is('internal-user') && req.data.tenant && req.data.tenant !== req.tenant)
    req.reject(403, `No permission to push extensions to tenants other than ${req.tenant}`)
  const tenant = (req.user.is('internal-user') && req.data.tenant) || req.tenant
  if (tenant) cds.context = { tenant }

  if (!extension) req.reject(400, 'Missing extension')
  const sources = typeof extension === 'string' ? Buffer.from(extension, 'base64') : extension
  const { extCsn, bundles, csvs } = await _readProject(sources, req)
  if (!extCsn.extensions && !extCsn.definitions) req.reject(400, 'Missing or bad extension')
  if (!tag) tag = null

  // remove current extension with tag
  if (tag) await DELETE.from('cds.xt.Extensions').where({ tag })

  // insert and activate extension
  const ID = cds.utils.uuid()
  await INSERT.into('cds.xt.Extensions').entries({
    ID,
    csn: JSON.stringify(extCsn),
    i18n: bundles ? JSON.stringify(bundles) : null,
    sources,
    activated: 'database',
    tag
  })

  // do validation after extension table update - trust transaction handling for rollback
  // compiler validation
  LOG.info(`validating extension '${tag}' ...`)
  const { 'cds.xt.ModelProviderService': mps } = cds.services
  // REVISIT: Isn't that also done during activate?

  let csn
  try {
    csn = await mps.getCsn(tenant, Object.keys(cds.context.features || {}))
  } catch (err) {
    return req.reject(400, getCompilerError(err.messages))
  }

  // extension linters
  const findings = linter.lint(extCsn, csn)
  if (findings.length > 0) {
    let message = `Validation for ${tag} failed with ${findings.length} finding(s):\n\n`
    message += findings.map(f => '  - ' + f.message).join('\n') + '\n'
    return req.reject(422, message)
  }

  LOG.info(`activating extension '${tag}' ...`)
  const async = cds.context.http?.req?.headers?.prefer === 'respond-async'
  await activate(ID, null, tenant, csvs, async)
}

module.exports = { push, pull }
