const LinterMessage = require('./message')

module.exports = class NamespaceChecker {
  check(extensionCsn, fullCsn, compileDir, mtxConfig) {
    let elementPrefixes = mtxConfig['element-prefix']
    let namespaceBlocklist = mtxConfig['namespace-blocklist'] || mtxConfig['namespace-blacklist']
    const messages = []

    if (elementPrefixes) {
      if (!Array.isArray(elementPrefixes)) {
        elementPrefixes = [elementPrefixes]
      }

      if (extensionCsn.extensions) {
        // forall switches back to definitions if extensions are undefined
        extensionCsn.forall(
          () => true,
          (element, name, parent) => {
            element.name = name // TODO check if bug
            this._checkElement(element, parent, elementPrefixes, compileDir, messages)
          },
          extensionCsn.extensions
        )
      }

      extensionCsn.forall(
        element => {
          return ['entity', 'function', 'action'].includes(element.kind)
        },
        entity => {
          this._checkEntity(entity, extensionCsn, fullCsn, elementPrefixes, compileDir, messages)
        }
      )
    }

    if (namespaceBlocklist) {
      if (!Array.isArray(namespaceBlocklist)) {
        namespaceBlocklist = [namespaceBlocklist]
      }

      extensionCsn.forall('service', service => {
        this._checkNamespace(service, namespaceBlocklist, compileDir, messages)
      })

      extensionCsn.forall(
        element => {
          return ['aspect', 'entity', 'type'].includes(element.kind)
        },
        entity => {
          if (entity._unresolved) return // skip unresolved entities
          this._checkNamespace(entity, namespaceBlocklist, compileDir, messages)
        }
      )
    }

    return messages
  }

  _checkElement(element, parent, elementPrefixes, compileDir, messages) {
    if (elementPrefixes.length < 1) {
      return
    }

    if (!parent) {
      return
    }

    for (const elementPrefix of elementPrefixes) {
      if (!parent.extend || element.name.startsWith(elementPrefix)) {
        return
      }
    }

    messages.push(this._createPrefixWarning(element, parent, elementPrefixes))
  }

  _checkEntity(element, reflectedCsn, reflectedFullCsn, elementPrefixes, compileDir, messages) {
    if (elementPrefixes.length < 1) {
      return
    }

    const parent = this._getEnclosingEntity(reflectedCsn, element)

    // parent exists in extension
    if (parent) {
      return
    }

    // check full csn for parent
    let elementName
    const parentFromFullCsn = this._getEnclosingEntity(reflectedFullCsn, element)
    if (!parentFromFullCsn) {
      elementName = element.name
    } else {
      elementName = this._getNestedEntityName(element, parentFromFullCsn.name) || element.name
    }

    for (const elementPrefix of elementPrefixes) {
      if (elementName.startsWith(elementPrefix)) {
        return
      }
    }

    messages.push(this._createPrefixWarning(element, parentFromFullCsn, elementPrefixes))
  }

  _hasEnclosingEntity(reflectedCsn, element) {
    const plainEntityName = element.name.replace(reflectedCsn.namespace + '.', '')
    const splitEntityName = plainEntityName.split('.')
    if (splitEntityName.length > 1) {
      return true
    }
    return false
  }

  // TODO set parent entity name / check original test cases
  _getEnclosingEntity(reflectedCsn, element) {
    const splitEntityName = element.name.split('.')
    if (splitEntityName.length > 1) {
      splitEntityName.pop()
      return reflectedCsn.definitions[splitEntityName.join('.')]
    }
    return null
  }

  _getNestedEntityName(element, parentName) {
    return element.name.replace(parentName + '.', '')
  }

  _checkNamespace(element, namespaceBlacklist, compileDir, messages) {
    for (const namespace of namespaceBlacklist) {
      if (element.name.startsWith(namespace)) {
        messages.push(this._createNamespaceWarning(element, compileDir, namespace))
      }
    }
  }

  _createPrefixWarning(element, parent, prefixRule) {
    let message = `Element '${element.name}' ${parent ? `in '${parent.extend || parent.name}'` : ''} must start with ${prefixRule}`
    return new LinterMessage(message, element)
  }

  _createNamespaceWarning(element, compileDir, namespace) {
    let message = `Element '${element.name}' uses a forbidden namespace '${namespace}'`
    return new LinterMessage(message, element)
  }
}
