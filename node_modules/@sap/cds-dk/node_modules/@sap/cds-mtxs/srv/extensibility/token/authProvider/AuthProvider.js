const { URL } = require('url');
const https = require('https');

const { assertDefined, assertEqualNonSecret, assertEqualSecret, snipValue, snipCert } = require('./util/SecretsUtil');

/**
 * Provides data for OAuth authorization requests.
 * While this base class provides client authentication, subclasses provide request bodies.
 */
module.exports = class AuthProvider {

    /**
     * Validates all data referring to client authentication or used by other methods of this class.
     */
    static #validate(credentials) {
        assertDefined('credentials', credentials);
        assertDefined('credentials.clientid', credentials.clientid);
        assertDefined('credentials.xsappname', credentials.xsappname);

        if (credentials.certificate) {
            // X.509
            assertDefined('credentials.certurl', credentials.certurl);
            assertDefined('credentials.key', credentials.key);
        } else {
            assertDefined('credentials.url', credentials.url);
            assertDefined('credentials.clientsecret', credentials.clientsecret);
        }
    }

    static urlencoded(dataObj) {
        return new URLSearchParams(dataObj).toString();
    }

    /**
     * Authenticates the query by verifying query.clientsecret or query.key (mTLS).
     * Other secrets, which only UAA can verify for authentication (passcode, refresh_token), can be ignored here.
     * When these are used to obtain a token, calling this method is not required.
     */
    static authenticateQuery(query, credentials) {
        assertEqualNonSecret('query.clientid', query.clientid, credentials.clientid);
        if (credentials.certificate) {
            // mTLS (X.509 Client Authentication): verify Private Key
            assertEqualSecret('query.key', query.key, credentials.key);
        } else {
            // TODO don't allow attacker to brute-force clientsecret
            assertEqualSecret('query.clientsecret', query.clientsecret, credentials.clientsecret);
        }
    }

    credentials;
    query;
    #authUrl;
    #clientAuth;

    constructor(credentials, query) {
        AuthProvider.#validate(credentials);
        this.credentials = credentials;
        this.query = query;
    }

    get authUrl() {
        if (!this.#authUrl) {
            const url = new URL(this.credentials.certurl ?? this.credentials.url);
            if (this.query.subdomain) {
                url.hostname = url.hostname.replace(/^[^.]+/, this.query.subdomain);
            }
            url.pathname = '/oauth/token';
            this.#authUrl = url.toString();
        }
        return this.#authUrl;
    }

    /**
     * Returns data suitable as `config` parameter of `axios.post()`.
     */
    get clientAuth() {
        if (!this.#clientAuth) {
            this.#clientAuth = this.credentials.certificate
                ? {
                    httpsAgent: new https.Agent({
                        cert: this.credentials.certificate,
                        key: this.credentials.key
                    })
                }
                : {
                    auth: {
                        username: this.credentials.clientid,
                        password: this.credentials.clientsecret
                    }
                };
        }
        return this.#clientAuth;
    }

    get scope() {
        return this.credentials.xsappname + '.cds.ExtensionDeveloper';
    }

    clientAuthToLog() {
        return this.clientAuth.httpsAgent
            ? `X.509 (mTLS) with certificate '${snipCert(this.credentials.certificate)}'`
            : `Basic Auth with username '${this.clientAuth.auth.username}'`;
    }

    postDataToLog() {
        const publicParams = ['grant_type', 'client_id', 'scope'];
        return this.postData
            .split('&')
            .map(entry => {
                    let [k, v] = entry.split('=');
                    if (publicParams.includes(k)) {
                        return entry;
                    }
                    return `${k}=${snipValue(v)}`;
                }
            )
            .join('&');
    }

    /* More methods in derived classes */
}
