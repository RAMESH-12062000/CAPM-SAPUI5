const https = require('https')
const cds = require('@sap/cds')
const LOG = cds.log('mtx'), DEBUG = cds.debug('mtx|sm')
const { uuid } = cds.utils
const { cacheBindings = true } = cds.env.requires.multitenancy ?? {}
const { sm_url, url, clientid, clientsecret, certurl, certificate, key } = cds.env.requires.db.credentials
const axios = require('axios')
const api = axios.create({ baseURL: sm_url + '/v1/', headers: { 'Content-Type': 'application/json' }})
api.interceptors.request.use(async conf => {
  conf.headers.Authorization = await _token()
  DEBUG?.(conf.method.toUpperCase(), conf.baseURL + conf.url, {
    ...(conf.params && { params: conf.params }),
    ...(conf.data && { data: conf.data })
  })
  return conf
})
api.interceptors.response.use(response => response, require('../../../lib/pruneAxiosErrors'))

/* API */

async function create(tenant, parameters) {
  LOG.info('creating HDI container for', { tenant }, ...(parameters ? ['with', { ...parameters }] : []))
  const name = await _instanceName4(tenant), service_plan_id = await _planId()
  const { binding_parameters, provisioning_parameters } = parameters ?? {}
  let _instance, service_instance_id
  try {
    _instance = await api.post('service_instances?async=true', {
      name, service_plan_id, parameters: provisioning_parameters,
      labels: { tenant_id: [tenant] },
    })
    service_instance_id = (await _poll(_instance.headers.location)).resource_id
  } catch (e) {
    const status = e.status ?? 500
    if (status === 409 || e.error === 'Conflict') {
      const instance = await _instance4(tenant)
      if (!instance.ready || !instance.usable) {
        const faultyInstance = await api.get(`service_instances/${instance.id}`)
        const errors = faultyInstance?.data?.last_operation?.errors
        e.message ??= ''
        e.message += `${e.error}: ${e.description}. Last operation: ${errors?.error} ${errors?.description}`
        throw e
      }
      service_instance_id = instance.id
    } else {
      cds.error(_errorMessage(e, 'creating', tenant), { status })
    }
  }
  const _binding = await api.post('service_bindings?async=true', {
    name: tenant + `-${uuid()}`, service_instance_id, binding_parameters,
    labels: { tenant_id: [tenant], service_plan_id: [service_plan_id], managing_client_lib: ['instance-manager-client-lib'] }
  })
  await _poll(_binding.headers.location)
  const binding = { ...await get(tenant), tags: ['hana'] }
  return cacheBindings ? _bindings4.cached[tenant] = binding : binding
}

async function acquire(tenant, parameters) {
  try { return await get(tenant, { disableCache: true }) } catch (e) {
    if (e.status === 404) return create(tenant, parameters)
    throw e
  }
}

async function get(tenant, options) {
  let credentials, result
  try {
    [{ credentials } = {}] = await _bindings4([tenant], options)
    result = { name: await _instanceName4(tenant), tenant_id: tenant, credentials, tags: ['hana'] }
  } catch (e) {
    cds.error(_errorMessage(e, 'getting', tenant), { status: e.status ?? 500 })
  }
  if (!credentials) cds.error(`Tenant '${tenant}' does not exist`, { status: 404 })
  return result
}

function getAll(tenants = '*', options) { // REVISIT: mirroring @sap/instance-manager, remove in favor of `get(tenants = '*')`
  return _bindings4(tenants, options)
}

function deploy(container, tenant, out, options) {
  return require('./hdi').deploy(container, tenant, out, options)
}

async function remove(tenant) {
  const bindings = await _bindings4([tenant], { disableCache: true })
  const _deleteBindings = bindings.map(async ({ id }) =>
    _poll((await api.delete(`service_bindings/${id}?async=true`)).headers.location)
  )
  if (cacheBindings) delete _bindings4.cached[tenant]
  const failedDeletions = (await Promise.allSettled(_deleteBindings)).filter(d => d.status === 'rejected')
  //if (failedDeletions.length > 0) throw new AggregateError(failedDeletions.map(d => d.reason)) // REVISIT: Node 15+
  if (failedDeletions.length > 0) throw failedDeletions[0].reason
  const instance = await _instance4(tenant)
  if (instance) {
    const _deleteInstance = await api.delete(`service_instances/${instance.id}?async=true`)
    if (_deleteInstance.headers.location) await _poll(_deleteInstance.headers.location)
  }
}

module.exports = { create, get, getAll, acquire, deploy, delete: remove }

/* Private helpers */

async function _instance4(tenant) {
  const fieldQuery = `name eq '${await _instanceName4(tenant)}'`
  const instances = await api.get('service_instances?async=true', { params: { fieldQuery }})
  return instances.data.items[0]
}

async function _instanceName4(tenant) {
  if (cds.requires.multitenancy?.humanReadableInstanceName) return tenant
  // Compatible with @sap/instance-manager-created instances
  return require('crypto').createHash('sha256').update(`${await _planId()}_${tenant}`).digest('base64')
}

_bindings4.cached = {}
async function _bindings4(tenants, { disableCache = false } = {}) {
  const useCache = cacheBindings && !disableCache && tenants !== '*'
  const uncached = useCache ? tenants.filter(t => !(t in _bindings4.cached)) : tenants
  DEBUG?.('retrieving', { tenants }, { uncached })
  if (uncached.length === 0) return tenants.map(t => _bindings4.cached[t])
  const _tenantFilter = () => ` and tenant_id in (${uncached.map(t => `'${t}'`).join(', ')})`
  const tenantFilter = tenants === '*' ? '' : _tenantFilter()
  const labelQuery = `service_plan_id eq '${await _planId()}'` + tenantFilter
  const fieldQuery = `ready eq 'true'`
  const fetched = []; let token
  do {
    // eslint-disable-next-line no-await-in-loop
    const { items, token: nextPageToken } = (await api.get('service_bindings', { params: { token, labelQuery, fieldQuery }})).data
    fetched.push(...items)
    token = nextPageToken
  } while (token)
  if (useCache) {
    const cacheMisses = Object.fromEntries(fetched.filter(b => b.labels?.tenant_id).map(b => [b.labels.tenant_id[0], b]))
    Object.assign(_bindings4.cached, cacheMisses)
    return tenants.map(t => _bindings4.cached[t])
  }
  return fetched
}

async function _planId() {
  if (_planId.cached) return _planId.cached
  const fieldQuery = `catalog_name eq 'hdi-shared' and service_offering_id eq '${await _offeringId()}'`
  const { data } = await api.get('service_plans', { params: { fieldQuery }})
  const [planId] = data.items
  if (!planId) cds.error(`Could not find service plan with ${fieldQuery}`)
  return _planId.cached = data.items[0].id
}

async function _offeringId() {
  if (_offeringId.cached) return _offeringId.cached
  const fieldQuery = `catalog_name eq 'hana'`
  const { data } = await api.get('service_offerings', { params: { fieldQuery }})
  const [offeringId] = data.items
  if (!offeringId) cds.error(`Could not find service offering with ${fieldQuery}`)
  return _offeringId.cached = data.items[0].id
}

async function _token() {
  if (!_token.cached || _token.cached.expiry < Date.now() + 30000) {
    const auth = certificate ? { maxRedirects: 0, httpsAgent: new https.Agent({ cert: certificate, key }) }
                             : { auth: { username: clientid, password: clientsecret } }
    const authUrl = `${certurl ?? url}/oauth/token`
    const data = `grant_type=client_credentials&client_id=${encodeURI(clientid)}`
    const config = { method: 'POST', timeout: 5000, data, ...auth }
    const { access_token, expires_in } = await fetchTokenResiliently(authUrl, config)
    _token.cached = { access_token, expiry: Date.now() + expires_in * 1000 }
  }
  return `Bearer ${_token.cached.access_token}`
}

function _poll(location) {
  let attempts = 0, maxAttempts = 60, pollingTimeout = 3000, maxTime = pollingTimeout * maxAttempts/1000
  const _next = async (resolve, reject) => {
    const { data, data: { state, errors } } = await api.get(location.slice('/v1/'.length))
    if (state === 'succeeded') return resolve(data)
    if (state === 'failed') return reject(errors[0] ?? errors)
    if (attempts > maxAttempts) return reject(new Error(`Polling ${location} timed out after ${maxTime} seconds`))
    setTimeout(++attempts && _next, 3000, resolve, reject)
  }
  return new Promise(_next)
}

function _errorMessage(e, action, tenant) {
  const msg = `Error ${action} tenant ${tenant}: ${e.response?.data?.error ?? e.code ?? e.message ?? 'unknown error'}`
  const cause = e.description || e.cause ? require('os').EOL + `Root Cause: ${e.description ?? e.cause}` : ''
  return msg + cause
}

const maxRetries = 3
const fetchTokenResiliently = module.exports.fetchTokenResiliently = async function (url, config, retriesLeft = maxRetries) {
  try {
      return (await axios(url, config)).data
  } catch (error) {
      const { status, headers } = error.response ?? { status: 500 }
      if (status in { 401: 1, 403: 1 } || retriesLeft === 0) throw error
      const attempt = maxRetries - retriesLeft + 1
      DEBUG?.(`fetching token attempt ${attempt} failed with`, { error })
      let delay = 0
      if (status === 429) {
          const retryAfter = headers['retry-after']
          if (retryAfter) delay = parseInt(retryAfter, 10) * 1000
          else throw error
      } else if (status in { 408: 1, 502: 1, 504: 1 }) {
          delay = 300 * 2 ** (attempt - 1)
      } else {
          delay = 1000 * 3 ** (attempt - 1)
      }
      await new Promise((resolve) => setTimeout(resolve, delay))
      return fetchTokenResiliently(url, config, retriesLeft - 1)
  }
}
