const cds = require('../../../')
const { toODataResult, postProcess } = require('../utils/result')
const querystring = require('node:querystring')
const { getKeysAndParamsFromPath, handleSapMessages } = require('../utils')
const { handleStreamProperties } = require('../../_runtime/common/utils/streamProp')

// REVISIT: move to or rewrite in libx/odata
const metaInfo = require('../../_runtime/cds-services/adapter/odata-v4/utils/metaInfo')
const { getPageSize } = require('../../_runtime/common/generic/paging')

const _getCount = result =>
  Array.isArray(result)
    ? result.reduce((acc, val) => {
        return acc + ((val && (val.$count || val._counted_)) || (val[0] && (val[0].$count || val[0]._counted_))) || 0
      }, 0)
    : result.$count || result._counted_ || 0

const _calculateNextLink = (req, result) => {
  const $skiptoken = result.$nextLink ?? _calculateSkiptoken(req, result)
  if ($skiptoken) {
    const queryParamsWithSkipToken = { ...req.http.req.query, $skiptoken }
    // REVISIT: slice replaces leading '/'. Always starts with '/'?
    result.$nextLink =
      req.http.req.path.slice(1) +
      '?' +
      querystring.stringify(queryParamsWithSkipToken, '&', '=', { encodeURIComponent: e => e })
  }
}

const _calculateSkiptoken = (req, result) => {
  const limit = Array.isArray(req.query) ? getPageSize(req.query[0]._target).max : req.query.SELECT.limit?.rows?.val
  const top = parseInt(req.http.req.query.$top)
  if (limit === result.length && limit !== top) {
    const token = req.http.req.query.$skiptoken
    if (cds.env.query.limit.reliablePaging && _reliablePagingPossible(req)) {
      const decoded = token && JSON.parse(Buffer.from(token, 'base64').toString())
      const skipToken = {
        r: (decoded?.r || 0) + limit,
        c: req.query.SELECT.orderBy.map(o => ({
          a: o.sort ? o.sort === 'asc' : true,
          k: o.ref[0],
          v: result[result.length - 1][o.ref[0]]
        }))
      }

      if (limit + (decoded?.r || 0) !== top) {
        return Buffer.from(JSON.stringify(skipToken)).toString('base64')
      }
    } else {
      return (token ? parseInt(token) : 0) + limit
    }
  }
}

const _reliablePagingPossible = req => {
  if (req.target._isDraftEnabled) return false
  if (cds.context?.http.req.query.$apply) return false
  if (req.query.SELECT.limit.offset?.val ?? req.query.SELECT.limit.offset > 0) return false
  if (req.query.SELECT.orderBy?.some(o => !o.ref)) return false
  return (
    !req.query.SELECT.columns ||
    req.query.SELECT.columns.some(c => c === '*' || c.ref?.[0] === '*') ||
    req.query.SELECT.orderBy?.every(o => req.query.SELECT.columns?.some(c => o.ref[0] === c.ref?.[0]))
  )
}

const _checkExpandDeep = (column, entity, namespace) => {
  const { expand } = column
  if (expand.length > 1 || expand[0] !== '*') {
    for (const expandColumn of expand) {
      if (expandColumn === '*') continue
      if (expandColumn.expand) {
        _checkExpandDeep(expandColumn, entity.elements[expandColumn.ref[0]]._target, namespace)
      }
    }
  }
  if (!entity.name.startsWith(namespace) && !entity._service) {
    // proxy, only add keys
    const asteriskIndex = column.expand.findIndex(e => e === '*')
    column.expand.splice(asteriskIndex)
    for (const key in entity.keys) {
      if (entity.elements[key].isAssociation) continue
      column.expand.push({ ref: [key] })
    }
  }
}

const resolveProxyExpands = ({ SELECT: { columns }, target: entity }, service) => {
  if (!columns) return

  for (const column of columns) {
    if (column.expand) {
      _checkExpandDeep(column, entity.elements[column.ref[0]]._target, service.namespace)
    }
  }
}

const _isNullableSingleton = query => query._target._isSingleton && query._target['@odata.singleton.nullable']

const _isToOneAssoc = query =>
  query.SELECT.from.ref.length > 1 && typeof query.SELECT.from.ref.slice(-1)[0] === 'string'

// basically stolen from old read handler without understanding it ^^
const _handleArrayOfQueries = (srv, req, res, next) => {
  const info = metaInfo(req._query, 'READ', srv, {}, req, false)
  const cdsReq = new cds.Request({ query: req._query, req, res })
  srv
    .dispatch(cdsReq)
    .then(result => {
      handleSapMessages(cdsReq, req, res)

      if (req.url.match(/\/\$count/)) {
        const count = Array.isArray(result)
          ? result.reduce((acc, val) => {
              return (
                acc + ((val && (val.$count || val._counted_)) || (val[0] && (val[0].$count || val[0]._counted_))) || 0
              )
            }, 0)
          : result.$count || result._counted_ || 0
        return res.set('Content-Type', 'text/plain').send(count.toString())
      }

      const adjustedResult = []
      if (cdsReq.query[0].SELECT.count) adjustedResult.$count = 0
      adjustedResult.push(...result[0])
      adjustedResult.$count += result[0].$count ? result[0].$count : 0
      for (let i = 1; i < result.length; i++) {
        adjustedResult.push(...result[i])
        adjustedResult.$count += result[i].$count ? result[i].$count : 0
        // Add OData context, if it deviates from main context
        if (info.metadata.contextUrl !== info.metadata.additionalContextUrl[i - 1])
          result[i].forEach(entry => (entry['@odata.context'] = info.metadata.additionalContextUrl[i - 1]))
      }
      result.splice(0, result.length, ...adjustedResult)
      if (cdsReq.query[0].SELECT.count) result.$count = adjustedResult.$count || 0
      result = toODataResult(result, info)
      res.set('Content-Type', 'application/json;IEEE754Compatible=true').send(result)
    })
    .catch(next)
}

module.exports = srv =>
  function read(req, res, next) {
    // disable express etag checks
    req.headers['cache-control'] = 'no-cache'

    if (req._preferReturn) {
      throw Object.assign(new Error(`The 'return' preference is not allowed in ${req.method} requests`), {
        statusCode: 400
      })
    }

    // $apply with concat -> multiple queries with special handling
    if (Array.isArray(req._query)) return _handleArrayOfQueries(srv, req, res, next)

    // REVISIT: better solution for _propertyAccess
    let {
      SELECT: { from },
      target,
      _propertyAccess
    } = req._query
    const { _query: query } = req

    // payload & params
    const { keys, params } = getKeysAndParamsFromPath(from, srv)
    const data = keys //> for read and delete, we provide keys in req.data

    // we need a cds.Request for multiple reasons, incl. params, headers, sap-messages, read after write, ...
    const cdsReq = new cds.Request({ query, data, params, req, res })
    Object.defineProperty(cdsReq, 'protocol', { value: 'odata-v4' })

    // REVISIT: what is this for? some tests fail without it... we should find a better solution!
    Object.defineProperty(query.SELECT, '_4odata', { value: true })

    // do now to get meta info before the query is rewritten + to know return type
    const info = metaInfo(query, 'READ', srv, {}, req, false)

    // FIXME: wrong contextUrl for SiblingEntity
    if (info.metadata.contextUrl.match(/\/SiblingEntity\//)) {
      const split = info.metadata.contextUrl.split('/')
      const i = split.findIndex(s => s === 'SiblingEntity')
      split.splice(i, 1)
      if (split[i - 1].match(/IsActiveEntity=false/)) {
        split[i - 1] = split[i - 1].replace('IsActiveEntity=false', 'IsActiveEntity=true')
        info.metadata.contextUrl = split.join('/')
      } else {
        info.metadata.contextUrl = split.join('/').replace(/IsActiveEntity=true/g, 'IsActiveEntity=false')
      }
    }

    const lastPathElement = req.path.split('/').slice(-1)[0]

    query.SELECT.columns ??= ['*']

    if (cds.env.effective.odata.proxies && cds.env.effective.odata.xrefs) {
      // REVISIT check above is still not perfect solution
      resolveProxyExpands(query, srv)
    }

    handleStreamProperties(target, query.SELECT.columns, srv.model)

    // REVISIT: what is this for? some tests fail without it... we should find a better solution!
    Object.defineProperty(query.SELECT, '_4odata', { value: true })

    return srv
      .dispatch(cdsReq)
      .then(result => {
        handleSapMessages(cdsReq, req, res)

        if (cdsReq.target._etag && result == null && cdsReq.headers['if-none-match']) {
          return res.status(304).end()
        }

        if (result == null) {
          if (_isNullableSingleton(query) || _isToOneAssoc(query)) return res.sendStatus(204)
          throw Object.assign(new Error(`Not Found`), {
            statusCode: 404
          })
        }

        if (_propertyAccess && result[_propertyAccess] === null) return res.sendStatus(204)

        if (lastPathElement === '$count') {
          result = _getCount(result)
          return res.set('Content-Type', 'text/plain').send(result.toString())
        } else if (lastPathElement === '$value' && _propertyAccess) {
          return res.set('Content-Type', 'text/plain').send(result[_propertyAccess].toString())
        }

        if (info.metadata.isCollection) _calculateNextLink(cdsReq, result)
        postProcess(cdsReq.target, srv, result)
        if (result['$etag']) res.set('etag', result['$etag'])
        result = toODataResult(result, info)

        // Express interprets numbers as HTTP status codes
        const isNumber = typeof result === 'number'
        res
          .set('Content-Type', isNumber ? 'text/plain' : 'application/json;IEEE754Compatible=true')
          .send(isNumber ? result.toString() : result)
      })
      .catch(next)
  }
