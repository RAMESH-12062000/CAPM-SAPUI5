const cds = require('../../../')
const { UPDATE, DELETE } = cds.ql

const { getKeysAndParamsFromPath, handleSapMessages } = require('../utils')

module.exports = srv =>
  function deleete(req, res, next) {
    if (req._preferReturn) {
      throw Object.assign(new Error(`The 'return' preference is not allowed in ${req.method} requests`), {
        statusCode: 400
      })
    }

    // REVISIT: better solution for query._propertyAccess
    const {
      SELECT: { one, from },
      target,
      _propertyAccess
    } = req._query

    if (!one) {
      // REVISIT: don't use "ENTITY.COLLECTION" as that's an okra term
      throw Object.assign(new Error('Method DELETE not allowed for ENTITY.COLLECTION'), { statusCode: 405 })
    }

    // payload & params
    const { keys, params } = getKeysAndParamsFromPath(from, srv)
    const data = keys //> for read and delete, we provide keys in req.data
    if (_propertyAccess) data[_propertyAccess] = null //> delete of property -> set to null

    // query
    const query = _propertyAccess ? UPDATE(from).set({ [_propertyAccess]: null }) : DELETE.from(from)

    // we need a cds.Request for multiple reasons, incl. params, headers, sap-messages, read after write, ...
    const cdsReq = new cds.Request({ query, data, params, req, res })
    Object.defineProperty(cdsReq, 'protocol', { value: 'odata-v4' })

    // rewrite event for draft-enabled entities
    if (target._isDraftEnabled && cdsReq.data.IsActiveEntity === false) cdsReq.event = 'CANCEL'

    return srv
      .dispatch(cdsReq)
      .then(result => {
        handleSapMessages(cdsReq, req, res)

        if (result === 0) throw Object.assign(new Error('Not found'), { statusCode: 404 })
        res.sendStatus(204)
      })
      .catch(next)
  }
