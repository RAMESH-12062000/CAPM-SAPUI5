const cds = require('../../../cds')

/**
 * This is the express handler for a specific OData endpoint.
 * Note: the same service can be served at different endpoints.
 */
module.exports = srv => {
  const okra = new OkraAdapter(srv)
  return okra.process.bind(okra)
}

let OData
function OkraAdapter(srv, model = srv.model) {
  const edm = cds.compile.to.edm(model, { service: srv.definition?.name || srv.name })
  OData ??= require('./OData')
  return new OData(edm, model, srv.options).addCDSServiceToChannel(srv)
}

//////////////////////////////////////////////////////////////////////////////
//
//  REVISIT: Move to ExtensibilityService
//
if (cds.requires.extensibility || cds.requires.toggles) {
  let unique = 0
  module.exports = srv => {
    const id = `${++unique} - ${srv.path}` // REVISIT: this is to allow running multiple express apps serving same endpoints, as done by some questionable tests
    return function ODataAdapter(req, res) {
      const model = cds.context?.model || srv.model
      if (!model._cached) Object.defineProperty(model, '_cached', { value: { touched: Date.now() } })

      // Note: cache is attached to model cache so they get disposed when models are evicted from cache
      let adapters = model._cached._odata_adapters || (model._cached._odata_adapters = {})
      let okra = adapters[id]
      if (!okra) {
        const _srv = { __proto__: srv, _real_srv: srv, model } // REVISIT: we need to do that better in new adapters
        okra = adapters[id] = new OkraAdapter(_srv, model)
      }
      return okra.process(req, res)
    }
  }
}
